import {
  $ as pE,
  Ab as Nh,
  B as Bh,
  Bb as RE,
  C as nm,
  Ca as SE,
  Cb as Fh,
  D as pi,
  Da as Ph,
  Db as Mh,
  E as gi,
  Ea as vE,
  Eb as Uh,
  F as Dh,
  Fa as IE,
  Fb as zh,
  G as to,
  H as Kn,
  Hb as jh,
  I as rm,
  Ib as BE,
  Jb as DE,
  K as sE,
  Kb as $r,
  L as mi,
  Lb as _E,
  Ma as CE,
  Mb as PE,
  N as oE,
  Na as kE,
  Nb as LE,
  O as im,
  Oa as ya,
  Ob as wi,
  P as aE,
  Pb as cm,
  Q as Vr,
  Qb as Pn,
  Rb as bi,
  S as sm,
  Sb as OE,
  T as cE,
  Tb as NE,
  U as uE,
  Ua as Lh,
  V as ts,
  Va as wa,
  W as ga,
  Wa as TE,
  X as lE,
  Y as hE,
  Z as fE,
  _ as dE,
  a as rt,
  aa as gE,
  b as eE,
  ba as mE,
  ca as no,
  d as ae,
  da as yE,
  e as Zs,
  f as tE,
  g as Ae,
  ga as wE,
  h as em,
  i as le,
  ia as ro,
  j as M,
  k as tm,
  ka as mt,
  l as nE,
  la as bE,
  m as Cu,
  ma,
  n as da,
  o as Xs,
  oa as AE,
  p as sr,
  pa as yi,
  q as pa,
  qa as ns,
  qb as ba,
  r as or,
  ra as om,
  s as rE,
  sa as EE,
  t as eo,
  ta as Tu,
  u as ar,
  v as ku,
  w as es,
  xa as _h,
  ya as xE,
  z as iE,
  za as am,
  zb as Oh,
} from "./chunk-FRM3FMZU.js";
import { c as WE, d as HE } from "./chunk-J6HUAGRI.js";
import { a as GB } from "./chunk-L7NZVLCG.js";
import { a as Wh, b as Hh, d as VE } from "./chunk-UV7ERROY.js";
import {
  Ra as hm,
  a as HB,
  d as VB,
  e as $B,
  f as jE,
} from "./chunk-DXA257HR.js";
import { a as um, c as je, m as lm } from "./chunk-URXTW6Z4.js";
import {
  b as qg,
  d as Qg,
  j as Su,
  l as vu,
  o as pn,
  q as Yg,
  r as KA,
  s as kh,
  v as qA,
} from "./chunk-2CMVC2QG.js";
import {
  $ as Gn,
  Db as ZA,
  Gb as fa,
  H as HA,
  Ha as Zg,
  Ia as br,
  K as VA,
  Ka as QA,
  L as Ke,
  M as oe,
  Mb as XA,
  N as Tt,
  Nb as ct,
  Pa as Iu,
  Q as $A,
  Rb as Hr,
  Tb as Oe,
  W as xe,
  Za as Wr,
  _ as dn,
  aa as Jg,
  ab as ir,
  c as Ch,
  ca as GA,
  cc as Rh,
  db as Xg,
  eb as JA,
  ia as xn,
  j as WA,
  k as Ys,
  m as Gg,
  n as Kg,
  p as rr,
  qb as Th,
  r as hn,
  s as xu,
  sa as _n,
  z as fn,
  za as Sn,
  zb as YA,
} from "./chunk-23ZZ27XK.js";
import { b as rs } from "./chunk-3VTBTNQ3.js";
import { H as Ie, I as ME } from "./chunk-YYSBJNVH.js";
import { a as UE, b as zE } from "./chunk-PV7NZOQN.js";
import { l as FE } from "./chunk-4467BSCR.js";
import {
  a as v,
  b as $,
  c as Eu,
  d as ln,
  e as ot,
  f as ve,
  g as Vg,
  i as Et,
  j as $g,
  k as Js,
  l as d,
  q as p,
} from "./chunk-KXQY476L.js";
var uI = ve((cI, _y) => {
  "use strict";
  p();
  (function (n) {
    if (typeof cI == "object" && typeof _y < "u") _y.exports = n();
    else if (typeof define == "function" && define.amd) define([], n);
    else {
      var e;
      typeof window < "u"
        ? (e = window)
        : typeof global < "u"
        ? (e = global)
        : typeof self < "u"
        ? (e = self)
        : (e = this),
        (e.bs58 = n());
    }
  })(function () {
    var n, e, t;
    return (function () {
      function r(i, s, o) {
        function a(l, h) {
          if (!s[l]) {
            if (!i[l]) {
              var f = typeof Eu == "function" && Eu;
              if (!h && f) return f(l, !0);
              if (c) return c(l, !0);
              var g = new Error("Cannot find module '" + l + "'");
              throw ((g.code = "MODULE_NOT_FOUND"), g);
            }
            var y = (s[l] = { exports: {} });
            i[l][0].call(
              y.exports,
              function (w) {
                var m = i[l][1][w];
                return a(m || w);
              },
              y,
              y.exports,
              r,
              i,
              s,
              o
            );
          }
          return s[l].exports;
        }
        for (var c = typeof Eu == "function" && Eu, u = 0; u < o.length; u++)
          a(o[u]);
        return a;
      }
      return r;
    })()(
      {
        1: [
          function (r, i, s) {
            Object.defineProperty(s, "__esModule", { value: !0 });
            function o(a) {
              if (a.length >= 255) throw new TypeError("Alphabet too long");
              let c = new Uint8Array(256);
              for (let m = 0; m < c.length; m++) c[m] = 255;
              for (let m = 0; m < a.length; m++) {
                let b = a.charAt(m),
                  I = b.charCodeAt(0);
                if (c[I] !== 255) throw new TypeError(b + " is ambiguous");
                c[I] = m;
              }
              let u = a.length,
                l = a.charAt(0),
                h = Math.log(u) / Math.log(256),
                f = Math.log(256) / Math.log(u);
              function g(m) {
                if (
                  (m instanceof Uint8Array ||
                    (ArrayBuffer.isView(m)
                      ? (m = new Uint8Array(
                          m.buffer,
                          m.byteOffset,
                          m.byteLength
                        ))
                      : Array.isArray(m) && (m = Uint8Array.from(m))),
                  !(m instanceof Uint8Array))
                )
                  throw new TypeError("Expected Uint8Array");
                if (m.length === 0) return "";
                let b = 0,
                  I = 0,
                  E = 0,
                  T = m.length;
                for (; E !== T && m[E] === 0; ) E++, b++;
                let B = ((T - E) * f + 1) >>> 0,
                  L = new Uint8Array(B);
                for (; E !== T; ) {
                  let W = m[E],
                    be = 0;
                  for (
                    let pe = B - 1;
                    (W !== 0 || be < I) && pe !== -1;
                    pe--, be++
                  )
                    (W += (256 * L[pe]) >>> 0),
                      (L[pe] = W % u >>> 0),
                      (W = (W / u) >>> 0);
                  if (W !== 0) throw new Error("Non-zero carry");
                  (I = be), E++;
                }
                let U = B - I;
                for (; U !== B && L[U] === 0; ) U++;
                let j = l.repeat(b);
                for (; U < B; ++U) j += a.charAt(L[U]);
                return j;
              }
              function y(m) {
                if (typeof m != "string")
                  throw new TypeError("Expected String");
                if (m.length === 0) return new Uint8Array();
                let b = 0,
                  I = 0,
                  E = 0;
                for (; m[b] === l; ) I++, b++;
                let T = ((m.length - b) * h + 1) >>> 0,
                  B = new Uint8Array(T);
                for (; m[b]; ) {
                  let W = c[m.charCodeAt(b)];
                  if (W === 255) return;
                  let be = 0;
                  for (
                    let pe = T - 1;
                    (W !== 0 || be < E) && pe !== -1;
                    pe--, be++
                  )
                    (W += (u * B[pe]) >>> 0),
                      (B[pe] = W % 256 >>> 0),
                      (W = (W / 256) >>> 0);
                  if (W !== 0) throw new Error("Non-zero carry");
                  (E = be), b++;
                }
                let L = T - E;
                for (; L !== T && B[L] === 0; ) L++;
                let U = new Uint8Array(I + (T - L)),
                  j = I;
                for (; L !== T; ) U[j++] = B[L++];
                return U;
              }
              function w(m) {
                let b = y(m);
                if (b) return b;
                throw new Error("Non-base" + u + " character");
              }
              return { encode: g, decodeUnsafe: y, decode: w };
            }
            s.default = o;
          },
          {},
        ],
        2: [
          function (r, i, s) {
            var o =
              (this && this.__importDefault) ||
              function (u) {
                return u && u.__esModule ? u : { default: u };
              };
            Object.defineProperty(s, "__esModule", { value: !0 });
            var a = o(r("base-x")),
              c = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
            s.default = (0, a.default)(c);
          },
          { "base-x": 1 },
        ],
      },
      {},
      [2]
    )(2);
  });
});
var kI = ve((Ec) => {
  "use strict";
  p();
  var Ny = Wh(),
    bc = Hh(),
    hI =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : null;
  Ec.Buffer = D;
  Ec.SlowBuffer = O8;
  Ec.INSPECT_MAX_BYTES = 50;
  var vd = 2147483647;
  Ec.kMaxLength = vd;
  D.TYPED_ARRAY_SUPPORT = B8();
  !D.TYPED_ARRAY_SUPPORT &&
    typeof console < "u" &&
    typeof console.error == "function" &&
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  function B8() {
    try {
      let n = new Uint8Array(1),
        e = {
          foo: function () {
            return 42;
          },
        };
      return (
        Object.setPrototypeOf(e, Uint8Array.prototype),
        Object.setPrototypeOf(n, e),
        n.foo() === 42
      );
    } catch {
      return !1;
    }
  }
  Object.defineProperty(D.prototype, "parent", {
    enumerable: !0,
    get: function () {
      if (D.isBuffer(this)) return this.buffer;
    },
  });
  Object.defineProperty(D.prototype, "offset", {
    enumerable: !0,
    get: function () {
      if (D.isBuffer(this)) return this.byteOffset;
    },
  });
  function Di(n) {
    if (n > vd)
      throw new RangeError(
        'The value "' + n + '" is invalid for option "size"'
      );
    let e = new Uint8Array(n);
    return Object.setPrototypeOf(e, D.prototype), e;
  }
  function D(n, e, t) {
    if (typeof n == "number") {
      if (typeof e == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return zy(n);
    }
    return gI(n, e, t);
  }
  D.poolSize = 8192;
  function gI(n, e, t) {
    if (typeof n == "string") return _8(n, e);
    if (ArrayBuffer.isView(n)) return P8(n);
    if (n == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof n
      );
    if (
      Jr(n, ArrayBuffer) ||
      (n && Jr(n.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < "u" &&
        (Jr(n, SharedArrayBuffer) || (n && Jr(n.buffer, SharedArrayBuffer))))
    )
      return My(n, e, t);
    if (typeof n == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    let r = n.valueOf && n.valueOf();
    if (r != null && r !== n) return D.from(r, e, t);
    let i = L8(n);
    if (i) return i;
    if (
      typeof Symbol < "u" &&
      Symbol.toPrimitive != null &&
      typeof n[Symbol.toPrimitive] == "function"
    )
      return D.from(n[Symbol.toPrimitive]("string"), e, t);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof n
    );
  }
  D.from = function (n, e, t) {
    return gI(n, e, t);
  };
  Object.setPrototypeOf(D.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(D, Uint8Array);
  function mI(n) {
    if (typeof n != "number")
      throw new TypeError('"size" argument must be of type number');
    if (n < 0)
      throw new RangeError(
        'The value "' + n + '" is invalid for option "size"'
      );
  }
  function D8(n, e, t) {
    return (
      mI(n),
      n <= 0
        ? Di(n)
        : e !== void 0
        ? typeof t == "string"
          ? Di(n).fill(e, t)
          : Di(n).fill(e)
        : Di(n)
    );
  }
  D.alloc = function (n, e, t) {
    return D8(n, e, t);
  };
  function zy(n) {
    return mI(n), Di(n < 0 ? 0 : jy(n) | 0);
  }
  D.allocUnsafe = function (n) {
    return zy(n);
  };
  D.allocUnsafeSlow = function (n) {
    return zy(n);
  };
  function _8(n, e) {
    if (((typeof e != "string" || e === "") && (e = "utf8"), !D.isEncoding(e)))
      throw new TypeError("Unknown encoding: " + e);
    let t = yI(n, e) | 0,
      r = Di(t),
      i = r.write(n, e);
    return i !== t && (r = r.slice(0, i)), r;
  }
  function Fy(n) {
    let e = n.length < 0 ? 0 : jy(n.length) | 0,
      t = Di(e);
    for (let r = 0; r < e; r += 1) t[r] = n[r] & 255;
    return t;
  }
  function P8(n) {
    if (Jr(n, Uint8Array)) {
      let e = new Uint8Array(n);
      return My(e.buffer, e.byteOffset, e.byteLength);
    }
    return Fy(n);
  }
  function My(n, e, t) {
    if (e < 0 || n.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (n.byteLength < e + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let r;
    return (
      e === void 0 && t === void 0
        ? (r = new Uint8Array(n))
        : t === void 0
        ? (r = new Uint8Array(n, e))
        : (r = new Uint8Array(n, e, t)),
      Object.setPrototypeOf(r, D.prototype),
      r
    );
  }
  function L8(n) {
    if (D.isBuffer(n)) {
      let e = jy(n.length) | 0,
        t = Di(e);
      return t.length === 0 || n.copy(t, 0, 0, e), t;
    }
    if (n.length !== void 0)
      return typeof n.length != "number" || Hy(n.length) ? Di(0) : Fy(n);
    if (n.type === "Buffer" && Array.isArray(n.data)) return Fy(n.data);
  }
  function jy(n) {
    if (n >= vd)
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          vd.toString(16) +
          " bytes"
      );
    return n | 0;
  }
  function O8(n) {
    return +n != n && (n = 0), D.alloc(+n);
  }
  D.isBuffer = function (e) {
    return e != null && e._isBuffer === !0 && e !== D.prototype;
  };
  D.compare = function (e, t) {
    if (
      (Jr(e, Uint8Array) && (e = D.from(e, e.offset, e.byteLength)),
      Jr(t, Uint8Array) && (t = D.from(t, t.offset, t.byteLength)),
      !D.isBuffer(e) || !D.isBuffer(t))
    )
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (e === t) return 0;
    let r = e.length,
      i = t.length;
    for (let s = 0, o = Math.min(r, i); s < o; ++s)
      if (e[s] !== t[s]) {
        (r = e[s]), (i = t[s]);
        break;
      }
    return r < i ? -1 : i < r ? 1 : 0;
  };
  D.isEncoding = function (e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  };
  D.concat = function (e, t) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0) return D.alloc(0);
    let r;
    if (t === void 0) for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
    let i = D.allocUnsafe(t),
      s = 0;
    for (r = 0; r < e.length; ++r) {
      let o = e[r];
      if (Jr(o, Uint8Array))
        s + o.length > i.length
          ? (D.isBuffer(o) || (o = D.from(o)), o.copy(i, s))
          : Uint8Array.prototype.set.call(i, o, s);
      else if (D.isBuffer(o)) o.copy(i, s);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      s += o.length;
    }
    return i;
  };
  function yI(n, e) {
    if (D.isBuffer(n)) return n.length;
    if (ArrayBuffer.isView(n) || Jr(n, ArrayBuffer)) return n.byteLength;
    if (typeof n != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof n
      );
    let t = n.length,
      r = arguments.length > 2 && arguments[2] === !0;
    if (!r && t === 0) return 0;
    let i = !1;
    for (;;)
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return Uy(n).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return CI(n).length;
        default:
          if (i) return r ? -1 : Uy(n).length;
          (e = ("" + e).toLowerCase()), (i = !0);
      }
  }
  D.byteLength = yI;
  function N8(n, e, t) {
    let r = !1;
    if (
      ((e === void 0 || e < 0) && (e = 0),
      e > this.length ||
        ((t === void 0 || t > this.length) && (t = this.length), t <= 0) ||
        ((t >>>= 0), (e >>>= 0), t <= e))
    )
      return "";
    for (n || (n = "utf8"); ; )
      switch (n) {
        case "hex":
          return G8(this, e, t);
        case "utf8":
        case "utf-8":
          return bI(this, e, t);
        case "ascii":
          return V8(this, e, t);
        case "latin1":
        case "binary":
          return $8(this, e, t);
        case "base64":
          return W8(this, e, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return K8(this, e, t);
        default:
          if (r) throw new TypeError("Unknown encoding: " + n);
          (n = (n + "").toLowerCase()), (r = !0);
      }
  }
  D.prototype._isBuffer = !0;
  function Ro(n, e, t) {
    let r = n[e];
    (n[e] = n[t]), (n[t] = r);
  }
  D.prototype.swap16 = function () {
    let e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < e; t += 2) Ro(this, t, t + 1);
    return this;
  };
  D.prototype.swap32 = function () {
    let e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < e; t += 4) Ro(this, t, t + 3), Ro(this, t + 1, t + 2);
    return this;
  };
  D.prototype.swap64 = function () {
    let e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < e; t += 8)
      Ro(this, t, t + 7),
        Ro(this, t + 1, t + 6),
        Ro(this, t + 2, t + 5),
        Ro(this, t + 3, t + 4);
    return this;
  };
  D.prototype.toString = function () {
    let e = this.length;
    return e === 0
      ? ""
      : arguments.length === 0
      ? bI(this, 0, e)
      : N8.apply(this, arguments);
  };
  D.prototype.toLocaleString = D.prototype.toString;
  D.prototype.equals = function (e) {
    if (!D.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
    return this === e ? !0 : D.compare(this, e) === 0;
  };
  D.prototype.inspect = function () {
    let e = "",
      t = Ec.INSPECT_MAX_BYTES;
    return (
      (e = this.toString("hex", 0, t)
        .replace(/(.{2})/g, "$1 ")
        .trim()),
      this.length > t && (e += " ... "),
      "<Buffer " + e + ">"
    );
  };
  hI && (D.prototype[hI] = D.prototype.inspect);
  D.prototype.compare = function (e, t, r, i, s) {
    if (
      (Jr(e, Uint8Array) && (e = D.from(e, e.offset, e.byteLength)),
      !D.isBuffer(e))
    )
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
          typeof e
      );
    if (
      (t === void 0 && (t = 0),
      r === void 0 && (r = e ? e.length : 0),
      i === void 0 && (i = 0),
      s === void 0 && (s = this.length),
      t < 0 || r > e.length || i < 0 || s > this.length)
    )
      throw new RangeError("out of range index");
    if (i >= s && t >= r) return 0;
    if (i >= s) return -1;
    if (t >= r) return 1;
    if (((t >>>= 0), (r >>>= 0), (i >>>= 0), (s >>>= 0), this === e)) return 0;
    let o = s - i,
      a = r - t,
      c = Math.min(o, a),
      u = this.slice(i, s),
      l = e.slice(t, r);
    for (let h = 0; h < c; ++h)
      if (u[h] !== l[h]) {
        (o = u[h]), (a = l[h]);
        break;
      }
    return o < a ? -1 : a < o ? 1 : 0;
  };
  function wI(n, e, t, r, i) {
    if (n.length === 0) return -1;
    if (
      (typeof t == "string"
        ? ((r = t), (t = 0))
        : t > 2147483647
        ? (t = 2147483647)
        : t < -2147483648 && (t = -2147483648),
      (t = +t),
      Hy(t) && (t = i ? 0 : n.length - 1),
      t < 0 && (t = n.length + t),
      t >= n.length)
    ) {
      if (i) return -1;
      t = n.length - 1;
    } else if (t < 0)
      if (i) t = 0;
      else return -1;
    if ((typeof e == "string" && (e = D.from(e, r)), D.isBuffer(e)))
      return e.length === 0 ? -1 : fI(n, e, t, r, i);
    if (typeof e == "number")
      return (
        (e = e & 255),
        typeof Uint8Array.prototype.indexOf == "function"
          ? i
            ? Uint8Array.prototype.indexOf.call(n, e, t)
            : Uint8Array.prototype.lastIndexOf.call(n, e, t)
          : fI(n, [e], t, r, i)
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  function fI(n, e, t, r, i) {
    let s = 1,
      o = n.length,
      a = e.length;
    if (
      r !== void 0 &&
      ((r = String(r).toLowerCase()),
      r === "ucs2" || r === "ucs-2" || r === "utf16le" || r === "utf-16le")
    ) {
      if (n.length < 2 || e.length < 2) return -1;
      (s = 2), (o /= 2), (a /= 2), (t /= 2);
    }
    function c(l, h) {
      return s === 1 ? l[h] : l.readUInt16BE(h * s);
    }
    let u;
    if (i) {
      let l = -1;
      for (u = t; u < o; u++)
        if (c(n, u) === c(e, l === -1 ? 0 : u - l)) {
          if ((l === -1 && (l = u), u - l + 1 === a)) return l * s;
        } else l !== -1 && (u -= u - l), (l = -1);
    } else
      for (t + a > o && (t = o - a), u = t; u >= 0; u--) {
        let l = !0;
        for (let h = 0; h < a; h++)
          if (c(n, u + h) !== c(e, h)) {
            l = !1;
            break;
          }
        if (l) return u;
      }
    return -1;
  }
  D.prototype.includes = function (e, t, r) {
    return this.indexOf(e, t, r) !== -1;
  };
  D.prototype.indexOf = function (e, t, r) {
    return wI(this, e, t, r, !0);
  };
  D.prototype.lastIndexOf = function (e, t, r) {
    return wI(this, e, t, r, !1);
  };
  function F8(n, e, t, r) {
    t = Number(t) || 0;
    let i = n.length - t;
    r ? ((r = Number(r)), r > i && (r = i)) : (r = i);
    let s = e.length;
    r > s / 2 && (r = s / 2);
    let o;
    for (o = 0; o < r; ++o) {
      let a = parseInt(e.substr(o * 2, 2), 16);
      if (Hy(a)) return o;
      n[t + o] = a;
    }
    return o;
  }
  function M8(n, e, t, r) {
    return Id(Uy(e, n.length - t), n, t, r);
  }
  function U8(n, e, t, r) {
    return Id(Y8(e), n, t, r);
  }
  function z8(n, e, t, r) {
    return Id(CI(e), n, t, r);
  }
  function j8(n, e, t, r) {
    return Id(Z8(e, n.length - t), n, t, r);
  }
  D.prototype.write = function (e, t, r, i) {
    if (t === void 0) (i = "utf8"), (r = this.length), (t = 0);
    else if (r === void 0 && typeof t == "string")
      (i = t), (r = this.length), (t = 0);
    else if (isFinite(t))
      (t = t >>> 0),
        isFinite(r)
          ? ((r = r >>> 0), i === void 0 && (i = "utf8"))
          : ((i = r), (r = void 0));
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    let s = this.length - t;
    if (
      ((r === void 0 || r > s) && (r = s),
      (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds");
    i || (i = "utf8");
    let o = !1;
    for (;;)
      switch (i) {
        case "hex":
          return F8(this, e, t, r);
        case "utf8":
        case "utf-8":
          return M8(this, e, t, r);
        case "ascii":
        case "latin1":
        case "binary":
          return U8(this, e, t, r);
        case "base64":
          return z8(this, e, t, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return j8(this, e, t, r);
        default:
          if (o) throw new TypeError("Unknown encoding: " + i);
          (i = ("" + i).toLowerCase()), (o = !0);
      }
  };
  D.prototype.toJSON = function () {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0),
    };
  };
  function W8(n, e, t) {
    return e === 0 && t === n.length
      ? Ny.fromByteArray(n)
      : Ny.fromByteArray(n.slice(e, t));
  }
  function bI(n, e, t) {
    t = Math.min(n.length, t);
    let r = [],
      i = e;
    for (; i < t; ) {
      let s = n[i],
        o = null,
        a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (i + a <= t) {
        let c, u, l, h;
        switch (a) {
          case 1:
            s < 128 && (o = s);
            break;
          case 2:
            (c = n[i + 1]),
              (c & 192) === 128 &&
                ((h = ((s & 31) << 6) | (c & 63)), h > 127 && (o = h));
            break;
          case 3:
            (c = n[i + 1]),
              (u = n[i + 2]),
              (c & 192) === 128 &&
                (u & 192) === 128 &&
                ((h = ((s & 15) << 12) | ((c & 63) << 6) | (u & 63)),
                h > 2047 && (h < 55296 || h > 57343) && (o = h));
            break;
          case 4:
            (c = n[i + 1]),
              (u = n[i + 2]),
              (l = n[i + 3]),
              (c & 192) === 128 &&
                (u & 192) === 128 &&
                (l & 192) === 128 &&
                ((h =
                  ((s & 15) << 18) |
                  ((c & 63) << 12) |
                  ((u & 63) << 6) |
                  (l & 63)),
                h > 65535 && h < 1114112 && (o = h));
        }
      }
      o === null
        ? ((o = 65533), (a = 1))
        : o > 65535 &&
          ((o -= 65536),
          r.push(((o >>> 10) & 1023) | 55296),
          (o = 56320 | (o & 1023))),
        r.push(o),
        (i += a);
    }
    return H8(r);
  }
  var dI = 4096;
  function H8(n) {
    let e = n.length;
    if (e <= dI) return String.fromCharCode.apply(String, n);
    let t = "",
      r = 0;
    for (; r < e; )
      t += String.fromCharCode.apply(String, n.slice(r, (r += dI)));
    return t;
  }
  function V8(n, e, t) {
    let r = "";
    t = Math.min(n.length, t);
    for (let i = e; i < t; ++i) r += String.fromCharCode(n[i] & 127);
    return r;
  }
  function $8(n, e, t) {
    let r = "";
    t = Math.min(n.length, t);
    for (let i = e; i < t; ++i) r += String.fromCharCode(n[i]);
    return r;
  }
  function G8(n, e, t) {
    let r = n.length;
    (!e || e < 0) && (e = 0), (!t || t < 0 || t > r) && (t = r);
    let i = "";
    for (let s = e; s < t; ++s) i += X8[n[s]];
    return i;
  }
  function K8(n, e, t) {
    let r = n.slice(e, t),
      i = "";
    for (let s = 0; s < r.length - 1; s += 2)
      i += String.fromCharCode(r[s] + r[s + 1] * 256);
    return i;
  }
  D.prototype.slice = function (e, t) {
    let r = this.length;
    (e = ~~e),
      (t = t === void 0 ? r : ~~t),
      e < 0 ? ((e += r), e < 0 && (e = 0)) : e > r && (e = r),
      t < 0 ? ((t += r), t < 0 && (t = 0)) : t > r && (t = r),
      t < e && (t = e);
    let i = this.subarray(e, t);
    return Object.setPrototypeOf(i, D.prototype), i;
  };
  function Kt(n, e, t) {
    if (n % 1 !== 0 || n < 0) throw new RangeError("offset is not uint");
    if (n + e > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  D.prototype.readUintLE = D.prototype.readUIntLE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Kt(e, t, this.length);
    let i = this[e],
      s = 1,
      o = 0;
    for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
    return i;
  };
  D.prototype.readUintBE = D.prototype.readUIntBE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Kt(e, t, this.length);
    let i = this[e + --t],
      s = 1;
    for (; t > 0 && (s *= 256); ) i += this[e + --t] * s;
    return i;
  };
  D.prototype.readUint8 = D.prototype.readUInt8 = function (e, t) {
    return (e = e >>> 0), t || Kt(e, 1, this.length), this[e];
  };
  D.prototype.readUint16LE = D.prototype.readUInt16LE = function (e, t) {
    return (
      (e = e >>> 0), t || Kt(e, 2, this.length), this[e] | (this[e + 1] << 8)
    );
  };
  D.prototype.readUint16BE = D.prototype.readUInt16BE = function (e, t) {
    return (
      (e = e >>> 0), t || Kt(e, 2, this.length), (this[e] << 8) | this[e + 1]
    );
  };
  D.prototype.readUint32LE = D.prototype.readUInt32LE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Kt(e, 4, this.length),
      (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
        this[e + 3] * 16777216
    );
  };
  D.prototype.readUint32BE = D.prototype.readUInt32BE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Kt(e, 4, this.length),
      this[e] * 16777216 +
        ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
    );
  };
  D.prototype.readBigUInt64LE = vs(function (e) {
    (e = e >>> 0), Ac(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && Bl(e, this.length - 8);
    let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24,
      s = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + r * 2 ** 24;
    return BigInt(i) + (BigInt(s) << BigInt(32));
  });
  D.prototype.readBigUInt64BE = vs(function (e) {
    (e = e >>> 0), Ac(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && Bl(e, this.length - 8);
    let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e],
      s = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r;
    return (BigInt(i) << BigInt(32)) + BigInt(s);
  });
  D.prototype.readIntLE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Kt(e, t, this.length);
    let i = this[e],
      s = 1,
      o = 0;
    for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
    return (s *= 128), i >= s && (i -= Math.pow(2, 8 * t)), i;
  };
  D.prototype.readIntBE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Kt(e, t, this.length);
    let i = t,
      s = 1,
      o = this[e + --i];
    for (; i > 0 && (s *= 256); ) o += this[e + --i] * s;
    return (s *= 128), o >= s && (o -= Math.pow(2, 8 * t)), o;
  };
  D.prototype.readInt8 = function (e, t) {
    return (
      (e = e >>> 0),
      t || Kt(e, 1, this.length),
      this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
    );
  };
  D.prototype.readInt16LE = function (e, t) {
    (e = e >>> 0), t || Kt(e, 2, this.length);
    let r = this[e] | (this[e + 1] << 8);
    return r & 32768 ? r | 4294901760 : r;
  };
  D.prototype.readInt16BE = function (e, t) {
    (e = e >>> 0), t || Kt(e, 2, this.length);
    let r = this[e + 1] | (this[e] << 8);
    return r & 32768 ? r | 4294901760 : r;
  };
  D.prototype.readInt32LE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Kt(e, 4, this.length),
      this[e] | (this[e + 1] << 8) | (this[e + 2] << 16) | (this[e + 3] << 24)
    );
  };
  D.prototype.readInt32BE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Kt(e, 4, this.length),
      (this[e] << 24) | (this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3]
    );
  };
  D.prototype.readBigInt64LE = vs(function (e) {
    (e = e >>> 0), Ac(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && Bl(e, this.length - 8);
    let i =
      this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (r << 24);
    return (
      (BigInt(i) << BigInt(32)) +
      BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
    );
  });
  D.prototype.readBigInt64BE = vs(function (e) {
    (e = e >>> 0), Ac(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && Bl(e, this.length - 8);
    let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (
      (BigInt(i) << BigInt(32)) +
      BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r)
    );
  });
  D.prototype.readFloatLE = function (e, t) {
    return (
      (e = e >>> 0), t || Kt(e, 4, this.length), bc.read(this, e, !0, 23, 4)
    );
  };
  D.prototype.readFloatBE = function (e, t) {
    return (
      (e = e >>> 0), t || Kt(e, 4, this.length), bc.read(this, e, !1, 23, 4)
    );
  };
  D.prototype.readDoubleLE = function (e, t) {
    return (
      (e = e >>> 0), t || Kt(e, 8, this.length), bc.read(this, e, !0, 52, 8)
    );
  };
  D.prototype.readDoubleBE = function (e, t) {
    return (
      (e = e >>> 0), t || Kt(e, 8, this.length), bc.read(this, e, !1, 52, 8)
    );
  };
  function Nn(n, e, t, r, i, s) {
    if (!D.isBuffer(n))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > i || e < s)
      throw new RangeError('"value" argument is out of bounds');
    if (t + r > n.length) throw new RangeError("Index out of range");
  }
  D.prototype.writeUintLE = D.prototype.writeUIntLE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), (r = r >>> 0), !i)) {
      let a = Math.pow(2, 8 * r) - 1;
      Nn(this, e, t, r, a, 0);
    }
    let s = 1,
      o = 0;
    for (this[t] = e & 255; ++o < r && (s *= 256); )
      this[t + o] = (e / s) & 255;
    return t + r;
  };
  D.prototype.writeUintBE = D.prototype.writeUIntBE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), (r = r >>> 0), !i)) {
      let a = Math.pow(2, 8 * r) - 1;
      Nn(this, e, t, r, a, 0);
    }
    let s = r - 1,
      o = 1;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
      this[t + s] = (e / o) & 255;
    return t + r;
  };
  D.prototype.writeUint8 = D.prototype.writeUInt8 = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 1, 255, 0),
      (this[t] = e & 255),
      t + 1
    );
  };
  D.prototype.writeUint16LE = D.prototype.writeUInt16LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 2, 65535, 0),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      t + 2
    );
  };
  D.prototype.writeUint16BE = D.prototype.writeUInt16BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 2, 65535, 0),
      (this[t] = e >>> 8),
      (this[t + 1] = e & 255),
      t + 2
    );
  };
  D.prototype.writeUint32LE = D.prototype.writeUInt32LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 4, 4294967295, 0),
      (this[t + 3] = e >>> 24),
      (this[t + 2] = e >>> 16),
      (this[t + 1] = e >>> 8),
      (this[t] = e & 255),
      t + 4
    );
  };
  D.prototype.writeUint32BE = D.prototype.writeUInt32BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 4, 4294967295, 0),
      (this[t] = e >>> 24),
      (this[t + 1] = e >>> 16),
      (this[t + 2] = e >>> 8),
      (this[t + 3] = e & 255),
      t + 4
    );
  };
  function AI(n, e, t, r, i) {
    II(e, r, i, n, t, 7);
    let s = Number(e & BigInt(4294967295));
    (n[t++] = s),
      (s = s >> 8),
      (n[t++] = s),
      (s = s >> 8),
      (n[t++] = s),
      (s = s >> 8),
      (n[t++] = s);
    let o = Number((e >> BigInt(32)) & BigInt(4294967295));
    return (
      (n[t++] = o),
      (o = o >> 8),
      (n[t++] = o),
      (o = o >> 8),
      (n[t++] = o),
      (o = o >> 8),
      (n[t++] = o),
      t
    );
  }
  function EI(n, e, t, r, i) {
    II(e, r, i, n, t, 7);
    let s = Number(e & BigInt(4294967295));
    (n[t + 7] = s),
      (s = s >> 8),
      (n[t + 6] = s),
      (s = s >> 8),
      (n[t + 5] = s),
      (s = s >> 8),
      (n[t + 4] = s);
    let o = Number((e >> BigInt(32)) & BigInt(4294967295));
    return (
      (n[t + 3] = o),
      (o = o >> 8),
      (n[t + 2] = o),
      (o = o >> 8),
      (n[t + 1] = o),
      (o = o >> 8),
      (n[t] = o),
      t + 8
    );
  }
  D.prototype.writeBigUInt64LE = vs(function (e, t = 0) {
    return AI(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  D.prototype.writeBigUInt64BE = vs(function (e, t = 0) {
    return EI(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  D.prototype.writeIntLE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), !i)) {
      let c = Math.pow(2, 8 * r - 1);
      Nn(this, e, t, r, c - 1, -c);
    }
    let s = 0,
      o = 1,
      a = 0;
    for (this[t] = e & 255; ++s < r && (o *= 256); )
      e < 0 && a === 0 && this[t + s - 1] !== 0 && (a = 1),
        (this[t + s] = (((e / o) >> 0) - a) & 255);
    return t + r;
  };
  D.prototype.writeIntBE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), !i)) {
      let c = Math.pow(2, 8 * r - 1);
      Nn(this, e, t, r, c - 1, -c);
    }
    let s = r - 1,
      o = 1,
      a = 0;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
      e < 0 && a === 0 && this[t + s + 1] !== 0 && (a = 1),
        (this[t + s] = (((e / o) >> 0) - a) & 255);
    return t + r;
  };
  D.prototype.writeInt8 = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 1, 127, -128),
      e < 0 && (e = 255 + e + 1),
      (this[t] = e & 255),
      t + 1
    );
  };
  D.prototype.writeInt16LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 2, 32767, -32768),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      t + 2
    );
  };
  D.prototype.writeInt16BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 2, 32767, -32768),
      (this[t] = e >>> 8),
      (this[t + 1] = e & 255),
      t + 2
    );
  };
  D.prototype.writeInt32LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 4, 2147483647, -2147483648),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      (this[t + 2] = e >>> 16),
      (this[t + 3] = e >>> 24),
      t + 4
    );
  };
  D.prototype.writeInt32BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Nn(this, e, t, 4, 2147483647, -2147483648),
      e < 0 && (e = 4294967295 + e + 1),
      (this[t] = e >>> 24),
      (this[t + 1] = e >>> 16),
      (this[t + 2] = e >>> 8),
      (this[t + 3] = e & 255),
      t + 4
    );
  };
  D.prototype.writeBigInt64LE = vs(function (e, t = 0) {
    return AI(
      this,
      e,
      t,
      -BigInt("0x8000000000000000"),
      BigInt("0x7fffffffffffffff")
    );
  });
  D.prototype.writeBigInt64BE = vs(function (e, t = 0) {
    return EI(
      this,
      e,
      t,
      -BigInt("0x8000000000000000"),
      BigInt("0x7fffffffffffffff")
    );
  });
  function xI(n, e, t, r, i, s) {
    if (t + r > n.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  function SI(n, e, t, r, i) {
    return (
      (e = +e),
      (t = t >>> 0),
      i || xI(n, e, t, 4, 34028234663852886e22, -34028234663852886e22),
      bc.write(n, e, t, r, 23, 4),
      t + 4
    );
  }
  D.prototype.writeFloatLE = function (e, t, r) {
    return SI(this, e, t, !0, r);
  };
  D.prototype.writeFloatBE = function (e, t, r) {
    return SI(this, e, t, !1, r);
  };
  function vI(n, e, t, r, i) {
    return (
      (e = +e),
      (t = t >>> 0),
      i || xI(n, e, t, 8, 17976931348623157e292, -17976931348623157e292),
      bc.write(n, e, t, r, 52, 8),
      t + 8
    );
  }
  D.prototype.writeDoubleLE = function (e, t, r) {
    return vI(this, e, t, !0, r);
  };
  D.prototype.writeDoubleBE = function (e, t, r) {
    return vI(this, e, t, !1, r);
  };
  D.prototype.copy = function (e, t, r, i) {
    if (!D.isBuffer(e)) throw new TypeError("argument should be a Buffer");
    if (
      (r || (r = 0),
      !i && i !== 0 && (i = this.length),
      t >= e.length && (t = e.length),
      t || (t = 0),
      i > 0 && i < r && (i = r),
      i === r || e.length === 0 || this.length === 0)
    )
      return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
    if (i < 0) throw new RangeError("sourceEnd out of bounds");
    i > this.length && (i = this.length),
      e.length - t < i - r && (i = e.length - t + r);
    let s = i - r;
    return (
      this === e && typeof Uint8Array.prototype.copyWithin == "function"
        ? this.copyWithin(t, r, i)
        : Uint8Array.prototype.set.call(e, this.subarray(r, i), t),
      s
    );
  };
  D.prototype.fill = function (e, t, r, i) {
    if (typeof e == "string") {
      if (
        (typeof t == "string"
          ? ((i = t), (t = 0), (r = this.length))
          : typeof r == "string" && ((i = r), (r = this.length)),
        i !== void 0 && typeof i != "string")
      )
        throw new TypeError("encoding must be a string");
      if (typeof i == "string" && !D.isEncoding(i))
        throw new TypeError("Unknown encoding: " + i);
      if (e.length === 1) {
        let o = e.charCodeAt(0);
        ((i === "utf8" && o < 128) || i === "latin1") && (e = o);
      }
    } else
      typeof e == "number"
        ? (e = e & 255)
        : typeof e == "boolean" && (e = Number(e));
    if (t < 0 || this.length < t || this.length < r)
      throw new RangeError("Out of range index");
    if (r <= t) return this;
    (t = t >>> 0), (r = r === void 0 ? this.length : r >>> 0), e || (e = 0);
    let s;
    if (typeof e == "number") for (s = t; s < r; ++s) this[s] = e;
    else {
      let o = D.isBuffer(e) ? e : D.from(e, i),
        a = o.length;
      if (a === 0)
        throw new TypeError(
          'The value "' + e + '" is invalid for argument "value"'
        );
      for (s = 0; s < r - t; ++s) this[s + t] = o[s % a];
    }
    return this;
  };
  var wc = {};
  function Wy(n, e, t) {
    wc[n] = class extends t {
      constructor() {
        super(),
          Object.defineProperty(this, "message", {
            value: e.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${n}]`),
          this.stack,
          delete this.name;
      }
      get code() {
        return n;
      }
      set code(i) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: i,
          writable: !0,
        });
      }
      toString() {
        return `${this.name} [${n}]: ${this.message}`;
      }
    };
  }
  Wy(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function (n) {
      return n
        ? `${n} is outside of buffer bounds`
        : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  Wy(
    "ERR_INVALID_ARG_TYPE",
    function (n, e) {
      return `The "${n}" argument must be of type number. Received type ${typeof e}`;
    },
    TypeError
  );
  Wy(
    "ERR_OUT_OF_RANGE",
    function (n, e, t) {
      let r = `The value of "${n}" is out of range.`,
        i = t;
      return (
        Number.isInteger(t) && Math.abs(t) > 2 ** 32
          ? (i = pI(String(t)))
          : typeof t == "bigint" &&
            ((i = String(t)),
            (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) &&
              (i = pI(i)),
            (i += "n")),
        (r += ` It must be ${e}. Received ${i}`),
        r
      );
    },
    RangeError
  );
  function pI(n) {
    let e = "",
      t = n.length,
      r = n[0] === "-" ? 1 : 0;
    for (; t >= r + 4; t -= 3) e = `_${n.slice(t - 3, t)}${e}`;
    return `${n.slice(0, t)}${e}`;
  }
  function q8(n, e, t) {
    Ac(e, "offset"),
      (n[e] === void 0 || n[e + t] === void 0) && Bl(e, n.length - (t + 1));
  }
  function II(n, e, t, r, i, s) {
    if (n > t || n < e) {
      let o = typeof e == "bigint" ? "n" : "",
        a;
      throw (
        (s > 3
          ? e === 0 || e === BigInt(0)
            ? (a = `>= 0${o} and < 2${o} ** ${(s + 1) * 8}${o}`)
            : (a = `>= -(2${o} ** ${(s + 1) * 8 - 1}${o}) and < 2 ** ${
                (s + 1) * 8 - 1
              }${o}`)
          : (a = `>= ${e}${o} and <= ${t}${o}`),
        new wc.ERR_OUT_OF_RANGE("value", a, n))
      );
    }
    q8(r, i, s);
  }
  function Ac(n, e) {
    if (typeof n != "number") throw new wc.ERR_INVALID_ARG_TYPE(e, "number", n);
  }
  function Bl(n, e, t) {
    throw Math.floor(n) !== n
      ? (Ac(n, t), new wc.ERR_OUT_OF_RANGE(t || "offset", "an integer", n))
      : e < 0
      ? new wc.ERR_BUFFER_OUT_OF_BOUNDS()
      : new wc.ERR_OUT_OF_RANGE(
          t || "offset",
          `>= ${t ? 1 : 0} and <= ${e}`,
          n
        );
  }
  var Q8 = /[^+/0-9A-Za-z-_]/g;
  function J8(n) {
    if (((n = n.split("=")[0]), (n = n.trim().replace(Q8, "")), n.length < 2))
      return "";
    for (; n.length % 4 !== 0; ) n = n + "=";
    return n;
  }
  function Uy(n, e) {
    e = e || 1 / 0;
    let t,
      r = n.length,
      i = null,
      s = [];
    for (let o = 0; o < r; ++o) {
      if (((t = n.charCodeAt(o)), t > 55295 && t < 57344)) {
        if (!i) {
          if (t > 56319) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          } else if (o + 1 === r) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          i = t;
          continue;
        }
        if (t < 56320) {
          (e -= 3) > -1 && s.push(239, 191, 189), (i = t);
          continue;
        }
        t = (((i - 55296) << 10) | (t - 56320)) + 65536;
      } else i && (e -= 3) > -1 && s.push(239, 191, 189);
      if (((i = null), t < 128)) {
        if ((e -= 1) < 0) break;
        s.push(t);
      } else if (t < 2048) {
        if ((e -= 2) < 0) break;
        s.push((t >> 6) | 192, (t & 63) | 128);
      } else if (t < 65536) {
        if ((e -= 3) < 0) break;
        s.push((t >> 12) | 224, ((t >> 6) & 63) | 128, (t & 63) | 128);
      } else if (t < 1114112) {
        if ((e -= 4) < 0) break;
        s.push(
          (t >> 18) | 240,
          ((t >> 12) & 63) | 128,
          ((t >> 6) & 63) | 128,
          (t & 63) | 128
        );
      } else throw new Error("Invalid code point");
    }
    return s;
  }
  function Y8(n) {
    let e = [];
    for (let t = 0; t < n.length; ++t) e.push(n.charCodeAt(t) & 255);
    return e;
  }
  function Z8(n, e) {
    let t,
      r,
      i,
      s = [];
    for (let o = 0; o < n.length && !((e -= 2) < 0); ++o)
      (t = n.charCodeAt(o)), (r = t >> 8), (i = t % 256), s.push(i), s.push(r);
    return s;
  }
  function CI(n) {
    return Ny.toByteArray(J8(n));
  }
  function Id(n, e, t, r) {
    let i;
    for (i = 0; i < r && !(i + t >= e.length || i >= n.length); ++i)
      e[i + t] = n[i];
    return i;
  }
  function Jr(n, e) {
    return (
      n instanceof e ||
      (n != null &&
        n.constructor != null &&
        n.constructor.name != null &&
        n.constructor.name === e.name)
    );
  }
  function Hy(n) {
    return n !== n;
  }
  var X8 = (function () {
    let n = "0123456789abcdef",
      e = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let r = t * 16;
      for (let i = 0; i < 16; ++i) e[r + i] = n[t] + n[i];
    }
    return e;
  })();
  function vs(n) {
    return typeof BigInt > "u" ? eF : n;
  }
  function eF() {
    throw new Error("BigInt not supported");
  }
});
function TI(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function tF(n) {
  return (
    n instanceof Uint8Array ||
    (ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array")
  );
}
function xc(n, ...e) {
  if (!tF(n)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(n.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + n.length
    );
}
function RI(n) {
  if (typeof n != "function" || typeof n.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  TI(n.outputLen), TI(n.blockLen);
}
function Sc(n, e = !0) {
  if (n.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && n.finished) throw new Error("Hash#digest() has already been called");
}
function BI(n, e) {
  xc(n);
  let t = e.outputLen;
  if (n.length < t)
    throw new Error(
      "digestInto() expects output buffer of length at least " + t
    );
}
var Cd = ot(() => {
  "use strict";
  p();
});
var Bo,
  DI = ot(() => {
    "use strict";
    p();
    Bo =
      typeof globalThis == "object" && "crypto" in globalThis
        ? globalThis.crypto
        : void 0;
  });
function _I(n) {
  if (typeof n != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof n);
  return new Uint8Array(new TextEncoder().encode(n));
}
function Dl(n) {
  return typeof n == "string" && (n = _I(n)), xc(n), n;
}
function Vy(...n) {
  let e = 0;
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    xc(i), (e += i.length);
  }
  let t = new Uint8Array(e);
  for (let r = 0, i = 0; r < n.length; r++) {
    let s = n[r];
    t.set(s, i), (i += s.length);
  }
  return t;
}
function Td(n) {
  let e = (r) => n().update(Dl(r)).digest(),
    t = n();
  return (
    (e.outputLen = t.outputLen),
    (e.blockLen = t.blockLen),
    (e.create = () => n()),
    e
  );
}
function Rd(n = 32) {
  if (Bo && typeof Bo.getRandomValues == "function")
    return Bo.getRandomValues(new Uint8Array(n));
  if (Bo && typeof Bo.randomBytes == "function") return Bo.randomBytes(n);
  throw new Error("crypto.getRandomValues must be defined");
}
var kd,
  Lr,
  vc,
  Do = ot(() => {
    "use strict";
    p();
    DI();
    Cd();
    (kd = (n) => new DataView(n.buffer, n.byteOffset, n.byteLength)),
      (Lr = (n, e) => (n << (32 - e)) | (n >>> e));
    vc = class {
      clone() {
        return this._cloneInto();
      }
    };
  });
function nF(n, e, t, r) {
  if (typeof n.setBigUint64 == "function") return n.setBigUint64(e, t, r);
  let i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((t >> i) & s),
    a = Number(t & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  n.setUint32(e + c, o, r), n.setUint32(e + u, a, r);
}
var PI,
  LI,
  Ic,
  $y = ot(() => {
    "use strict";
    p();
    Cd();
    Do();
    (PI = (n, e, t) => (n & e) ^ (~n & t)),
      (LI = (n, e, t) => (n & e) ^ (n & t) ^ (e & t)),
      (Ic = class extends vc {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = kd(this.buffer));
        }
        update(e) {
          Sc(this);
          let { view: t, buffer: r, blockLen: i } = this;
          e = Dl(e);
          let s = e.length;
          for (let o = 0; o < s; ) {
            let a = Math.min(i - this.pos, s - o);
            if (a === i) {
              let c = kd(e);
              for (; i <= s - o; o += i) this.process(c, o);
              continue;
            }
            r.set(e.subarray(o, o + a), this.pos),
              (this.pos += a),
              (o += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          Sc(this), BI(e, this), (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: s } = this,
            { pos: o } = this;
          (t[o++] = 128),
            this.buffer.subarray(o).fill(0),
            this.padOffset > i - o && (this.process(r, 0), (o = 0));
          for (let h = o; h < i; h++) t[h] = 0;
          nF(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
          let a = kd(e),
            c = this.outputLen;
          if (c % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          let u = c / 4,
            l = this.get();
          if (u > l.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let h = 0; h < u; h++) a.setUint32(4 * h, l[h], s);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: s,
            destroyed: o,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = s),
            (e.destroyed = o),
            i % t && e.buffer.set(r),
            e
          );
        }
      });
  });
function OI(n, e = !1) {
  return e
    ? { h: Number(n & Bd), l: Number((n >> Gy) & Bd) }
    : { h: Number((n >> Gy) & Bd) | 0, l: Number(n & Bd) | 0 };
}
function rF(n, e = !1) {
  let t = new Uint32Array(n.length),
    r = new Uint32Array(n.length);
  for (let i = 0; i < n.length; i++) {
    let { h: s, l: o } = OI(n[i], e);
    [t[i], r[i]] = [s, o];
  }
  return [t, r];
}
function yF(n, e, t, r) {
  let i = (e >>> 0) + (r >>> 0);
  return { h: (n + t + ((i / 2 ** 32) | 0)) | 0, l: i | 0 };
}
var Bd,
  Gy,
  iF,
  sF,
  oF,
  aF,
  cF,
  uF,
  lF,
  hF,
  fF,
  dF,
  pF,
  gF,
  mF,
  wF,
  bF,
  AF,
  EF,
  xF,
  SF,
  vF,
  Te,
  NI = ot(() => {
    "use strict";
    p();
    (Bd = BigInt(4294967295)), (Gy = BigInt(32));
    (iF = (n, e) => (BigInt(n >>> 0) << Gy) | BigInt(e >>> 0)),
      (sF = (n, e, t) => n >>> t),
      (oF = (n, e, t) => (n << (32 - t)) | (e >>> t)),
      (aF = (n, e, t) => (n >>> t) | (e << (32 - t))),
      (cF = (n, e, t) => (n << (32 - t)) | (e >>> t)),
      (uF = (n, e, t) => (n << (64 - t)) | (e >>> (t - 32))),
      (lF = (n, e, t) => (n >>> (t - 32)) | (e << (64 - t))),
      (hF = (n, e) => e),
      (fF = (n, e) => n),
      (dF = (n, e, t) => (n << t) | (e >>> (32 - t))),
      (pF = (n, e, t) => (e << t) | (n >>> (32 - t))),
      (gF = (n, e, t) => (e << (t - 32)) | (n >>> (64 - t))),
      (mF = (n, e, t) => (n << (t - 32)) | (e >>> (64 - t)));
    (wF = (n, e, t) => (n >>> 0) + (e >>> 0) + (t >>> 0)),
      (bF = (n, e, t, r) => (e + t + r + ((n / 2 ** 32) | 0)) | 0),
      (AF = (n, e, t, r) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0)),
      (EF = (n, e, t, r, i) => (e + t + r + i + ((n / 2 ** 32) | 0)) | 0),
      (xF = (n, e, t, r, i) =>
        (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0)),
      (SF = (n, e, t, r, i, s) =>
        (e + t + r + i + s + ((n / 2 ** 32) | 0)) | 0),
      (vF = {
        fromBig: OI,
        split: rF,
        toBig: iF,
        shrSH: sF,
        shrSL: oF,
        rotrSH: aF,
        rotrSL: cF,
        rotrBH: uF,
        rotrBL: lF,
        rotr32H: hF,
        rotr32L: fF,
        rotlSH: dF,
        rotlSL: pF,
        rotlBH: gF,
        rotlBL: mF,
        add: yF,
        add3L: wF,
        add3H: bF,
        add4L: AF,
        add4H: EF,
        add5H: SF,
        add5L: xF,
      }),
      (Te = vF);
  });
var IF,
  CF,
  Is,
  Cs,
  Ky,
  FI,
  MI = ot(() => {
    "use strict";
    p();
    $y();
    NI();
    Do();
    ([IF, CF] = Te.split(
      [
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817",
      ].map((n) => BigInt(n))
    )),
      (Is = new Uint32Array(80)),
      (Cs = new Uint32Array(80)),
      (Ky = class extends Ic {
        constructor() {
          super(128, 64, 16, !1),
            (this.Ah = 1779033703),
            (this.Al = -205731576),
            (this.Bh = -1150833019),
            (this.Bl = -2067093701),
            (this.Ch = 1013904242),
            (this.Cl = -23791573),
            (this.Dh = -1521486534),
            (this.Dl = 1595750129),
            (this.Eh = 1359893119),
            (this.El = -1377402159),
            (this.Fh = -1694144372),
            (this.Fl = 725511199),
            (this.Gh = 528734635),
            (this.Gl = -79577749),
            (this.Hh = 1541459225),
            (this.Hl = 327033209);
        }
        get() {
          let {
            Ah: e,
            Al: t,
            Bh: r,
            Bl: i,
            Ch: s,
            Cl: o,
            Dh: a,
            Dl: c,
            Eh: u,
            El: l,
            Fh: h,
            Fl: f,
            Gh: g,
            Gl: y,
            Hh: w,
            Hl: m,
          } = this;
          return [e, t, r, i, s, o, a, c, u, l, h, f, g, y, w, m];
        }
        set(e, t, r, i, s, o, a, c, u, l, h, f, g, y, w, m) {
          (this.Ah = e | 0),
            (this.Al = t | 0),
            (this.Bh = r | 0),
            (this.Bl = i | 0),
            (this.Ch = s | 0),
            (this.Cl = o | 0),
            (this.Dh = a | 0),
            (this.Dl = c | 0),
            (this.Eh = u | 0),
            (this.El = l | 0),
            (this.Fh = h | 0),
            (this.Fl = f | 0),
            (this.Gh = g | 0),
            (this.Gl = y | 0),
            (this.Hh = w | 0),
            (this.Hl = m | 0);
        }
        process(e, t) {
          for (let E = 0; E < 16; E++, t += 4)
            (Is[E] = e.getUint32(t)), (Cs[E] = e.getUint32((t += 4)));
          for (let E = 16; E < 80; E++) {
            let T = Is[E - 15] | 0,
              B = Cs[E - 15] | 0,
              L = Te.rotrSH(T, B, 1) ^ Te.rotrSH(T, B, 8) ^ Te.shrSH(T, B, 7),
              U = Te.rotrSL(T, B, 1) ^ Te.rotrSL(T, B, 8) ^ Te.shrSL(T, B, 7),
              j = Is[E - 2] | 0,
              W = Cs[E - 2] | 0,
              be =
                Te.rotrSH(j, W, 19) ^ Te.rotrBH(j, W, 61) ^ Te.shrSH(j, W, 6),
              pe =
                Te.rotrSL(j, W, 19) ^ Te.rotrBL(j, W, 61) ^ Te.shrSL(j, W, 6),
              ge = Te.add4L(U, pe, Cs[E - 7], Cs[E - 16]),
              _e = Te.add4H(ge, L, be, Is[E - 7], Is[E - 16]);
            (Is[E] = _e | 0), (Cs[E] = ge | 0);
          }
          let {
            Ah: r,
            Al: i,
            Bh: s,
            Bl: o,
            Ch: a,
            Cl: c,
            Dh: u,
            Dl: l,
            Eh: h,
            El: f,
            Fh: g,
            Fl: y,
            Gh: w,
            Gl: m,
            Hh: b,
            Hl: I,
          } = this;
          for (let E = 0; E < 80; E++) {
            let T =
                Te.rotrSH(h, f, 14) ^ Te.rotrSH(h, f, 18) ^ Te.rotrBH(h, f, 41),
              B =
                Te.rotrSL(h, f, 14) ^ Te.rotrSL(h, f, 18) ^ Te.rotrBL(h, f, 41),
              L = (h & g) ^ (~h & w),
              U = (f & y) ^ (~f & m),
              j = Te.add5L(I, B, U, CF[E], Cs[E]),
              W = Te.add5H(j, b, T, L, IF[E], Is[E]),
              be = j | 0,
              pe =
                Te.rotrSH(r, i, 28) ^ Te.rotrBH(r, i, 34) ^ Te.rotrBH(r, i, 39),
              ge =
                Te.rotrSL(r, i, 28) ^ Te.rotrBL(r, i, 34) ^ Te.rotrBL(r, i, 39),
              _e = (r & s) ^ (r & a) ^ (s & a),
              X = (i & o) ^ (i & c) ^ (o & c);
            (b = w | 0),
              (I = m | 0),
              (w = g | 0),
              (m = y | 0),
              (g = h | 0),
              (y = f | 0),
              ({ h, l: f } = Te.add(u | 0, l | 0, W | 0, be | 0)),
              (u = a | 0),
              (l = c | 0),
              (a = s | 0),
              (c = o | 0),
              (s = r | 0),
              (o = i | 0);
            let q = Te.add3L(be, ge, X);
            (r = Te.add3H(q, W, pe, _e)), (i = q | 0);
          }
          ({ h: r, l: i } = Te.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
            ({ h: s, l: o } = Te.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
            ({ h: a, l: c } = Te.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
            ({ h: u, l } = Te.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0)),
            ({ h, l: f } = Te.add(this.Eh | 0, this.El | 0, h | 0, f | 0)),
            ({ h: g, l: y } = Te.add(this.Fh | 0, this.Fl | 0, g | 0, y | 0)),
            ({ h: w, l: m } = Te.add(this.Gh | 0, this.Gl | 0, w | 0, m | 0)),
            ({ h: b, l: I } = Te.add(this.Hh | 0, this.Hl | 0, b | 0, I | 0)),
            this.set(r, i, s, o, a, c, u, l, h, f, g, y, w, m, b, I);
        }
        roundClean() {
          Is.fill(0), Cs.fill(0);
        }
        destroy() {
          this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }),
      (FI = Td(() => new Ky()));
  });
var Pd = {};
Vg(Pd, {
  aInRange: () => Fn,
  abool: () => Or,
  abytes: () => Cc,
  bitGet: () => _F,
  bitLen: () => Yy,
  bitMask: () => Pl,
  bitSet: () => PF,
  bytesToHex: () => Pi,
  bytesToNumberBE: () => Li,
  bytesToNumberLE: () => Ts,
  concatBytes: () => Oi,
  createHmacDrbg: () => Zy,
  ensureBytes: () => St,
  equalBytes: () => BF,
  hexToBytes: () => Po,
  hexToNumber: () => Jy,
  inRange: () => _l,
  isBytes: () => ks,
  memoized: () => Oo,
  notImplemented: () => OF,
  numberToBytesBE: () => Rs,
  numberToBytesLE: () => Lo,
  numberToHexUnpadded: () => _o,
  numberToVarBytesBE: () => RF,
  utf8ToBytes: () => DF,
  validateObject: () => Yr,
});
function ks(n) {
  return (
    n instanceof Uint8Array ||
    (ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array")
  );
}
function Cc(n) {
  if (!ks(n)) throw new Error("Uint8Array expected");
}
function Or(n, e) {
  if (typeof e != "boolean") throw new Error(n + " boolean expected, got " + e);
}
function Pi(n) {
  Cc(n);
  let e = "";
  for (let t = 0; t < n.length; t++) e += TF[n[t]];
  return e;
}
function _o(n) {
  let e = n.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function Jy(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  return n === "" ? Dd : BigInt("0x" + n);
}
function UI(n) {
  if (n >= _i._0 && n <= _i._9) return n - _i._0;
  if (n >= _i.A && n <= _i.F) return n - (_i.A - 10);
  if (n >= _i.a && n <= _i.f) return n - (_i.a - 10);
}
function Po(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  let e = n.length,
    t = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  let r = new Uint8Array(t);
  for (let i = 0, s = 0; i < t; i++, s += 2) {
    let o = UI(n.charCodeAt(s)),
      a = UI(n.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      let c = n[s] + n[s + 1];
      throw new Error(
        'hex string expected, got non-hex character "' + c + '" at index ' + s
      );
    }
    r[i] = o * 16 + a;
  }
  return r;
}
function Li(n) {
  return Jy(Pi(n));
}
function Ts(n) {
  return Cc(n), Jy(Pi(Uint8Array.from(n).reverse()));
}
function Rs(n, e) {
  return Po(n.toString(16).padStart(e * 2, "0"));
}
function Lo(n, e) {
  return Rs(n, e).reverse();
}
function RF(n) {
  return Po(_o(n));
}
function St(n, e, t) {
  let r;
  if (typeof e == "string")
    try {
      r = Po(e);
    } catch (s) {
      throw new Error(n + " must be hex string or Uint8Array, cause: " + s);
    }
  else if (ks(e)) r = Uint8Array.from(e);
  else throw new Error(n + " must be hex string or Uint8Array");
  let i = r.length;
  if (typeof t == "number" && i !== t)
    throw new Error(n + " of length " + t + " expected, got " + i);
  return r;
}
function Oi(...n) {
  let e = 0;
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    Cc(i), (e += i.length);
  }
  let t = new Uint8Array(e);
  for (let r = 0, i = 0; r < n.length; r++) {
    let s = n[r];
    t.set(s, i), (i += s.length);
  }
  return t;
}
function BF(n, e) {
  if (n.length !== e.length) return !1;
  let t = 0;
  for (let r = 0; r < n.length; r++) t |= n[r] ^ e[r];
  return t === 0;
}
function DF(n) {
  if (typeof n != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(n));
}
function _l(n, e, t) {
  return qy(n) && qy(e) && qy(t) && e <= n && n < t;
}
function Fn(n, e, t, r) {
  if (!_l(e, t, r))
    throw new Error(
      "expected valid " + n + ": " + t + " <= n < " + r + ", got " + e
    );
}
function Yy(n) {
  let e;
  for (e = 0; n > Dd; n >>= _d, e += 1);
  return e;
}
function _F(n, e) {
  return (n >> BigInt(e)) & _d;
}
function PF(n, e, t) {
  return n | ((t ? _d : Dd) << BigInt(e));
}
function Zy(n, e, t) {
  if (typeof n != "number" || n < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof t != "function") throw new Error("hmacFn must be a function");
  let r = Qy(n),
    i = Qy(n),
    s = 0,
    o = () => {
      r.fill(1), i.fill(0), (s = 0);
    },
    a = (...h) => t(i, r, ...h),
    c = (h = Qy()) => {
      (i = a(zI([0]), h)),
        (r = a()),
        h.length !== 0 && ((i = a(zI([1]), h)), (r = a()));
    },
    u = () => {
      if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let h = 0,
        f = [];
      for (; h < e; ) {
        r = a();
        let g = r.slice();
        f.push(g), (h += r.length);
      }
      return Oi(...f);
    };
  return (h, f) => {
    o(), c(h);
    let g;
    for (; !(g = f(u())); ) c();
    return o(), g;
  };
}
function Yr(n, e, t = {}) {
  let r = (i, s, o) => {
    let a = LF[s];
    if (typeof a != "function") throw new Error("invalid validator function");
    let c = n[i];
    if (!(o && c === void 0) && !a(c, n))
      throw new Error(
        "param " + String(i) + " is invalid. Expected " + s + ", got " + c
      );
  };
  for (let [i, s] of Object.entries(e)) r(i, s, !1);
  for (let [i, s] of Object.entries(t)) r(i, s, !0);
  return n;
}
function Oo(n) {
  let e = new WeakMap();
  return (t, ...r) => {
    let i = e.get(t);
    if (i !== void 0) return i;
    let s = n(t, ...r);
    return e.set(t, s), s;
  };
}
var Dd,
  _d,
  kF,
  TF,
  _i,
  qy,
  Pl,
  Qy,
  zI,
  LF,
  OF,
  No = ot(() => {
    "use strict";
    p();
    (Dd = BigInt(0)), (_d = BigInt(1)), (kF = BigInt(2));
    TF = Array.from({ length: 256 }, (n, e) => e.toString(16).padStart(2, "0"));
    _i = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    qy = (n) => typeof n == "bigint" && Dd <= n;
    (Pl = (n) => (kF << BigInt(n - 1)) - _d),
      (Qy = (n) => new Uint8Array(n)),
      (zI = (n) => Uint8Array.from(n));
    LF = {
      bigint: (n) => typeof n == "bigint",
      function: (n) => typeof n == "function",
      boolean: (n) => typeof n == "boolean",
      string: (n) => typeof n == "string",
      stringOrUint8Array: (n) => typeof n == "string" || ks(n),
      isSafeInteger: (n) => Number.isSafeInteger(n),
      array: (n) => Array.isArray(n),
      field: (n, e) => e.Fp.isValid(n),
      hash: (n) => typeof n == "function" && Number.isSafeInteger(n.outputLen),
    };
    OF = () => {
      throw new Error("not implemented");
    };
  });
function it(n, e) {
  let t = n % e;
  return t >= Ut ? t : e + t;
}
function UF(n, e, t) {
  if (e < Ut) throw new Error("invalid exponent, negatives unsupported");
  if (t <= Ut) throw new Error("invalid modulus");
  if (t === yt) return Ut;
  let r = yt;
  for (; e > Ut; ) e & yt && (r = (r * n) % t), (n = (n * n) % t), (e >>= yt);
  return r;
}
function wt(n, e, t) {
  let r = n;
  for (; e-- > Ut; ) (r *= r), (r %= t);
  return r;
}
function Ld(n, e) {
  if (n === Ut) throw new Error("invert: expected non-zero number");
  if (e <= Ut) throw new Error("invert: expected positive modulus, got " + e);
  let t = it(n, e),
    r = e,
    i = Ut,
    s = yt,
    o = yt,
    a = Ut;
  for (; t !== Ut; ) {
    let u = r / t,
      l = r % t,
      h = i - o * u,
      f = s - a * u;
    (r = t), (t = l), (i = o), (s = a), (o = h), (a = f);
  }
  if (r !== yt) throw new Error("invert: does not exist");
  return it(i, e);
}
function zF(n) {
  let e = (n - yt) / Fo,
    t,
    r,
    i;
  for (t = n - yt, r = 0; t % Fo === Ut; t /= Fo, r++);
  for (i = Fo; i < n && UF(i, e, n) !== n - yt; i++)
    if (i > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r === 1) {
    let o = (n + yt) / Xy;
    return function (c, u) {
      let l = c.pow(u, o);
      if (!c.eql(c.sqr(l), u)) throw new Error("Cannot find square root");
      return l;
    };
  }
  let s = (t + yt) / Fo;
  return function (a, c) {
    if (a.pow(c, e) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = r,
      l = a.pow(a.mul(a.ONE, i), t),
      h = a.pow(c, s),
      f = a.pow(c, t);
    for (; !a.eql(f, a.ONE); ) {
      if (a.eql(f, a.ZERO)) return a.ZERO;
      let g = 1;
      for (let w = a.sqr(f); g < u && !a.eql(w, a.ONE); g++) w = a.sqr(w);
      let y = a.pow(l, yt << BigInt(u - g - 1));
      (l = a.sqr(y)), (h = a.mul(h, y)), (f = a.mul(f, l)), (u = g);
    }
    return h;
  };
}
function jF(n) {
  if (n % Xy === NF) {
    let e = (n + yt) / Xy;
    return function (r, i) {
      let s = r.pow(i, e);
      if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
      return s;
    };
  }
  if (n % WI === jI) {
    let e = (n - jI) / WI;
    return function (r, i) {
      let s = r.mul(i, Fo),
        o = r.pow(s, e),
        a = r.mul(i, o),
        c = r.mul(r.mul(a, Fo), o),
        u = r.mul(a, r.sub(c, r.ONE));
      if (!r.eql(r.sqr(u), i)) throw new Error("Cannot find square root");
      return u;
    };
  }
  return n % MF, zF(n);
}
function ew(n) {
  let e = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger",
    },
    t = WF.reduce((r, i) => ((r[i] = "function"), r), e);
  return Yr(n, t);
}
function HF(n, e, t) {
  if (t < Ut) throw new Error("invalid exponent, negatives unsupported");
  if (t === Ut) return n.ONE;
  if (t === yt) return e;
  let r = n.ONE,
    i = e;
  for (; t > Ut; ) t & yt && (r = n.mul(r, i)), (i = n.sqr(i)), (t >>= yt);
  return r;
}
function VF(n, e) {
  let t = new Array(e.length),
    r = e.reduce(
      (s, o, a) => (n.is0(o) ? s : ((t[a] = s), n.mul(s, o))),
      n.ONE
    ),
    i = n.inv(r);
  return (
    e.reduceRight(
      (s, o, a) => (n.is0(o) ? s : ((t[a] = n.mul(s, t[a])), n.mul(s, o))),
      i
    ),
    t
  );
}
function tw(n, e) {
  let t = e !== void 0 ? e : n.toString(2).length,
    r = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: r };
}
function Bs(n, e, t = !1, r = {}) {
  if (n <= Ut) throw new Error("invalid field: expected ORDER > 0, got " + n);
  let { nBitLength: i, nByteLength: s } = tw(n, e);
  if (s > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let o,
    a = Object.freeze({
      ORDER: n,
      BITS: i,
      BYTES: s,
      MASK: Pl(i),
      ZERO: Ut,
      ONE: yt,
      create: (c) => it(c, n),
      isValid: (c) => {
        if (typeof c != "bigint")
          throw new Error(
            "invalid field element: expected bigint, got " + typeof c
          );
        return Ut <= c && c < n;
      },
      is0: (c) => c === Ut,
      isOdd: (c) => (c & yt) === yt,
      neg: (c) => it(-c, n),
      eql: (c, u) => c === u,
      sqr: (c) => it(c * c, n),
      add: (c, u) => it(c + u, n),
      sub: (c, u) => it(c - u, n),
      mul: (c, u) => it(c * u, n),
      pow: (c, u) => HF(a, c, u),
      div: (c, u) => it(c * Ld(u, n), n),
      sqrN: (c) => c * c,
      addN: (c, u) => c + u,
      subN: (c, u) => c - u,
      mulN: (c, u) => c * u,
      inv: (c) => Ld(c, n),
      sqrt: r.sqrt || ((c) => (o || (o = jF(n)), o(a, c))),
      invertBatch: (c) => VF(a, c),
      cmov: (c, u, l) => (l ? u : c),
      toBytes: (c) => (t ? Lo(c, s) : Rs(c, s)),
      fromBytes: (c) => {
        if (c.length !== s)
          throw new Error(
            "Field.fromBytes: expected " + s + " bytes, got " + c.length
          );
        return t ? Ts(c) : Li(c);
      },
    });
  return Object.freeze(a);
}
function VI(n) {
  if (typeof n != "bigint") throw new Error("field order must be bigint");
  let e = n.toString(2).length;
  return Math.ceil(e / 8);
}
function nw(n) {
  let e = VI(n);
  return e + Math.ceil(e / 2);
}
function $I(n, e, t = !1) {
  let r = n.length,
    i = VI(e),
    s = nw(e);
  if (r < 16 || r < s || r > 1024)
    throw new Error("expected " + s + "-1024 bytes of input, got " + r);
  let o = t ? Li(n) : Ts(n),
    a = it(o, e - yt) + yt;
  return t ? Lo(a, i) : Rs(a, i);
}
var Ut,
  yt,
  Fo,
  NF,
  Xy,
  jI,
  WI,
  FF,
  MF,
  HI,
  WF,
  kc = ot(() => {
    "use strict";
    p();
    No();
    (Ut = BigInt(0)),
      (yt = BigInt(1)),
      (Fo = BigInt(2)),
      (NF = BigInt(3)),
      (Xy = BigInt(4)),
      (jI = BigInt(5)),
      (WI = BigInt(8)),
      (FF = BigInt(9)),
      (MF = BigInt(16));
    (HI = (n, e) => (it(n, e) & yt) === yt),
      (WF = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN",
      ]);
  });
function rw(n, e) {
  let t = e.negate();
  return n ? t : e;
}
function KI(n, e) {
  if (!Number.isSafeInteger(n) || n <= 0 || n > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + n);
}
function iw(n, e) {
  KI(n, e);
  let t = Math.ceil(e / n) + 1,
    r = 2 ** (n - 1);
  return { windows: t, windowSize: r };
}
function GF(n, e) {
  if (!Array.isArray(n)) throw new Error("array expected");
  n.forEach((t, r) => {
    if (!(t instanceof e)) throw new Error("invalid point at index " + r);
  });
}
function KF(n, e) {
  if (!Array.isArray(n)) throw new Error("array of scalars expected");
  n.forEach((t, r) => {
    if (!e.isValid(t)) throw new Error("invalid scalar at index " + r);
  });
}
function ow(n) {
  return qI.get(n) || 1;
}
function Nd(n, e) {
  return {
    constTimeNegate: rw,
    hasPrecomputes(t) {
      return ow(t) !== 1;
    },
    unsafeLadder(t, r, i = n.ZERO) {
      let s = t;
      for (; r > GI; ) r & Od && (i = i.add(s)), (s = s.double()), (r >>= Od);
      return i;
    },
    precomputeWindow(t, r) {
      let { windows: i, windowSize: s } = iw(r, e),
        o = [],
        a = t,
        c = a;
      for (let u = 0; u < i; u++) {
        (c = a), o.push(c);
        for (let l = 1; l < s; l++) (c = c.add(a)), o.push(c);
        a = c.double();
      }
      return o;
    },
    wNAF(t, r, i) {
      let { windows: s, windowSize: o } = iw(t, e),
        a = n.ZERO,
        c = n.BASE,
        u = BigInt(2 ** t - 1),
        l = 2 ** t,
        h = BigInt(t);
      for (let f = 0; f < s; f++) {
        let g = f * o,
          y = Number(i & u);
        (i >>= h), y > o && ((y -= l), (i += Od));
        let w = g,
          m = g + Math.abs(y) - 1,
          b = f % 2 !== 0,
          I = y < 0;
        y === 0 ? (c = c.add(rw(b, r[w]))) : (a = a.add(rw(I, r[m])));
      }
      return { p: a, f: c };
    },
    wNAFUnsafe(t, r, i, s = n.ZERO) {
      let { windows: o, windowSize: a } = iw(t, e),
        c = BigInt(2 ** t - 1),
        u = 2 ** t,
        l = BigInt(t);
      for (let h = 0; h < o; h++) {
        let f = h * a;
        if (i === GI) break;
        let g = Number(i & c);
        if (((i >>= l), g > a && ((g -= u), (i += Od)), g === 0)) continue;
        let y = r[f + Math.abs(g) - 1];
        g < 0 && (y = y.negate()), (s = s.add(y));
      }
      return s;
    },
    getPrecomputes(t, r, i) {
      let s = sw.get(r);
      return (
        s || ((s = this.precomputeWindow(r, t)), t !== 1 && sw.set(r, i(s))), s
      );
    },
    wNAFCached(t, r, i) {
      let s = ow(t);
      return this.wNAF(s, this.getPrecomputes(s, t, i), r);
    },
    wNAFCachedUnsafe(t, r, i, s) {
      let o = ow(t);
      return o === 1
        ? this.unsafeLadder(t, r, s)
        : this.wNAFUnsafe(o, this.getPrecomputes(o, t, i), r, s);
    },
    setWindowSize(t, r) {
      KI(r, e), qI.set(t, r), sw.delete(t);
    },
  };
}
function Fd(n, e, t, r) {
  if ((GF(t, n), KF(r, e), t.length !== r.length))
    throw new Error("arrays of points and scalars must have equal length");
  let i = n.ZERO,
    s = Yy(BigInt(t.length)),
    o = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1,
    a = (1 << o) - 1,
    c = new Array(a + 1).fill(i),
    u = Math.floor((e.BITS - 1) / o) * o,
    l = i;
  for (let h = u; h >= 0; h -= o) {
    c.fill(i);
    for (let g = 0; g < r.length; g++) {
      let y = r[g],
        w = Number((y >> BigInt(h)) & BigInt(a));
      c[w] = c[w].add(t[g]);
    }
    let f = i;
    for (let g = c.length - 1, y = i; g > 0; g--)
      (y = y.add(c[g])), (f = f.add(y));
    if (((l = l.add(f)), h !== 0)) for (let g = 0; g < o; g++) l = l.double();
  }
  return l;
}
function Ll(n) {
  return (
    ew(n.Fp),
    Yr(
      n,
      { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
      { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
    ),
    Object.freeze($(v(v({}, tw(n.n, n.nBitLength)), n), { p: n.Fp.ORDER }))
  );
}
var GI,
  Od,
  sw,
  qI,
  aw = ot(() => {
    "use strict";
    p();
    kc();
    No();
    (GI = BigInt(0)), (Od = BigInt(1));
    (sw = new WeakMap()), (qI = new WeakMap());
  });
function JF(n) {
  let e = Ll(n);
  return (
    Yr(
      n,
      { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" },
      {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function",
      }
    ),
    Object.freeze(v({}, e))
  );
}
function QI(n) {
  let e = JF(n),
    {
      Fp: t,
      n: r,
      prehash: i,
      hash: s,
      randomBytes: o,
      nByteLength: a,
      h: c,
    } = e,
    u = Md << (BigInt(a * 8) - Mn),
    l = t.create,
    h = Bs(e.n, e.nBitLength),
    f =
      e.uvRatio ||
      ((F, O) => {
        try {
          return { isValid: !0, value: t.sqrt(F * t.inv(O)) };
        } catch {
          return { isValid: !1, value: Nr };
        }
      }),
    g = e.adjustScalarBytes || ((F) => F),
    y =
      e.domain ||
      ((F, O, K) => {
        if ((Or("phflag", K), O.length || K))
          throw new Error("Contexts/pre-hash are not supported");
        return F;
      });
  function w(F, O) {
    Fn("coordinate " + F, O, Nr, u);
  }
  function m(F) {
    if (!(F instanceof E)) throw new Error("ExtendedPoint expected");
  }
  let b = Oo((F, O) => {
      let { ex: K, ey: H, ez: he } = F,
        Ee = F.is0();
      O == null && (O = Ee ? qF : t.inv(he));
      let Se = l(K * O),
        Pe = l(H * O),
        ye = l(he * O);
      if (Ee) return { x: Nr, y: Mn };
      if (ye !== Mn) throw new Error("invZ was invalid");
      return { x: Se, y: Pe };
    }),
    I = Oo((F) => {
      let { a: O, d: K } = e;
      if (F.is0()) throw new Error("bad point: ZERO");
      let { ex: H, ey: he, ez: Ee, et: Se } = F,
        Pe = l(H * H),
        ye = l(he * he),
        ze = l(Ee * Ee),
        nt = l(ze * ze),
        Wt = l(Pe * O),
        Ht = l(ze * l(Wt + ye)),
        nn = l(nt + l(K * l(Pe * ye)));
      if (Ht !== nn) throw new Error("bad point: equation left != right (1)");
      let un = l(H * he),
        Dn = l(Ee * Se);
      if (un !== Dn) throw new Error("bad point: equation left != right (2)");
      return !0;
    });
  class E {
    constructor(O, K, H, he) {
      (this.ex = O),
        (this.ey = K),
        (this.ez = H),
        (this.et = he),
        w("x", O),
        w("y", K),
        w("z", H),
        w("t", he),
        Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(O) {
      if (O instanceof E) throw new Error("extended point not allowed");
      let { x: K, y: H } = O || {};
      return w("x", K), w("y", H), new E(K, H, Mn, l(K * H));
    }
    static normalizeZ(O) {
      let K = t.invertBatch(O.map((H) => H.ez));
      return O.map((H, he) => H.toAffine(K[he])).map(E.fromAffine);
    }
    static msm(O, K) {
      return Fd(E, h, O, K);
    }
    _setWindowSize(O) {
      L.setWindowSize(this, O);
    }
    assertValidity() {
      I(this);
    }
    equals(O) {
      m(O);
      let { ex: K, ey: H, ez: he } = this,
        { ex: Ee, ey: Se, ez: Pe } = O,
        ye = l(K * Pe),
        ze = l(Ee * he),
        nt = l(H * Pe),
        Wt = l(Se * he);
      return ye === ze && nt === Wt;
    }
    is0() {
      return this.equals(E.ZERO);
    }
    negate() {
      return new E(l(-this.ex), this.ey, this.ez, l(-this.et));
    }
    double() {
      let { a: O } = e,
        { ex: K, ey: H, ez: he } = this,
        Ee = l(K * K),
        Se = l(H * H),
        Pe = l(Md * l(he * he)),
        ye = l(O * Ee),
        ze = K + H,
        nt = l(l(ze * ze) - Ee - Se),
        Wt = ye + Se,
        Ht = Wt - Pe,
        nn = ye - Se,
        un = l(nt * Ht),
        Dn = l(Wt * nn),
        En = l(nt * nn),
        jr = l(Ht * Wt);
      return new E(un, Dn, jr, En);
    }
    add(O) {
      m(O);
      let { a: K, d: H } = e,
        { ex: he, ey: Ee, ez: Se, et: Pe } = this,
        { ex: ye, ey: ze, ez: nt, et: Wt } = O;
      if (K === BigInt(-1)) {
        let OA = l((Ee - he) * (ze + ye)),
          NA = l((Ee + he) * (ze - ye)),
          Hg = l(NA - OA);
        if (Hg === Nr) return this.double();
        let FA = l(Se * Md * Wt),
          MA = l(Pe * Md * nt),
          UA = MA + FA,
          zA = NA + OA,
          jA = MA - FA,
          UB = l(UA * Hg),
          zB = l(zA * jA),
          jB = l(UA * jA),
          WB = l(Hg * zA);
        return new E(UB, zB, WB, jB);
      }
      let Ht = l(he * ye),
        nn = l(Ee * ze),
        un = l(Pe * H * Wt),
        Dn = l(Se * nt),
        En = l((he + Ee) * (ye + ze) - Ht - nn),
        jr = Dn - un,
        di = Dn + un,
        Au = l(nn - K * Ht),
        OB = l(En * jr),
        NB = l(di * Au),
        FB = l(En * Au),
        MB = l(jr * di);
      return new E(OB, NB, MB, FB);
    }
    subtract(O) {
      return this.add(O.negate());
    }
    wNAF(O) {
      return L.wNAFCached(this, O, E.normalizeZ);
    }
    multiply(O) {
      let K = O;
      Fn("scalar", K, Mn, r);
      let { p: H, f: he } = this.wNAF(K);
      return E.normalizeZ([H, he])[0];
    }
    multiplyUnsafe(O, K = E.ZERO) {
      let H = O;
      return (
        Fn("scalar", H, Nr, r),
        H === Nr
          ? B
          : this.is0() || H === Mn
          ? this
          : L.wNAFCachedUnsafe(this, H, E.normalizeZ, K)
      );
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c).is0();
    }
    isTorsionFree() {
      return L.unsafeLadder(this, r).is0();
    }
    toAffine(O) {
      return b(this, O);
    }
    clearCofactor() {
      let { h: O } = e;
      return O === Mn ? this : this.multiplyUnsafe(O);
    }
    static fromHex(O, K = !1) {
      let { d: H, a: he } = e,
        Ee = t.BYTES;
      (O = St("pointHex", O, Ee)), Or("zip215", K);
      let Se = O.slice(),
        Pe = O[Ee - 1];
      Se[Ee - 1] = Pe & -129;
      let ye = Ts(Se),
        ze = K ? u : t.ORDER;
      Fn("pointHex.y", ye, Nr, ze);
      let nt = l(ye * ye),
        Wt = l(nt - Mn),
        Ht = l(H * nt - he),
        { isValid: nn, value: un } = f(Wt, Ht);
      if (!nn) throw new Error("Point.fromHex: invalid y coordinate");
      let Dn = (un & Mn) === Mn,
        En = (Pe & 128) !== 0;
      if (!K && un === Nr && En)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return En !== Dn && (un = l(-un)), E.fromAffine({ x: un, y: ye });
    }
    static fromPrivateKey(O) {
      return W(O).point;
    }
    toRawBytes() {
      let { x: O, y: K } = this.toAffine(),
        H = Lo(K, t.BYTES);
      return (H[H.length - 1] |= O & Mn ? 128 : 0), H;
    }
    toHex() {
      return Pi(this.toRawBytes());
    }
  }
  (E.BASE = new E(e.Gx, e.Gy, Mn, l(e.Gx * e.Gy))),
    (E.ZERO = new E(Nr, Mn, Mn, Nr));
  let { BASE: T, ZERO: B } = E,
    L = Nd(E, a * 8);
  function U(F) {
    return it(F, r);
  }
  function j(F) {
    return U(Ts(F));
  }
  function W(F) {
    let O = t.BYTES;
    F = St("private key", F, O);
    let K = St("hashed private key", s(F), 2 * O),
      H = g(K.slice(0, O)),
      he = K.slice(O, 2 * O),
      Ee = j(H),
      Se = T.multiply(Ee),
      Pe = Se.toRawBytes();
    return { head: H, prefix: he, scalar: Ee, point: Se, pointBytes: Pe };
  }
  function be(F) {
    return W(F).pointBytes;
  }
  function pe(F = new Uint8Array(), ...O) {
    let K = Oi(...O);
    return j(s(y(K, St("context", F), !!i)));
  }
  function ge(F, O, K = {}) {
    (F = St("message", F)), i && (F = i(F));
    let { prefix: H, scalar: he, pointBytes: Ee } = W(O),
      Se = pe(K.context, H, F),
      Pe = T.multiply(Se).toRawBytes(),
      ye = pe(K.context, Pe, Ee, F),
      ze = U(Se + ye * he);
    Fn("signature.s", ze, Nr, r);
    let nt = Oi(Pe, Lo(ze, t.BYTES));
    return St("result", nt, t.BYTES * 2);
  }
  let _e = QF;
  function X(F, O, K, H = _e) {
    let { context: he, zip215: Ee } = H,
      Se = t.BYTES;
    (F = St("signature", F, 2 * Se)),
      (O = St("message", O)),
      (K = St("publicKey", K, Se)),
      Ee !== void 0 && Or("zip215", Ee),
      i && (O = i(O));
    let Pe = Ts(F.slice(Se, 2 * Se)),
      ye,
      ze,
      nt;
    try {
      (ye = E.fromHex(K, Ee)),
        (ze = E.fromHex(F.slice(0, Se), Ee)),
        (nt = T.multiplyUnsafe(Pe));
    } catch {
      return !1;
    }
    if (!Ee && ye.isSmallOrder()) return !1;
    let Wt = pe(he, ze.toRawBytes(), ye.toRawBytes(), O);
    return ze
      .add(ye.multiplyUnsafe(Wt))
      .subtract(nt)
      .clearCofactor()
      .equals(E.ZERO);
  }
  return (
    T._setWindowSize(8),
    {
      CURVE: e,
      getPublicKey: be,
      sign: ge,
      verify: X,
      ExtendedPoint: E,
      utils: {
        getExtendedPublicKey: W,
        randomPrivateKey: () => o(t.BYTES),
        precompute(F = 8, O = E.BASE) {
          return O._setWindowSize(F), O.multiply(BigInt(3)), O;
        },
      },
    }
  );
}
var Nr,
  Mn,
  Md,
  qF,
  QF,
  JI = ot(() => {
    "use strict";
    p();
    aw();
    kc();
    No();
    No();
    (Nr = BigInt(0)),
      (Mn = BigInt(1)),
      (Md = BigInt(2)),
      (qF = BigInt(8)),
      (QF = { zip215: !0 });
  });
function eM(n) {
  let e = BigInt(10),
    t = BigInt(20),
    r = BigInt(40),
    i = BigInt(80),
    s = cw,
    a = (((n * n) % s) * n) % s,
    c = (wt(a, ZI, s) * a) % s,
    u = (wt(c, YF, s) * n) % s,
    l = (wt(u, ZF, s) * u) % s,
    h = (wt(l, e, s) * l) % s,
    f = (wt(h, t, s) * h) % s,
    g = (wt(f, r, s) * f) % s,
    y = (wt(g, i, s) * g) % s,
    w = (wt(y, i, s) * g) % s,
    m = (wt(w, e, s) * l) % s;
  return { pow_p_5_8: (wt(m, ZI, s) * n) % s, b2: a };
}
function tM(n) {
  return (n[0] &= 248), (n[31] &= 127), (n[31] |= 64), n;
}
function nM(n, e) {
  let t = cw,
    r = it(e * e * e, t),
    i = it(r * r * e, t),
    s = eM(n * i).pow_p_5_8,
    o = it(n * r * s, t),
    a = it(e * o * o, t),
    c = o,
    u = it(o * YI, t),
    l = a === n,
    h = a === it(-n, t),
    f = a === it(-n * YI, t);
  return (
    l && (o = c),
    (h || f) && (o = u),
    HI(o, t) && (o = it(-o, t)),
    { isValid: l || h, value: o }
  );
}
var cw,
  YI,
  yX,
  YF,
  ZI,
  wX,
  ZF,
  XF,
  rM,
  iM,
  Mo,
  XI = ot(() => {
    "use strict";
    p();
    MI();
    Do();
    JI();
    kc();
    (cw = BigInt(
      "57896044618658097711785492504343953926634992332820282019728792003956564819949"
    )),
      (YI = BigInt(
        "19681161376707505956807079304988542015446066515923890162744021073123829784752"
      )),
      (yX = BigInt(0)),
      (YF = BigInt(1)),
      (ZI = BigInt(2)),
      (wX = BigInt(3)),
      (ZF = BigInt(5)),
      (XF = BigInt(8));
    (rM = Bs(cw, void 0, !0)),
      (iM = {
        a: BigInt(-1),
        d: BigInt(
          "37095705934669439343138083508754565189542113879843219016388785533085940283555"
        ),
        Fp: rM,
        n: BigInt(
          "7237005577332262213973186563042994240857116359379907606001950938285454250989"
        ),
        h: XF,
        Gx: BigInt(
          "15112221349535400772501151409588531511454012693041857206046113283949847762202"
        ),
        Gy: BigInt(
          "46316835694926478169428394003475163141307993866256225615783033603165251855960"
        ),
        hash: FI,
        randomBytes: Rd,
        adjustScalarBytes: tM,
        uvRatio: nM,
      }),
      (Mo = QI(iM));
  });
var fC = ve((Rc) => {
  "use strict";
  p();
  var uw = Wh(),
    Tc = Hh(),
    eC =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : null;
  Rc.Buffer = N;
  Rc.SlowBuffer = lM;
  Rc.INSPECT_MAX_BYTES = 50;
  var Ud = 2147483647;
  Rc.kMaxLength = Ud;
  N.TYPED_ARRAY_SUPPORT = sM();
  !N.TYPED_ARRAY_SUPPORT &&
    typeof console < "u" &&
    typeof console.error == "function" &&
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  function sM() {
    try {
      var n = new Uint8Array(1),
        e = {
          foo: function () {
            return 42;
          },
        };
      return (
        Object.setPrototypeOf(e, Uint8Array.prototype),
        Object.setPrototypeOf(n, e),
        n.foo() === 42
      );
    } catch {
      return !1;
    }
  }
  Object.defineProperty(N.prototype, "parent", {
    enumerable: !0,
    get: function () {
      if (N.isBuffer(this)) return this.buffer;
    },
  });
  Object.defineProperty(N.prototype, "offset", {
    enumerable: !0,
    get: function () {
      if (N.isBuffer(this)) return this.byteOffset;
    },
  });
  function Ni(n) {
    if (n > Ud)
      throw new RangeError(
        'The value "' + n + '" is invalid for option "size"'
      );
    var e = new Uint8Array(n);
    return Object.setPrototypeOf(e, N.prototype), e;
  }
  function N(n, e, t) {
    if (typeof n == "number") {
      if (typeof e == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return dw(n);
    }
    return rC(n, e, t);
  }
  N.poolSize = 8192;
  function rC(n, e, t) {
    if (typeof n == "string") return aM(n, e);
    if (ArrayBuffer.isView(n)) return cM(n);
    if (n == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof n
      );
    if (
      Zr(n, ArrayBuffer) ||
      (n && Zr(n.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < "u" &&
        (Zr(n, SharedArrayBuffer) || (n && Zr(n.buffer, SharedArrayBuffer))))
    )
      return hw(n, e, t);
    if (typeof n == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var r = n.valueOf && n.valueOf();
    if (r != null && r !== n) return N.from(r, e, t);
    var i = uM(n);
    if (i) return i;
    if (
      typeof Symbol < "u" &&
      Symbol.toPrimitive != null &&
      typeof n[Symbol.toPrimitive] == "function"
    )
      return N.from(n[Symbol.toPrimitive]("string"), e, t);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof n
    );
  }
  N.from = function (n, e, t) {
    return rC(n, e, t);
  };
  Object.setPrototypeOf(N.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(N, Uint8Array);
  function iC(n) {
    if (typeof n != "number")
      throw new TypeError('"size" argument must be of type number');
    if (n < 0)
      throw new RangeError(
        'The value "' + n + '" is invalid for option "size"'
      );
  }
  function oM(n, e, t) {
    return (
      iC(n),
      n <= 0
        ? Ni(n)
        : e !== void 0
        ? typeof t == "string"
          ? Ni(n).fill(e, t)
          : Ni(n).fill(e)
        : Ni(n)
    );
  }
  N.alloc = function (n, e, t) {
    return oM(n, e, t);
  };
  function dw(n) {
    return iC(n), Ni(n < 0 ? 0 : pw(n) | 0);
  }
  N.allocUnsafe = function (n) {
    return dw(n);
  };
  N.allocUnsafeSlow = function (n) {
    return dw(n);
  };
  function aM(n, e) {
    if (((typeof e != "string" || e === "") && (e = "utf8"), !N.isEncoding(e)))
      throw new TypeError("Unknown encoding: " + e);
    var t = sC(n, e) | 0,
      r = Ni(t),
      i = r.write(n, e);
    return i !== t && (r = r.slice(0, i)), r;
  }
  function lw(n) {
    for (
      var e = n.length < 0 ? 0 : pw(n.length) | 0, t = Ni(e), r = 0;
      r < e;
      r += 1
    )
      t[r] = n[r] & 255;
    return t;
  }
  function cM(n) {
    if (Zr(n, Uint8Array)) {
      var e = new Uint8Array(n);
      return hw(e.buffer, e.byteOffset, e.byteLength);
    }
    return lw(n);
  }
  function hw(n, e, t) {
    if (e < 0 || n.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (n.byteLength < e + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var r;
    return (
      e === void 0 && t === void 0
        ? (r = new Uint8Array(n))
        : t === void 0
        ? (r = new Uint8Array(n, e))
        : (r = new Uint8Array(n, e, t)),
      Object.setPrototypeOf(r, N.prototype),
      r
    );
  }
  function uM(n) {
    if (N.isBuffer(n)) {
      var e = pw(n.length) | 0,
        t = Ni(e);
      return t.length === 0 || n.copy(t, 0, 0, e), t;
    }
    if (n.length !== void 0)
      return typeof n.length != "number" || gw(n.length) ? Ni(0) : lw(n);
    if (n.type === "Buffer" && Array.isArray(n.data)) return lw(n.data);
  }
  function pw(n) {
    if (n >= Ud)
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          Ud.toString(16) +
          " bytes"
      );
    return n | 0;
  }
  function lM(n) {
    return +n != n && (n = 0), N.alloc(+n);
  }
  N.isBuffer = function (e) {
    return e != null && e._isBuffer === !0 && e !== N.prototype;
  };
  N.compare = function (e, t) {
    if (
      (Zr(e, Uint8Array) && (e = N.from(e, e.offset, e.byteLength)),
      Zr(t, Uint8Array) && (t = N.from(t, t.offset, t.byteLength)),
      !N.isBuffer(e) || !N.isBuffer(t))
    )
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (e === t) return 0;
    for (var r = e.length, i = t.length, s = 0, o = Math.min(r, i); s < o; ++s)
      if (e[s] !== t[s]) {
        (r = e[s]), (i = t[s]);
        break;
      }
    return r < i ? -1 : i < r ? 1 : 0;
  };
  N.isEncoding = function (e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  };
  N.concat = function (e, t) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0) return N.alloc(0);
    var r;
    if (t === void 0) for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
    var i = N.allocUnsafe(t),
      s = 0;
    for (r = 0; r < e.length; ++r) {
      var o = e[r];
      if (Zr(o, Uint8Array))
        s + o.length > i.length
          ? N.from(o).copy(i, s)
          : Uint8Array.prototype.set.call(i, o, s);
      else if (N.isBuffer(o)) o.copy(i, s);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      s += o.length;
    }
    return i;
  };
  function sC(n, e) {
    if (N.isBuffer(n)) return n.length;
    if (ArrayBuffer.isView(n) || Zr(n, ArrayBuffer)) return n.byteLength;
    if (typeof n != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof n
      );
    var t = n.length,
      r = arguments.length > 2 && arguments[2] === !0;
    if (!r && t === 0) return 0;
    for (var i = !1; ; )
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return fw(n).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return hC(n).length;
        default:
          if (i) return r ? -1 : fw(n).length;
          (e = ("" + e).toLowerCase()), (i = !0);
      }
  }
  N.byteLength = sC;
  function hM(n, e, t) {
    var r = !1;
    if (
      ((e === void 0 || e < 0) && (e = 0),
      e > this.length ||
        ((t === void 0 || t > this.length) && (t = this.length), t <= 0) ||
        ((t >>>= 0), (e >>>= 0), t <= e))
    )
      return "";
    for (n || (n = "utf8"); ; )
      switch (n) {
        case "hex":
          return EM(this, e, t);
        case "utf8":
        case "utf-8":
          return aC(this, e, t);
        case "ascii":
          return bM(this, e, t);
        case "latin1":
        case "binary":
          return AM(this, e, t);
        case "base64":
          return yM(this, e, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return xM(this, e, t);
        default:
          if (r) throw new TypeError("Unknown encoding: " + n);
          (n = (n + "").toLowerCase()), (r = !0);
      }
  }
  N.prototype._isBuffer = !0;
  function Uo(n, e, t) {
    var r = n[e];
    (n[e] = n[t]), (n[t] = r);
  }
  N.prototype.swap16 = function () {
    var e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var t = 0; t < e; t += 2) Uo(this, t, t + 1);
    return this;
  };
  N.prototype.swap32 = function () {
    var e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var t = 0; t < e; t += 4) Uo(this, t, t + 3), Uo(this, t + 1, t + 2);
    return this;
  };
  N.prototype.swap64 = function () {
    var e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var t = 0; t < e; t += 8)
      Uo(this, t, t + 7),
        Uo(this, t + 1, t + 6),
        Uo(this, t + 2, t + 5),
        Uo(this, t + 3, t + 4);
    return this;
  };
  N.prototype.toString = function () {
    var e = this.length;
    return e === 0
      ? ""
      : arguments.length === 0
      ? aC(this, 0, e)
      : hM.apply(this, arguments);
  };
  N.prototype.toLocaleString = N.prototype.toString;
  N.prototype.equals = function (e) {
    if (!N.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
    return this === e ? !0 : N.compare(this, e) === 0;
  };
  N.prototype.inspect = function () {
    var e = "",
      t = Rc.INSPECT_MAX_BYTES;
    return (
      (e = this.toString("hex", 0, t)
        .replace(/(.{2})/g, "$1 ")
        .trim()),
      this.length > t && (e += " ... "),
      "<Buffer " + e + ">"
    );
  };
  eC && (N.prototype[eC] = N.prototype.inspect);
  N.prototype.compare = function (e, t, r, i, s) {
    if (
      (Zr(e, Uint8Array) && (e = N.from(e, e.offset, e.byteLength)),
      !N.isBuffer(e))
    )
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
          typeof e
      );
    if (
      (t === void 0 && (t = 0),
      r === void 0 && (r = e ? e.length : 0),
      i === void 0 && (i = 0),
      s === void 0 && (s = this.length),
      t < 0 || r > e.length || i < 0 || s > this.length)
    )
      throw new RangeError("out of range index");
    if (i >= s && t >= r) return 0;
    if (i >= s) return -1;
    if (t >= r) return 1;
    if (((t >>>= 0), (r >>>= 0), (i >>>= 0), (s >>>= 0), this === e)) return 0;
    for (
      var o = s - i,
        a = r - t,
        c = Math.min(o, a),
        u = this.slice(i, s),
        l = e.slice(t, r),
        h = 0;
      h < c;
      ++h
    )
      if (u[h] !== l[h]) {
        (o = u[h]), (a = l[h]);
        break;
      }
    return o < a ? -1 : a < o ? 1 : 0;
  };
  function oC(n, e, t, r, i) {
    if (n.length === 0) return -1;
    if (
      (typeof t == "string"
        ? ((r = t), (t = 0))
        : t > 2147483647
        ? (t = 2147483647)
        : t < -2147483648 && (t = -2147483648),
      (t = +t),
      gw(t) && (t = i ? 0 : n.length - 1),
      t < 0 && (t = n.length + t),
      t >= n.length)
    ) {
      if (i) return -1;
      t = n.length - 1;
    } else if (t < 0)
      if (i) t = 0;
      else return -1;
    if ((typeof e == "string" && (e = N.from(e, r)), N.isBuffer(e)))
      return e.length === 0 ? -1 : tC(n, e, t, r, i);
    if (typeof e == "number")
      return (
        (e = e & 255),
        typeof Uint8Array.prototype.indexOf == "function"
          ? i
            ? Uint8Array.prototype.indexOf.call(n, e, t)
            : Uint8Array.prototype.lastIndexOf.call(n, e, t)
          : tC(n, [e], t, r, i)
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  function tC(n, e, t, r, i) {
    var s = 1,
      o = n.length,
      a = e.length;
    if (
      r !== void 0 &&
      ((r = String(r).toLowerCase()),
      r === "ucs2" || r === "ucs-2" || r === "utf16le" || r === "utf-16le")
    ) {
      if (n.length < 2 || e.length < 2) return -1;
      (s = 2), (o /= 2), (a /= 2), (t /= 2);
    }
    function c(g, y) {
      return s === 1 ? g[y] : g.readUInt16BE(y * s);
    }
    var u;
    if (i) {
      var l = -1;
      for (u = t; u < o; u++)
        if (c(n, u) === c(e, l === -1 ? 0 : u - l)) {
          if ((l === -1 && (l = u), u - l + 1 === a)) return l * s;
        } else l !== -1 && (u -= u - l), (l = -1);
    } else
      for (t + a > o && (t = o - a), u = t; u >= 0; u--) {
        for (var h = !0, f = 0; f < a; f++)
          if (c(n, u + f) !== c(e, f)) {
            h = !1;
            break;
          }
        if (h) return u;
      }
    return -1;
  }
  N.prototype.includes = function (e, t, r) {
    return this.indexOf(e, t, r) !== -1;
  };
  N.prototype.indexOf = function (e, t, r) {
    return oC(this, e, t, r, !0);
  };
  N.prototype.lastIndexOf = function (e, t, r) {
    return oC(this, e, t, r, !1);
  };
  function fM(n, e, t, r) {
    t = Number(t) || 0;
    var i = n.length - t;
    r ? ((r = Number(r)), r > i && (r = i)) : (r = i);
    var s = e.length;
    r > s / 2 && (r = s / 2);
    for (var o = 0; o < r; ++o) {
      var a = parseInt(e.substr(o * 2, 2), 16);
      if (gw(a)) return o;
      n[t + o] = a;
    }
    return o;
  }
  function dM(n, e, t, r) {
    return zd(fw(e, n.length - t), n, t, r);
  }
  function pM(n, e, t, r) {
    return zd(IM(e), n, t, r);
  }
  function gM(n, e, t, r) {
    return zd(hC(e), n, t, r);
  }
  function mM(n, e, t, r) {
    return zd(CM(e, n.length - t), n, t, r);
  }
  N.prototype.write = function (e, t, r, i) {
    if (t === void 0) (i = "utf8"), (r = this.length), (t = 0);
    else if (r === void 0 && typeof t == "string")
      (i = t), (r = this.length), (t = 0);
    else if (isFinite(t))
      (t = t >>> 0),
        isFinite(r)
          ? ((r = r >>> 0), i === void 0 && (i = "utf8"))
          : ((i = r), (r = void 0));
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var s = this.length - t;
    if (
      ((r === void 0 || r > s) && (r = s),
      (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds");
    i || (i = "utf8");
    for (var o = !1; ; )
      switch (i) {
        case "hex":
          return fM(this, e, t, r);
        case "utf8":
        case "utf-8":
          return dM(this, e, t, r);
        case "ascii":
        case "latin1":
        case "binary":
          return pM(this, e, t, r);
        case "base64":
          return gM(this, e, t, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return mM(this, e, t, r);
        default:
          if (o) throw new TypeError("Unknown encoding: " + i);
          (i = ("" + i).toLowerCase()), (o = !0);
      }
  };
  N.prototype.toJSON = function () {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0),
    };
  };
  function yM(n, e, t) {
    return e === 0 && t === n.length
      ? uw.fromByteArray(n)
      : uw.fromByteArray(n.slice(e, t));
  }
  function aC(n, e, t) {
    t = Math.min(n.length, t);
    for (var r = [], i = e; i < t; ) {
      var s = n[i],
        o = null,
        a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (i + a <= t) {
        var c, u, l, h;
        switch (a) {
          case 1:
            s < 128 && (o = s);
            break;
          case 2:
            (c = n[i + 1]),
              (c & 192) === 128 &&
                ((h = ((s & 31) << 6) | (c & 63)), h > 127 && (o = h));
            break;
          case 3:
            (c = n[i + 1]),
              (u = n[i + 2]),
              (c & 192) === 128 &&
                (u & 192) === 128 &&
                ((h = ((s & 15) << 12) | ((c & 63) << 6) | (u & 63)),
                h > 2047 && (h < 55296 || h > 57343) && (o = h));
            break;
          case 4:
            (c = n[i + 1]),
              (u = n[i + 2]),
              (l = n[i + 3]),
              (c & 192) === 128 &&
                (u & 192) === 128 &&
                (l & 192) === 128 &&
                ((h =
                  ((s & 15) << 18) |
                  ((c & 63) << 12) |
                  ((u & 63) << 6) |
                  (l & 63)),
                h > 65535 && h < 1114112 && (o = h));
        }
      }
      o === null
        ? ((o = 65533), (a = 1))
        : o > 65535 &&
          ((o -= 65536),
          r.push(((o >>> 10) & 1023) | 55296),
          (o = 56320 | (o & 1023))),
        r.push(o),
        (i += a);
    }
    return wM(r);
  }
  var nC = 4096;
  function wM(n) {
    var e = n.length;
    if (e <= nC) return String.fromCharCode.apply(String, n);
    for (var t = "", r = 0; r < e; )
      t += String.fromCharCode.apply(String, n.slice(r, (r += nC)));
    return t;
  }
  function bM(n, e, t) {
    var r = "";
    t = Math.min(n.length, t);
    for (var i = e; i < t; ++i) r += String.fromCharCode(n[i] & 127);
    return r;
  }
  function AM(n, e, t) {
    var r = "";
    t = Math.min(n.length, t);
    for (var i = e; i < t; ++i) r += String.fromCharCode(n[i]);
    return r;
  }
  function EM(n, e, t) {
    var r = n.length;
    (!e || e < 0) && (e = 0), (!t || t < 0 || t > r) && (t = r);
    for (var i = "", s = e; s < t; ++s) i += kM[n[s]];
    return i;
  }
  function xM(n, e, t) {
    for (var r = n.slice(e, t), i = "", s = 0; s < r.length - 1; s += 2)
      i += String.fromCharCode(r[s] + r[s + 1] * 256);
    return i;
  }
  N.prototype.slice = function (e, t) {
    var r = this.length;
    (e = ~~e),
      (t = t === void 0 ? r : ~~t),
      e < 0 ? ((e += r), e < 0 && (e = 0)) : e > r && (e = r),
      t < 0 ? ((t += r), t < 0 && (t = 0)) : t > r && (t = r),
      t < e && (t = e);
    var i = this.subarray(e, t);
    return Object.setPrototypeOf(i, N.prototype), i;
  };
  function qt(n, e, t) {
    if (n % 1 !== 0 || n < 0) throw new RangeError("offset is not uint");
    if (n + e > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  N.prototype.readUintLE = N.prototype.readUIntLE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || qt(e, t, this.length);
    for (var i = this[e], s = 1, o = 0; ++o < t && (s *= 256); )
      i += this[e + o] * s;
    return i;
  };
  N.prototype.readUintBE = N.prototype.readUIntBE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || qt(e, t, this.length);
    for (var i = this[e + --t], s = 1; t > 0 && (s *= 256); )
      i += this[e + --t] * s;
    return i;
  };
  N.prototype.readUint8 = N.prototype.readUInt8 = function (e, t) {
    return (e = e >>> 0), t || qt(e, 1, this.length), this[e];
  };
  N.prototype.readUint16LE = N.prototype.readUInt16LE = function (e, t) {
    return (
      (e = e >>> 0), t || qt(e, 2, this.length), this[e] | (this[e + 1] << 8)
    );
  };
  N.prototype.readUint16BE = N.prototype.readUInt16BE = function (e, t) {
    return (
      (e = e >>> 0), t || qt(e, 2, this.length), (this[e] << 8) | this[e + 1]
    );
  };
  N.prototype.readUint32LE = N.prototype.readUInt32LE = function (e, t) {
    return (
      (e = e >>> 0),
      t || qt(e, 4, this.length),
      (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
        this[e + 3] * 16777216
    );
  };
  N.prototype.readUint32BE = N.prototype.readUInt32BE = function (e, t) {
    return (
      (e = e >>> 0),
      t || qt(e, 4, this.length),
      this[e] * 16777216 +
        ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
    );
  };
  N.prototype.readIntLE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || qt(e, t, this.length);
    for (var i = this[e], s = 1, o = 0; ++o < t && (s *= 256); )
      i += this[e + o] * s;
    return (s *= 128), i >= s && (i -= Math.pow(2, 8 * t)), i;
  };
  N.prototype.readIntBE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || qt(e, t, this.length);
    for (var i = t, s = 1, o = this[e + --i]; i > 0 && (s *= 256); )
      o += this[e + --i] * s;
    return (s *= 128), o >= s && (o -= Math.pow(2, 8 * t)), o;
  };
  N.prototype.readInt8 = function (e, t) {
    return (
      (e = e >>> 0),
      t || qt(e, 1, this.length),
      this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
    );
  };
  N.prototype.readInt16LE = function (e, t) {
    (e = e >>> 0), t || qt(e, 2, this.length);
    var r = this[e] | (this[e + 1] << 8);
    return r & 32768 ? r | 4294901760 : r;
  };
  N.prototype.readInt16BE = function (e, t) {
    (e = e >>> 0), t || qt(e, 2, this.length);
    var r = this[e + 1] | (this[e] << 8);
    return r & 32768 ? r | 4294901760 : r;
  };
  N.prototype.readInt32LE = function (e, t) {
    return (
      (e = e >>> 0),
      t || qt(e, 4, this.length),
      this[e] | (this[e + 1] << 8) | (this[e + 2] << 16) | (this[e + 3] << 24)
    );
  };
  N.prototype.readInt32BE = function (e, t) {
    return (
      (e = e >>> 0),
      t || qt(e, 4, this.length),
      (this[e] << 24) | (this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3]
    );
  };
  N.prototype.readFloatLE = function (e, t) {
    return (
      (e = e >>> 0), t || qt(e, 4, this.length), Tc.read(this, e, !0, 23, 4)
    );
  };
  N.prototype.readFloatBE = function (e, t) {
    return (
      (e = e >>> 0), t || qt(e, 4, this.length), Tc.read(this, e, !1, 23, 4)
    );
  };
  N.prototype.readDoubleLE = function (e, t) {
    return (
      (e = e >>> 0), t || qt(e, 8, this.length), Tc.read(this, e, !0, 52, 8)
    );
  };
  N.prototype.readDoubleBE = function (e, t) {
    return (
      (e = e >>> 0), t || qt(e, 8, this.length), Tc.read(this, e, !1, 52, 8)
    );
  };
  function Un(n, e, t, r, i, s) {
    if (!N.isBuffer(n))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > i || e < s)
      throw new RangeError('"value" argument is out of bounds');
    if (t + r > n.length) throw new RangeError("Index out of range");
  }
  N.prototype.writeUintLE = N.prototype.writeUIntLE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), (r = r >>> 0), !i)) {
      var s = Math.pow(2, 8 * r) - 1;
      Un(this, e, t, r, s, 0);
    }
    var o = 1,
      a = 0;
    for (this[t] = e & 255; ++a < r && (o *= 256); )
      this[t + a] = (e / o) & 255;
    return t + r;
  };
  N.prototype.writeUintBE = N.prototype.writeUIntBE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), (r = r >>> 0), !i)) {
      var s = Math.pow(2, 8 * r) - 1;
      Un(this, e, t, r, s, 0);
    }
    var o = r - 1,
      a = 1;
    for (this[t + o] = e & 255; --o >= 0 && (a *= 256); )
      this[t + o] = (e / a) & 255;
    return t + r;
  };
  N.prototype.writeUint8 = N.prototype.writeUInt8 = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 1, 255, 0),
      (this[t] = e & 255),
      t + 1
    );
  };
  N.prototype.writeUint16LE = N.prototype.writeUInt16LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 2, 65535, 0),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      t + 2
    );
  };
  N.prototype.writeUint16BE = N.prototype.writeUInt16BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 2, 65535, 0),
      (this[t] = e >>> 8),
      (this[t + 1] = e & 255),
      t + 2
    );
  };
  N.prototype.writeUint32LE = N.prototype.writeUInt32LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 4, 4294967295, 0),
      (this[t + 3] = e >>> 24),
      (this[t + 2] = e >>> 16),
      (this[t + 1] = e >>> 8),
      (this[t] = e & 255),
      t + 4
    );
  };
  N.prototype.writeUint32BE = N.prototype.writeUInt32BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 4, 4294967295, 0),
      (this[t] = e >>> 24),
      (this[t + 1] = e >>> 16),
      (this[t + 2] = e >>> 8),
      (this[t + 3] = e & 255),
      t + 4
    );
  };
  N.prototype.writeIntLE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), !i)) {
      var s = Math.pow(2, 8 * r - 1);
      Un(this, e, t, r, s - 1, -s);
    }
    var o = 0,
      a = 1,
      c = 0;
    for (this[t] = e & 255; ++o < r && (a *= 256); )
      e < 0 && c === 0 && this[t + o - 1] !== 0 && (c = 1),
        (this[t + o] = (((e / a) >> 0) - c) & 255);
    return t + r;
  };
  N.prototype.writeIntBE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), !i)) {
      var s = Math.pow(2, 8 * r - 1);
      Un(this, e, t, r, s - 1, -s);
    }
    var o = r - 1,
      a = 1,
      c = 0;
    for (this[t + o] = e & 255; --o >= 0 && (a *= 256); )
      e < 0 && c === 0 && this[t + o + 1] !== 0 && (c = 1),
        (this[t + o] = (((e / a) >> 0) - c) & 255);
    return t + r;
  };
  N.prototype.writeInt8 = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 1, 127, -128),
      e < 0 && (e = 255 + e + 1),
      (this[t] = e & 255),
      t + 1
    );
  };
  N.prototype.writeInt16LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 2, 32767, -32768),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      t + 2
    );
  };
  N.prototype.writeInt16BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 2, 32767, -32768),
      (this[t] = e >>> 8),
      (this[t + 1] = e & 255),
      t + 2
    );
  };
  N.prototype.writeInt32LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 4, 2147483647, -2147483648),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      (this[t + 2] = e >>> 16),
      (this[t + 3] = e >>> 24),
      t + 4
    );
  };
  N.prototype.writeInt32BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Un(this, e, t, 4, 2147483647, -2147483648),
      e < 0 && (e = 4294967295 + e + 1),
      (this[t] = e >>> 24),
      (this[t + 1] = e >>> 16),
      (this[t + 2] = e >>> 8),
      (this[t + 3] = e & 255),
      t + 4
    );
  };
  function cC(n, e, t, r, i, s) {
    if (t + r > n.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  function uC(n, e, t, r, i) {
    return (
      (e = +e),
      (t = t >>> 0),
      i || cC(n, e, t, 4, 34028234663852886e22, -34028234663852886e22),
      Tc.write(n, e, t, r, 23, 4),
      t + 4
    );
  }
  N.prototype.writeFloatLE = function (e, t, r) {
    return uC(this, e, t, !0, r);
  };
  N.prototype.writeFloatBE = function (e, t, r) {
    return uC(this, e, t, !1, r);
  };
  function lC(n, e, t, r, i) {
    return (
      (e = +e),
      (t = t >>> 0),
      i || cC(n, e, t, 8, 17976931348623157e292, -17976931348623157e292),
      Tc.write(n, e, t, r, 52, 8),
      t + 8
    );
  }
  N.prototype.writeDoubleLE = function (e, t, r) {
    return lC(this, e, t, !0, r);
  };
  N.prototype.writeDoubleBE = function (e, t, r) {
    return lC(this, e, t, !1, r);
  };
  N.prototype.copy = function (e, t, r, i) {
    if (!N.isBuffer(e)) throw new TypeError("argument should be a Buffer");
    if (
      (r || (r = 0),
      !i && i !== 0 && (i = this.length),
      t >= e.length && (t = e.length),
      t || (t = 0),
      i > 0 && i < r && (i = r),
      i === r || e.length === 0 || this.length === 0)
    )
      return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
    if (i < 0) throw new RangeError("sourceEnd out of bounds");
    i > this.length && (i = this.length),
      e.length - t < i - r && (i = e.length - t + r);
    var s = i - r;
    return (
      this === e && typeof Uint8Array.prototype.copyWithin == "function"
        ? this.copyWithin(t, r, i)
        : Uint8Array.prototype.set.call(e, this.subarray(r, i), t),
      s
    );
  };
  N.prototype.fill = function (e, t, r, i) {
    if (typeof e == "string") {
      if (
        (typeof t == "string"
          ? ((i = t), (t = 0), (r = this.length))
          : typeof r == "string" && ((i = r), (r = this.length)),
        i !== void 0 && typeof i != "string")
      )
        throw new TypeError("encoding must be a string");
      if (typeof i == "string" && !N.isEncoding(i))
        throw new TypeError("Unknown encoding: " + i);
      if (e.length === 1) {
        var s = e.charCodeAt(0);
        ((i === "utf8" && s < 128) || i === "latin1") && (e = s);
      }
    } else
      typeof e == "number"
        ? (e = e & 255)
        : typeof e == "boolean" && (e = Number(e));
    if (t < 0 || this.length < t || this.length < r)
      throw new RangeError("Out of range index");
    if (r <= t) return this;
    (t = t >>> 0), (r = r === void 0 ? this.length : r >>> 0), e || (e = 0);
    var o;
    if (typeof e == "number") for (o = t; o < r; ++o) this[o] = e;
    else {
      var a = N.isBuffer(e) ? e : N.from(e, i),
        c = a.length;
      if (c === 0)
        throw new TypeError(
          'The value "' + e + '" is invalid for argument "value"'
        );
      for (o = 0; o < r - t; ++o) this[o + t] = a[o % c];
    }
    return this;
  };
  var SM = /[^+/0-9A-Za-z-_]/g;
  function vM(n) {
    if (((n = n.split("=")[0]), (n = n.trim().replace(SM, "")), n.length < 2))
      return "";
    for (; n.length % 4 !== 0; ) n = n + "=";
    return n;
  }
  function fw(n, e) {
    e = e || 1 / 0;
    for (var t, r = n.length, i = null, s = [], o = 0; o < r; ++o) {
      if (((t = n.charCodeAt(o)), t > 55295 && t < 57344)) {
        if (!i) {
          if (t > 56319) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          } else if (o + 1 === r) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          i = t;
          continue;
        }
        if (t < 56320) {
          (e -= 3) > -1 && s.push(239, 191, 189), (i = t);
          continue;
        }
        t = (((i - 55296) << 10) | (t - 56320)) + 65536;
      } else i && (e -= 3) > -1 && s.push(239, 191, 189);
      if (((i = null), t < 128)) {
        if ((e -= 1) < 0) break;
        s.push(t);
      } else if (t < 2048) {
        if ((e -= 2) < 0) break;
        s.push((t >> 6) | 192, (t & 63) | 128);
      } else if (t < 65536) {
        if ((e -= 3) < 0) break;
        s.push((t >> 12) | 224, ((t >> 6) & 63) | 128, (t & 63) | 128);
      } else if (t < 1114112) {
        if ((e -= 4) < 0) break;
        s.push(
          (t >> 18) | 240,
          ((t >> 12) & 63) | 128,
          ((t >> 6) & 63) | 128,
          (t & 63) | 128
        );
      } else throw new Error("Invalid code point");
    }
    return s;
  }
  function IM(n) {
    for (var e = [], t = 0; t < n.length; ++t) e.push(n.charCodeAt(t) & 255);
    return e;
  }
  function CM(n, e) {
    for (var t, r, i, s = [], o = 0; o < n.length && !((e -= 2) < 0); ++o)
      (t = n.charCodeAt(o)), (r = t >> 8), (i = t % 256), s.push(i), s.push(r);
    return s;
  }
  function hC(n) {
    return uw.toByteArray(vM(n));
  }
  function zd(n, e, t, r) {
    for (var i = 0; i < r && !(i + t >= e.length || i >= n.length); ++i)
      e[i + t] = n[i];
    return i;
  }
  function Zr(n, e) {
    return (
      n instanceof e ||
      (n != null &&
        n.constructor != null &&
        n.constructor.name != null &&
        n.constructor.name === e.name)
    );
  }
  function gw(n) {
    return n !== n;
  }
  var kM = (function () {
    for (var n = "0123456789abcdef", e = new Array(256), t = 0; t < 16; ++t)
      for (var r = t * 16, i = 0; i < 16; ++i) e[r + i] = n[t] + n[i];
    return e;
  })();
});
var gC = ve((mw, pC) => {
  "use strict";
  p();
  var jd = fC(),
    Xr = jd.Buffer;
  function dC(n, e) {
    for (var t in n) e[t] = n[t];
  }
  Xr.from && Xr.alloc && Xr.allocUnsafe && Xr.allocUnsafeSlow
    ? (pC.exports = jd)
    : (dC(jd, mw), (mw.Buffer = zo));
  function zo(n, e, t) {
    return Xr(n, e, t);
  }
  zo.prototype = Object.create(Xr.prototype);
  dC(Xr, zo);
  zo.from = function (n, e, t) {
    if (typeof n == "number")
      throw new TypeError("Argument must not be a number");
    return Xr(n, e, t);
  };
  zo.alloc = function (n, e, t) {
    if (typeof n != "number") throw new TypeError("Argument must be a number");
    var r = Xr(n);
    return (
      e !== void 0
        ? typeof t == "string"
          ? r.fill(e, t)
          : r.fill(e)
        : r.fill(0),
      r
    );
  };
  zo.allocUnsafe = function (n) {
    if (typeof n != "number") throw new TypeError("Argument must be a number");
    return Xr(n);
  };
  zo.allocUnsafeSlow = function (n) {
    if (typeof n != "number") throw new TypeError("Argument must be a number");
    return jd.SlowBuffer(n);
  };
});
var yC = ve((IX, mC) => {
  "use strict";
  p();
  var Wd = gC().Buffer;
  function TM(n) {
    if (n.length >= 255) throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), t = 0; t < e.length; t++) e[t] = 255;
    for (var r = 0; r < n.length; r++) {
      var i = n.charAt(r),
        s = i.charCodeAt(0);
      if (e[s] !== 255) throw new TypeError(i + " is ambiguous");
      e[s] = r;
    }
    var o = n.length,
      a = n.charAt(0),
      c = Math.log(o) / Math.log(256),
      u = Math.log(256) / Math.log(o);
    function l(g) {
      if (
        ((Array.isArray(g) || g instanceof Uint8Array) && (g = Wd.from(g)),
        !Wd.isBuffer(g))
      )
        throw new TypeError("Expected Buffer");
      if (g.length === 0) return "";
      for (var y = 0, w = 0, m = 0, b = g.length; m !== b && g[m] === 0; )
        m++, y++;
      for (var I = ((b - m) * u + 1) >>> 0, E = new Uint8Array(I); m !== b; ) {
        for (
          var T = g[m], B = 0, L = I - 1;
          (T !== 0 || B < w) && L !== -1;
          L--, B++
        )
          (T += (256 * E[L]) >>> 0), (E[L] = T % o >>> 0), (T = (T / o) >>> 0);
        if (T !== 0) throw new Error("Non-zero carry");
        (w = B), m++;
      }
      for (var U = I - w; U !== I && E[U] === 0; ) U++;
      for (var j = a.repeat(y); U < I; ++U) j += n.charAt(E[U]);
      return j;
    }
    function h(g) {
      if (typeof g != "string") throw new TypeError("Expected String");
      if (g.length === 0) return Wd.alloc(0);
      for (var y = 0, w = 0, m = 0; g[y] === a; ) w++, y++;
      for (
        var b = ((g.length - y) * c + 1) >>> 0, I = new Uint8Array(b);
        y < g.length;

      ) {
        var E = e[g.charCodeAt(y)];
        if (E === 255) return;
        for (var T = 0, B = b - 1; (E !== 0 || T < m) && B !== -1; B--, T++)
          (E += (o * I[B]) >>> 0),
            (I[B] = E % 256 >>> 0),
            (E = (E / 256) >>> 0);
        if (E !== 0) throw new Error("Non-zero carry");
        (m = T), y++;
      }
      for (var L = b - m; L !== b && I[L] === 0; ) L++;
      var U = Wd.allocUnsafe(w + (b - L));
      U.fill(0, 0, w);
      for (var j = w; L !== b; ) U[j++] = I[L++];
      return U;
    }
    function f(g) {
      var y = h(g);
      if (y) return y;
      throw new Error("Non-base" + o + " character");
    }
    return { encode: l, decodeUnsafe: h, decode: f };
  }
  mC.exports = TM;
});
var Hd = ve((kX, wC) => {
  "use strict";
  p();
  var RM = yC(),
    BM = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  wC.exports = RM(BM);
});
function yw(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function DM(n) {
  return (
    n instanceof Uint8Array ||
    (ArrayBuffer.isView(n) && n.constructor.name === "Uint8Array")
  );
}
function Ol(n, ...e) {
  if (!DM(n)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(n.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + n.length
    );
}
function Bc(n, e = !0) {
  if (n.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && n.finished) throw new Error("Hash#digest() has already been called");
}
function Vd(n, e) {
  Ol(n);
  let t = e.outputLen;
  if (n.length < t)
    throw new Error(
      "digestInto() expects output buffer of length at least " + t
    );
}
var $d = ot(() => {
  "use strict";
  p();
});
function bw(n) {
  for (let e = 0; e < n.length; e++) n[e] = _M(n[e]);
}
function PM(n) {
  if (typeof n != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof n);
  return new Uint8Array(new TextEncoder().encode(n));
}
function _c(n) {
  return typeof n == "string" && (n = PM(n)), Ol(n), n;
}
function Kd(n) {
  let e = (r) => n().update(_c(r)).digest(),
    t = n();
  return (
    (e.outputLen = t.outputLen),
    (e.blockLen = t.blockLen),
    (e.create = () => n()),
    e
  );
}
function AC(n) {
  let e = (r, i) => n(i).update(_c(r)).digest(),
    t = n({});
  return (
    (e.outputLen = t.outputLen),
    (e.blockLen = t.blockLen),
    (e.create = (r) => n(r)),
    e
  );
}
var bC,
  Gd,
  Fr,
  ww,
  _M,
  Dc,
  qd = ot(() => {
    "use strict";
    p();
    $d();
    (bC = (n) =>
      new Uint32Array(n.buffer, n.byteOffset, Math.floor(n.byteLength / 4))),
      (Gd = (n) => new DataView(n.buffer, n.byteOffset, n.byteLength)),
      (Fr = (n, e) => (n << (32 - e)) | (n >>> e)),
      (ww = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68),
      (_M = (n) =>
        ((n << 24) & 4278190080) |
        ((n << 8) & 16711680) |
        ((n >>> 8) & 65280) |
        ((n >>> 24) & 255));
    Dc = class {
      clone() {
        return this._cloneInto();
      }
    };
  });
function LM(n, e, t, r) {
  if (typeof n.setBigUint64 == "function") return n.setBigUint64(e, t, r);
  let i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((t >> i) & s),
    a = Number(t & s),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  n.setUint32(e + c, o, r), n.setUint32(e + u, a, r);
}
var EC,
  xC,
  Qd,
  SC = ot(() => {
    "use strict";
    p();
    $d();
    qd();
    (EC = (n, e, t) => (n & e) ^ (~n & t)),
      (xC = (n, e, t) => (n & e) ^ (n & t) ^ (e & t)),
      (Qd = class extends Dc {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = Gd(this.buffer));
        }
        update(e) {
          Bc(this);
          let { view: t, buffer: r, blockLen: i } = this;
          e = _c(e);
          let s = e.length;
          for (let o = 0; o < s; ) {
            let a = Math.min(i - this.pos, s - o);
            if (a === i) {
              let c = Gd(e);
              for (; i <= s - o; o += i) this.process(c, o);
              continue;
            }
            r.set(e.subarray(o, o + a), this.pos),
              (this.pos += a),
              (o += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          Bc(this), Vd(e, this), (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: s } = this,
            { pos: o } = this;
          (t[o++] = 128),
            this.buffer.subarray(o).fill(0),
            this.padOffset > i - o && (this.process(r, 0), (o = 0));
          for (let h = o; h < i; h++) t[h] = 0;
          LM(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
          let a = Gd(e),
            c = this.outputLen;
          if (c % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          let u = c / 4,
            l = this.get();
          if (u > l.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let h = 0; h < u; h++) a.setUint32(4 * h, l[h], s);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: s,
            destroyed: o,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = s),
            (e.destroyed = o),
            i % t && e.buffer.set(r),
            e
          );
        }
      });
  });
var OM,
  Ds,
  _s,
  Aw,
  Ew,
  vC = ot(() => {
    "use strict";
    p();
    SC();
    qd();
    (OM = new Uint32Array([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298,
    ])),
      (Ds = new Uint32Array([
        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
        528734635, 1541459225,
      ])),
      (_s = new Uint32Array(64)),
      (Aw = class extends Qd {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = Ds[0] | 0),
            (this.B = Ds[1] | 0),
            (this.C = Ds[2] | 0),
            (this.D = Ds[3] | 0),
            (this.E = Ds[4] | 0),
            (this.F = Ds[5] | 0),
            (this.G = Ds[6] | 0),
            (this.H = Ds[7] | 0);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: s, F: o, G: a, H: c } = this;
          return [e, t, r, i, s, o, a, c];
        }
        set(e, t, r, i, s, o, a, c) {
          (this.A = e | 0),
            (this.B = t | 0),
            (this.C = r | 0),
            (this.D = i | 0),
            (this.E = s | 0),
            (this.F = o | 0),
            (this.G = a | 0),
            (this.H = c | 0);
        }
        process(e, t) {
          for (let h = 0; h < 16; h++, t += 4) _s[h] = e.getUint32(t, !1);
          for (let h = 16; h < 64; h++) {
            let f = _s[h - 15],
              g = _s[h - 2],
              y = Fr(f, 7) ^ Fr(f, 18) ^ (f >>> 3),
              w = Fr(g, 17) ^ Fr(g, 19) ^ (g >>> 10);
            _s[h] = (w + _s[h - 7] + y + _s[h - 16]) | 0;
          }
          let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
          for (let h = 0; h < 64; h++) {
            let f = Fr(a, 6) ^ Fr(a, 11) ^ Fr(a, 25),
              g = (l + f + EC(a, c, u) + OM[h] + _s[h]) | 0,
              w = ((Fr(r, 2) ^ Fr(r, 13) ^ Fr(r, 22)) + xC(r, i, s)) | 0;
            (l = u),
              (u = c),
              (c = a),
              (a = (o + g) | 0),
              (o = s),
              (s = i),
              (i = r),
              (r = (g + w) | 0);
          }
          (r = (r + this.A) | 0),
            (i = (i + this.B) | 0),
            (s = (s + this.C) | 0),
            (o = (o + this.D) | 0),
            (a = (a + this.E) | 0),
            (c = (c + this.F) | 0),
            (u = (u + this.G) | 0),
            (l = (l + this.H) | 0),
            this.set(r, i, s, o, a, c, u, l);
        }
        roundClean() {
          _s.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }),
      (Ew = Kd(() => new Aw()));
  });
var IC = {};
Vg(IC, { TextDecoder: () => Zd, TextEncoder: () => Xd });
function Fi(n, e, t) {
  return e <= n && n <= t;
}
function ep(n) {
  if (n === void 0) return {};
  if (n === Object(n)) return n;
  throw TypeError("Could not convert argument to dictionary");
}
function NM(n) {
  for (var e = String(n), t = e.length, r = 0, i = []; r < t; ) {
    var s = e.charCodeAt(r);
    if (s < 55296 || s > 57343) i.push(s);
    else if (56320 <= s && s <= 57343) i.push(65533);
    else if (55296 <= s && s <= 56319)
      if (r === t - 1) i.push(65533);
      else {
        var o = n.charCodeAt(r + 1);
        if (56320 <= o && o <= 57343) {
          var a = s & 1023,
            c = o & 1023;
          i.push(65536 + (a << 10) + c), (r += 1);
        } else i.push(65533);
      }
    r += 1;
  }
  return i;
}
function FM(n) {
  for (var e = "", t = 0; t < n.length; ++t) {
    var r = n[t];
    r <= 65535
      ? (e += String.fromCharCode(r))
      : ((r -= 65536),
        (e += String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320)));
  }
  return e;
}
function Sw(n) {
  this.tokens = [].slice.call(n);
}
function xw(n, e) {
  if (n) throw TypeError("Decoder error");
  return e || 65533;
}
function MM() {}
function UM() {}
function Zd(n, e) {
  if (!(this instanceof Zd)) return new Zd(n, e);
  if (((n = n !== void 0 ? String(n).toLowerCase() : Yd), n !== Yd))
    throw new Error("Encoding not supported. Only utf-8 is supported");
  (e = ep(e)),
    (this._streaming = !1),
    (this._BOMseen = !1),
    (this._decoder = null),
    (this._fatal = !!e.fatal),
    (this._ignoreBOM = !!e.ignoreBOM),
    Object.defineProperty(this, "encoding", { value: "utf-8" }),
    Object.defineProperty(this, "fatal", { value: this._fatal }),
    Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function Xd(n, e) {
  if (!(this instanceof Xd)) return new Xd(n, e);
  if (((n = n !== void 0 ? String(n).toLowerCase() : Yd), n !== Yd))
    throw new Error("Encoding not supported. Only utf-8 is supported");
  (e = ep(e)),
    (this._streaming = !1),
    (this._encoder = null),
    (this._options = { fatal: !!e.fatal }),
    Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function zM(n) {
  var e = n.fatal,
    t = 0,
    r = 0,
    i = 0,
    s = 128,
    o = 191;
  this.handler = function (a, c) {
    if (c === Jd && i !== 0) return (i = 0), xw(e);
    if (c === Jd) return Pc;
    if (i === 0) {
      if (Fi(c, 0, 127)) return c;
      if (Fi(c, 194, 223)) (i = 1), (t = c - 192);
      else if (Fi(c, 224, 239))
        c === 224 && (s = 160), c === 237 && (o = 159), (i = 2), (t = c - 224);
      else if (Fi(c, 240, 244))
        c === 240 && (s = 144), c === 244 && (o = 143), (i = 3), (t = c - 240);
      else return xw(e);
      return (t = t << (6 * i)), null;
    }
    if (!Fi(c, s, o))
      return (t = i = r = 0), (s = 128), (o = 191), a.prepend(c), xw(e);
    if (
      ((s = 128),
      (o = 191),
      (r += 1),
      (t += (c - 128) << (6 * (i - r))),
      r !== i)
    )
      return null;
    var u = t;
    return (t = i = r = 0), u;
  };
}
function jM(n) {
  var e = n.fatal;
  this.handler = function (t, r) {
    if (r === Jd) return Pc;
    if (Fi(r, 0, 127)) return r;
    var i, s;
    Fi(r, 128, 2047)
      ? ((i = 1), (s = 192))
      : Fi(r, 2048, 65535)
      ? ((i = 2), (s = 224))
      : Fi(r, 65536, 1114111) && ((i = 3), (s = 240));
    for (var o = [(r >> (6 * i)) + s]; i > 0; ) {
      var a = r >> (6 * (i - 1));
      o.push(128 | (a & 63)), (i -= 1);
    }
    return o;
  };
}
var Jd,
  Pc,
  Yd,
  CC = ot(() => {
    "use strict";
    p();
    Jd = -1;
    Sw.prototype = {
      endOfStream: function () {
        return !this.tokens.length;
      },
      read: function () {
        return this.tokens.length ? this.tokens.shift() : Jd;
      },
      prepend: function (n) {
        if (Array.isArray(n))
          for (var e = n; e.length; ) this.tokens.unshift(e.pop());
        else this.tokens.unshift(n);
      },
      push: function (n) {
        if (Array.isArray(n))
          for (var e = n; e.length; ) this.tokens.push(e.shift());
        else this.tokens.push(n);
      },
    };
    Pc = -1;
    MM.prototype = { handler: function (n, e) {} };
    UM.prototype = { handler: function (n, e) {} };
    Yd = "utf-8";
    Zd.prototype = {
      decode: function (e, t) {
        var r;
        typeof e == "object" && e instanceof ArrayBuffer
          ? (r = new Uint8Array(e))
          : typeof e == "object" &&
            "buffer" in e &&
            e.buffer instanceof ArrayBuffer
          ? (r = new Uint8Array(e.buffer, e.byteOffset, e.byteLength))
          : (r = new Uint8Array(0)),
          (t = ep(t)),
          this._streaming ||
            ((this._decoder = new zM({ fatal: this._fatal })),
            (this._BOMseen = !1)),
          (this._streaming = !!t.stream);
        for (
          var i = new Sw(r), s = [], o;
          !i.endOfStream() &&
          ((o = this._decoder.handler(i, i.read())), o !== Pc);

        )
          o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o));
        if (!this._streaming) {
          do {
            if (((o = this._decoder.handler(i, i.read())), o === Pc)) break;
            o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o));
          } while (!i.endOfStream());
          this._decoder = null;
        }
        return (
          s.length &&
            ["utf-8"].indexOf(this.encoding) !== -1 &&
            !this._ignoreBOM &&
            !this._BOMseen &&
            (s[0] === 65279
              ? ((this._BOMseen = !0), s.shift())
              : (this._BOMseen = !0)),
          FM(s)
        );
      },
    };
    Xd.prototype = {
      encode: function (e, t) {
        (e = e ? String(e) : ""),
          (t = ep(t)),
          this._streaming || (this._encoder = new jM(this._options)),
          (this._streaming = !!t.stream);
        for (
          var r = [], i = new Sw(NM(e)), s;
          !i.endOfStream() &&
          ((s = this._encoder.handler(i, i.read())), s !== Pc);

        )
          Array.isArray(s) ? r.push.apply(r, s) : r.push(s);
        if (!this._streaming) {
          for (; (s = this._encoder.handler(i, i.read())), s !== Pc; )
            Array.isArray(s) ? r.push.apply(r, s) : r.push(s);
          this._encoder = null;
        }
        return new Uint8Array(r);
      },
    };
  });
var DC = ve((st) => {
  "use strict";
  p();
  var WM =
      (st && st.__createBinding) ||
      (Object.create
        ? function (n, e, t, r) {
            r === void 0 && (r = t),
              Object.defineProperty(n, r, {
                enumerable: !0,
                get: function () {
                  return e[t];
                },
              });
          }
        : function (n, e, t, r) {
            r === void 0 && (r = t), (n[r] = e[t]);
          }),
    HM =
      (st && st.__setModuleDefault) ||
      (Object.create
        ? function (n, e) {
            Object.defineProperty(n, "default", { enumerable: !0, value: e });
          }
        : function (n, e) {
            n.default = e;
          }),
    ei =
      (st && st.__decorate) ||
      function (n, e, t, r) {
        var i = arguments.length,
          s =
            i < 3
              ? e
              : r === null
              ? (r = Object.getOwnPropertyDescriptor(e, t))
              : r,
          o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          s = Reflect.decorate(n, e, t, r);
        else
          for (var a = n.length - 1; a >= 0; a--)
            (o = n[a]) &&
              (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
        return i > 3 && s && Object.defineProperty(e, t, s), s;
      },
    VM =
      (st && st.__importStar) ||
      function (n) {
        if (n && n.__esModule) return n;
        var e = {};
        if (n != null)
          for (var t in n)
            t !== "default" && Object.hasOwnProperty.call(n, t) && WM(e, n, t);
        return HM(e, n), e;
      },
    kC =
      (st && st.__importDefault) ||
      function (n) {
        return n && n.__esModule ? n : { default: n };
      };
  Object.defineProperty(st, "__esModule", { value: !0 });
  st.deserializeUnchecked =
    st.deserialize =
    st.serialize =
    st.BinaryReader =
    st.BinaryWriter =
    st.BorshError =
    st.baseDecode =
    st.baseEncode =
      void 0;
  var Ps = kC(VE()),
    TC = kC(Hd()),
    $M = VM((CC(), $g(IC))),
    GM = typeof TextDecoder != "function" ? $M.TextDecoder : TextDecoder,
    KM = new GM("utf-8", { fatal: !0 });
  function qM(n) {
    return (
      typeof n == "string" && (n = Buffer.from(n, "utf8")),
      TC.default.encode(Buffer.from(n))
    );
  }
  st.baseEncode = qM;
  function QM(n) {
    return Buffer.from(TC.default.decode(n));
  }
  st.baseDecode = QM;
  var vw = 1024,
    on = class extends Error {
      constructor(e) {
        super(e), (this.fieldPath = []), (this.originalMessage = e);
      }
      addToFieldPath(e) {
        this.fieldPath.splice(0, 0, e),
          (this.message =
            this.originalMessage + ": " + this.fieldPath.join("."));
      }
    };
  st.BorshError = on;
  var tp = class {
    constructor() {
      (this.buf = Buffer.alloc(vw)), (this.length = 0);
    }
    maybeResize() {
      this.buf.length < 16 + this.length &&
        (this.buf = Buffer.concat([this.buf, Buffer.alloc(vw)]));
    }
    writeU8(e) {
      this.maybeResize(),
        this.buf.writeUInt8(e, this.length),
        (this.length += 1);
    }
    writeU16(e) {
      this.maybeResize(),
        this.buf.writeUInt16LE(e, this.length),
        (this.length += 2);
    }
    writeU32(e) {
      this.maybeResize(),
        this.buf.writeUInt32LE(e, this.length),
        (this.length += 4);
    }
    writeU64(e) {
      this.maybeResize(),
        this.writeBuffer(Buffer.from(new Ps.default(e).toArray("le", 8)));
    }
    writeU128(e) {
      this.maybeResize(),
        this.writeBuffer(Buffer.from(new Ps.default(e).toArray("le", 16)));
    }
    writeU256(e) {
      this.maybeResize(),
        this.writeBuffer(Buffer.from(new Ps.default(e).toArray("le", 32)));
    }
    writeU512(e) {
      this.maybeResize(),
        this.writeBuffer(Buffer.from(new Ps.default(e).toArray("le", 64)));
    }
    writeBuffer(e) {
      (this.buf = Buffer.concat([
        Buffer.from(this.buf.subarray(0, this.length)),
        e,
        Buffer.alloc(vw),
      ])),
        (this.length += e.length);
    }
    writeString(e) {
      this.maybeResize();
      let t = Buffer.from(e, "utf8");
      this.writeU32(t.length), this.writeBuffer(t);
    }
    writeFixedArray(e) {
      this.writeBuffer(Buffer.from(e));
    }
    writeArray(e, t) {
      this.maybeResize(), this.writeU32(e.length);
      for (let r of e) this.maybeResize(), t(r);
    }
    toArray() {
      return this.buf.subarray(0, this.length);
    }
  };
  st.BinaryWriter = tp;
  function ti(n, e, t) {
    let r = t.value;
    t.value = function (...i) {
      try {
        return r.apply(this, i);
      } catch (s) {
        if (s instanceof RangeError) {
          let o = s.code;
          if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(o) >= 0)
            throw new on("Reached the end of buffer when deserializing");
        }
        throw s;
      }
    };
  }
  var kn = class {
    constructor(e) {
      (this.buf = e), (this.offset = 0);
    }
    readU8() {
      let e = this.buf.readUInt8(this.offset);
      return (this.offset += 1), e;
    }
    readU16() {
      let e = this.buf.readUInt16LE(this.offset);
      return (this.offset += 2), e;
    }
    readU32() {
      let e = this.buf.readUInt32LE(this.offset);
      return (this.offset += 4), e;
    }
    readU64() {
      let e = this.readBuffer(8);
      return new Ps.default(e, "le");
    }
    readU128() {
      let e = this.readBuffer(16);
      return new Ps.default(e, "le");
    }
    readU256() {
      let e = this.readBuffer(32);
      return new Ps.default(e, "le");
    }
    readU512() {
      let e = this.readBuffer(64);
      return new Ps.default(e, "le");
    }
    readBuffer(e) {
      if (this.offset + e > this.buf.length)
        throw new on(`Expected buffer length ${e} isn't within bounds`);
      let t = this.buf.slice(this.offset, this.offset + e);
      return (this.offset += e), t;
    }
    readString() {
      let e = this.readU32(),
        t = this.readBuffer(e);
      try {
        return KM.decode(t);
      } catch (r) {
        throw new on(`Error decoding UTF-8 string: ${r}`);
      }
    }
    readFixedArray(e) {
      return new Uint8Array(this.readBuffer(e));
    }
    readArray(e) {
      let t = this.readU32(),
        r = Array();
      for (let i = 0; i < t; ++i) r.push(e());
      return r;
    }
  };
  ei([ti], kn.prototype, "readU8", null);
  ei([ti], kn.prototype, "readU16", null);
  ei([ti], kn.prototype, "readU32", null);
  ei([ti], kn.prototype, "readU64", null);
  ei([ti], kn.prototype, "readU128", null);
  ei([ti], kn.prototype, "readU256", null);
  ei([ti], kn.prototype, "readU512", null);
  ei([ti], kn.prototype, "readString", null);
  ei([ti], kn.prototype, "readFixedArray", null);
  ei([ti], kn.prototype, "readArray", null);
  st.BinaryReader = kn;
  function RC(n) {
    return n.charAt(0).toUpperCase() + n.slice(1);
  }
  function jo(n, e, t, r, i) {
    try {
      if (typeof r == "string") i[`write${RC(r)}`](t);
      else if (r instanceof Array)
        if (typeof r[0] == "number") {
          if (t.length !== r[0])
            throw new on(
              `Expecting byte array of length ${r[0]}, but got ${t.length} bytes`
            );
          i.writeFixedArray(t);
        } else if (r.length === 2 && typeof r[1] == "number") {
          if (t.length !== r[1])
            throw new on(
              `Expecting byte array of length ${r[1]}, but got ${t.length} bytes`
            );
          for (let s = 0; s < r[1]; s++) jo(n, null, t[s], r[0], i);
        } else
          i.writeArray(t, (s) => {
            jo(n, e, s, r[0], i);
          });
      else if (r.kind !== void 0)
        switch (r.kind) {
          case "option": {
            t == null ? i.writeU8(0) : (i.writeU8(1), jo(n, e, t, r.type, i));
            break;
          }
          case "map": {
            i.writeU32(t.size),
              t.forEach((s, o) => {
                jo(n, e, o, r.key, i), jo(n, e, s, r.value, i);
              });
            break;
          }
          default:
            throw new on(`FieldType ${r} unrecognized`);
        }
      else BC(n, t, i);
    } catch (s) {
      throw (s instanceof on && s.addToFieldPath(e), s);
    }
  }
  function BC(n, e, t) {
    if (typeof e.borshSerialize == "function") {
      e.borshSerialize(t);
      return;
    }
    let r = n.get(e.constructor);
    if (!r) throw new on(`Class ${e.constructor.name} is missing in schema`);
    if (r.kind === "struct")
      r.fields.map(([i, s]) => {
        jo(n, i, e[i], s, t);
      });
    else if (r.kind === "enum") {
      let i = e[r.field];
      for (let s = 0; s < r.values.length; ++s) {
        let [o, a] = r.values[s];
        if (o === i) {
          t.writeU8(s), jo(n, o, e[o], a, t);
          break;
        }
      }
    } else
      throw new on(
        `Unexpected schema kind: ${r.kind} for ${e.constructor.name}`
      );
  }
  function JM(n, e, t = tp) {
    let r = new t();
    return BC(n, e, r), r.toArray();
  }
  st.serialize = JM;
  function Wo(n, e, t, r) {
    try {
      if (typeof t == "string") return r[`read${RC(t)}`]();
      if (t instanceof Array) {
        if (typeof t[0] == "number") return r.readFixedArray(t[0]);
        if (typeof t[1] == "number") {
          let i = [];
          for (let s = 0; s < t[1]; s++) i.push(Wo(n, null, t[0], r));
          return i;
        } else return r.readArray(() => Wo(n, e, t[0], r));
      }
      if (t.kind === "option") return r.readU8() ? Wo(n, e, t.type, r) : void 0;
      if (t.kind === "map") {
        let i = new Map(),
          s = r.readU32();
        for (let o = 0; o < s; o++) {
          let a = Wo(n, e, t.key, r),
            c = Wo(n, e, t.value, r);
          i.set(a, c);
        }
        return i;
      }
      return Iw(n, t, r);
    } catch (i) {
      throw (i instanceof on && i.addToFieldPath(e), i);
    }
  }
  function Iw(n, e, t) {
    if (typeof e.borshDeserialize == "function") return e.borshDeserialize(t);
    let r = n.get(e);
    if (!r) throw new on(`Class ${e.name} is missing in schema`);
    if (r.kind === "struct") {
      let i = {};
      for (let [s, o] of n.get(e).fields) i[s] = Wo(n, s, o, t);
      return new e(i);
    }
    if (r.kind === "enum") {
      let i = t.readU8();
      if (i >= r.values.length)
        throw new on(`Enum index: ${i} is out of range`);
      let [s, o] = r.values[i],
        a = Wo(n, s, o, t);
      return new e({ [s]: a });
    }
    throw new on(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`);
  }
  function YM(n, e, t, r = kn) {
    let i = new r(t),
      s = Iw(n, e, i);
    if (i.offset < t.length)
      throw new on(
        `Unexpected ${t.length - i.offset} bytes after deserialized data`
      );
    return s;
  }
  st.deserialize = YM;
  function ZM(n, e, t, r = kn) {
    let i = new r(t);
    return Iw(n, e, i);
  }
  st.deserializeUnchecked = ZM;
});
var qC = ve((Fc) => {
  "use strict";
  p();
  var Cw = Wh(),
    Oc = Hh(),
    _C =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : null;
  Fc.Buffer = _;
  Fc.SlowBuffer = i3;
  Fc.INSPECT_MAX_BYTES = 50;
  var np = 2147483647;
  Fc.kMaxLength = np;
  _.TYPED_ARRAY_SUPPORT = XM();
  !_.TYPED_ARRAY_SUPPORT &&
    typeof console < "u" &&
    typeof console.error == "function" &&
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  function XM() {
    try {
      let n = new Uint8Array(1),
        e = {
          foo: function () {
            return 42;
          },
        };
      return (
        Object.setPrototypeOf(e, Uint8Array.prototype),
        Object.setPrototypeOf(n, e),
        n.foo() === 42
      );
    } catch {
      return !1;
    }
  }
  Object.defineProperty(_.prototype, "parent", {
    enumerable: !0,
    get: function () {
      if (_.isBuffer(this)) return this.buffer;
    },
  });
  Object.defineProperty(_.prototype, "offset", {
    enumerable: !0,
    get: function () {
      if (_.isBuffer(this)) return this.byteOffset;
    },
  });
  function Mi(n) {
    if (n > np)
      throw new RangeError(
        'The value "' + n + '" is invalid for option "size"'
      );
    let e = new Uint8Array(n);
    return Object.setPrototypeOf(e, _.prototype), e;
  }
  function _(n, e, t) {
    if (typeof n == "number") {
      if (typeof e == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Bw(n);
    }
    return NC(n, e, t);
  }
  _.poolSize = 8192;
  function NC(n, e, t) {
    if (typeof n == "string") return t3(n, e);
    if (ArrayBuffer.isView(n)) return n3(n);
    if (n == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof n
      );
    if (
      ni(n, ArrayBuffer) ||
      (n && ni(n.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < "u" &&
        (ni(n, SharedArrayBuffer) || (n && ni(n.buffer, SharedArrayBuffer))))
    )
      return Tw(n, e, t);
    if (typeof n == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    let r = n.valueOf && n.valueOf();
    if (r != null && r !== n) return _.from(r, e, t);
    let i = r3(n);
    if (i) return i;
    if (
      typeof Symbol < "u" &&
      Symbol.toPrimitive != null &&
      typeof n[Symbol.toPrimitive] == "function"
    )
      return _.from(n[Symbol.toPrimitive]("string"), e, t);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof n
    );
  }
  _.from = function (n, e, t) {
    return NC(n, e, t);
  };
  Object.setPrototypeOf(_.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(_, Uint8Array);
  function FC(n) {
    if (typeof n != "number")
      throw new TypeError('"size" argument must be of type number');
    if (n < 0)
      throw new RangeError(
        'The value "' + n + '" is invalid for option "size"'
      );
  }
  function e3(n, e, t) {
    return (
      FC(n),
      n <= 0
        ? Mi(n)
        : e !== void 0
        ? typeof t == "string"
          ? Mi(n).fill(e, t)
          : Mi(n).fill(e)
        : Mi(n)
    );
  }
  _.alloc = function (n, e, t) {
    return e3(n, e, t);
  };
  function Bw(n) {
    return FC(n), Mi(n < 0 ? 0 : Dw(n) | 0);
  }
  _.allocUnsafe = function (n) {
    return Bw(n);
  };
  _.allocUnsafeSlow = function (n) {
    return Bw(n);
  };
  function t3(n, e) {
    if (((typeof e != "string" || e === "") && (e = "utf8"), !_.isEncoding(e)))
      throw new TypeError("Unknown encoding: " + e);
    let t = MC(n, e) | 0,
      r = Mi(t),
      i = r.write(n, e);
    return i !== t && (r = r.slice(0, i)), r;
  }
  function kw(n) {
    let e = n.length < 0 ? 0 : Dw(n.length) | 0,
      t = Mi(e);
    for (let r = 0; r < e; r += 1) t[r] = n[r] & 255;
    return t;
  }
  function n3(n) {
    if (ni(n, Uint8Array)) {
      let e = new Uint8Array(n);
      return Tw(e.buffer, e.byteOffset, e.byteLength);
    }
    return kw(n);
  }
  function Tw(n, e, t) {
    if (e < 0 || n.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (n.byteLength < e + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let r;
    return (
      e === void 0 && t === void 0
        ? (r = new Uint8Array(n))
        : t === void 0
        ? (r = new Uint8Array(n, e))
        : (r = new Uint8Array(n, e, t)),
      Object.setPrototypeOf(r, _.prototype),
      r
    );
  }
  function r3(n) {
    if (_.isBuffer(n)) {
      let e = Dw(n.length) | 0,
        t = Mi(e);
      return t.length === 0 || n.copy(t, 0, 0, e), t;
    }
    if (n.length !== void 0)
      return typeof n.length != "number" || Pw(n.length) ? Mi(0) : kw(n);
    if (n.type === "Buffer" && Array.isArray(n.data)) return kw(n.data);
  }
  function Dw(n) {
    if (n >= np)
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          np.toString(16) +
          " bytes"
      );
    return n | 0;
  }
  function i3(n) {
    return +n != n && (n = 0), _.alloc(+n);
  }
  _.isBuffer = function (e) {
    return e != null && e._isBuffer === !0 && e !== _.prototype;
  };
  _.compare = function (e, t) {
    if (
      (ni(e, Uint8Array) && (e = _.from(e, e.offset, e.byteLength)),
      ni(t, Uint8Array) && (t = _.from(t, t.offset, t.byteLength)),
      !_.isBuffer(e) || !_.isBuffer(t))
    )
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (e === t) return 0;
    let r = e.length,
      i = t.length;
    for (let s = 0, o = Math.min(r, i); s < o; ++s)
      if (e[s] !== t[s]) {
        (r = e[s]), (i = t[s]);
        break;
      }
    return r < i ? -1 : i < r ? 1 : 0;
  };
  _.isEncoding = function (e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  };
  _.concat = function (e, t) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0) return _.alloc(0);
    let r;
    if (t === void 0) for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
    let i = _.allocUnsafe(t),
      s = 0;
    for (r = 0; r < e.length; ++r) {
      let o = e[r];
      if (ni(o, Uint8Array))
        s + o.length > i.length
          ? (_.isBuffer(o) || (o = _.from(o)), o.copy(i, s))
          : Uint8Array.prototype.set.call(i, o, s);
      else if (_.isBuffer(o)) o.copy(i, s);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      s += o.length;
    }
    return i;
  };
  function MC(n, e) {
    if (_.isBuffer(n)) return n.length;
    if (ArrayBuffer.isView(n) || ni(n, ArrayBuffer)) return n.byteLength;
    if (typeof n != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof n
      );
    let t = n.length,
      r = arguments.length > 2 && arguments[2] === !0;
    if (!r && t === 0) return 0;
    let i = !1;
    for (;;)
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return Rw(n).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return KC(n).length;
        default:
          if (i) return r ? -1 : Rw(n).length;
          (e = ("" + e).toLowerCase()), (i = !0);
      }
  }
  _.byteLength = MC;
  function s3(n, e, t) {
    let r = !1;
    if (
      ((e === void 0 || e < 0) && (e = 0),
      e > this.length ||
        ((t === void 0 || t > this.length) && (t = this.length), t <= 0) ||
        ((t >>>= 0), (e >>>= 0), t <= e))
    )
      return "";
    for (n || (n = "utf8"); ; )
      switch (n) {
        case "hex":
          return g3(this, e, t);
        case "utf8":
        case "utf-8":
          return zC(this, e, t);
        case "ascii":
          return d3(this, e, t);
        case "latin1":
        case "binary":
          return p3(this, e, t);
        case "base64":
          return h3(this, e, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return m3(this, e, t);
        default:
          if (r) throw new TypeError("Unknown encoding: " + n);
          (n = (n + "").toLowerCase()), (r = !0);
      }
  }
  _.prototype._isBuffer = !0;
  function Ho(n, e, t) {
    let r = n[e];
    (n[e] = n[t]), (n[t] = r);
  }
  _.prototype.swap16 = function () {
    let e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < e; t += 2) Ho(this, t, t + 1);
    return this;
  };
  _.prototype.swap32 = function () {
    let e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < e; t += 4) Ho(this, t, t + 3), Ho(this, t + 1, t + 2);
    return this;
  };
  _.prototype.swap64 = function () {
    let e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < e; t += 8)
      Ho(this, t, t + 7),
        Ho(this, t + 1, t + 6),
        Ho(this, t + 2, t + 5),
        Ho(this, t + 3, t + 4);
    return this;
  };
  _.prototype.toString = function () {
    let e = this.length;
    return e === 0
      ? ""
      : arguments.length === 0
      ? zC(this, 0, e)
      : s3.apply(this, arguments);
  };
  _.prototype.toLocaleString = _.prototype.toString;
  _.prototype.equals = function (e) {
    if (!_.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
    return this === e ? !0 : _.compare(this, e) === 0;
  };
  _.prototype.inspect = function () {
    let e = "",
      t = Fc.INSPECT_MAX_BYTES;
    return (
      (e = this.toString("hex", 0, t)
        .replace(/(.{2})/g, "$1 ")
        .trim()),
      this.length > t && (e += " ... "),
      "<Buffer " + e + ">"
    );
  };
  _C && (_.prototype[_C] = _.prototype.inspect);
  _.prototype.compare = function (e, t, r, i, s) {
    if (
      (ni(e, Uint8Array) && (e = _.from(e, e.offset, e.byteLength)),
      !_.isBuffer(e))
    )
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
          typeof e
      );
    if (
      (t === void 0 && (t = 0),
      r === void 0 && (r = e ? e.length : 0),
      i === void 0 && (i = 0),
      s === void 0 && (s = this.length),
      t < 0 || r > e.length || i < 0 || s > this.length)
    )
      throw new RangeError("out of range index");
    if (i >= s && t >= r) return 0;
    if (i >= s) return -1;
    if (t >= r) return 1;
    if (((t >>>= 0), (r >>>= 0), (i >>>= 0), (s >>>= 0), this === e)) return 0;
    let o = s - i,
      a = r - t,
      c = Math.min(o, a),
      u = this.slice(i, s),
      l = e.slice(t, r);
    for (let h = 0; h < c; ++h)
      if (u[h] !== l[h]) {
        (o = u[h]), (a = l[h]);
        break;
      }
    return o < a ? -1 : a < o ? 1 : 0;
  };
  function UC(n, e, t, r, i) {
    if (n.length === 0) return -1;
    if (
      (typeof t == "string"
        ? ((r = t), (t = 0))
        : t > 2147483647
        ? (t = 2147483647)
        : t < -2147483648 && (t = -2147483648),
      (t = +t),
      Pw(t) && (t = i ? 0 : n.length - 1),
      t < 0 && (t = n.length + t),
      t >= n.length)
    ) {
      if (i) return -1;
      t = n.length - 1;
    } else if (t < 0)
      if (i) t = 0;
      else return -1;
    if ((typeof e == "string" && (e = _.from(e, r)), _.isBuffer(e)))
      return e.length === 0 ? -1 : PC(n, e, t, r, i);
    if (typeof e == "number")
      return (
        (e = e & 255),
        typeof Uint8Array.prototype.indexOf == "function"
          ? i
            ? Uint8Array.prototype.indexOf.call(n, e, t)
            : Uint8Array.prototype.lastIndexOf.call(n, e, t)
          : PC(n, [e], t, r, i)
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  function PC(n, e, t, r, i) {
    let s = 1,
      o = n.length,
      a = e.length;
    if (
      r !== void 0 &&
      ((r = String(r).toLowerCase()),
      r === "ucs2" || r === "ucs-2" || r === "utf16le" || r === "utf-16le")
    ) {
      if (n.length < 2 || e.length < 2) return -1;
      (s = 2), (o /= 2), (a /= 2), (t /= 2);
    }
    function c(l, h) {
      return s === 1 ? l[h] : l.readUInt16BE(h * s);
    }
    let u;
    if (i) {
      let l = -1;
      for (u = t; u < o; u++)
        if (c(n, u) === c(e, l === -1 ? 0 : u - l)) {
          if ((l === -1 && (l = u), u - l + 1 === a)) return l * s;
        } else l !== -1 && (u -= u - l), (l = -1);
    } else
      for (t + a > o && (t = o - a), u = t; u >= 0; u--) {
        let l = !0;
        for (let h = 0; h < a; h++)
          if (c(n, u + h) !== c(e, h)) {
            l = !1;
            break;
          }
        if (l) return u;
      }
    return -1;
  }
  _.prototype.includes = function (e, t, r) {
    return this.indexOf(e, t, r) !== -1;
  };
  _.prototype.indexOf = function (e, t, r) {
    return UC(this, e, t, r, !0);
  };
  _.prototype.lastIndexOf = function (e, t, r) {
    return UC(this, e, t, r, !1);
  };
  function o3(n, e, t, r) {
    t = Number(t) || 0;
    let i = n.length - t;
    r ? ((r = Number(r)), r > i && (r = i)) : (r = i);
    let s = e.length;
    r > s / 2 && (r = s / 2);
    let o;
    for (o = 0; o < r; ++o) {
      let a = parseInt(e.substr(o * 2, 2), 16);
      if (Pw(a)) return o;
      n[t + o] = a;
    }
    return o;
  }
  function a3(n, e, t, r) {
    return rp(Rw(e, n.length - t), n, t, r);
  }
  function c3(n, e, t, r) {
    return rp(A3(e), n, t, r);
  }
  function u3(n, e, t, r) {
    return rp(KC(e), n, t, r);
  }
  function l3(n, e, t, r) {
    return rp(E3(e, n.length - t), n, t, r);
  }
  _.prototype.write = function (e, t, r, i) {
    if (t === void 0) (i = "utf8"), (r = this.length), (t = 0);
    else if (r === void 0 && typeof t == "string")
      (i = t), (r = this.length), (t = 0);
    else if (isFinite(t))
      (t = t >>> 0),
        isFinite(r)
          ? ((r = r >>> 0), i === void 0 && (i = "utf8"))
          : ((i = r), (r = void 0));
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    let s = this.length - t;
    if (
      ((r === void 0 || r > s) && (r = s),
      (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds");
    i || (i = "utf8");
    let o = !1;
    for (;;)
      switch (i) {
        case "hex":
          return o3(this, e, t, r);
        case "utf8":
        case "utf-8":
          return a3(this, e, t, r);
        case "ascii":
        case "latin1":
        case "binary":
          return c3(this, e, t, r);
        case "base64":
          return u3(this, e, t, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return l3(this, e, t, r);
        default:
          if (o) throw new TypeError("Unknown encoding: " + i);
          (i = ("" + i).toLowerCase()), (o = !0);
      }
  };
  _.prototype.toJSON = function () {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0),
    };
  };
  function h3(n, e, t) {
    return e === 0 && t === n.length
      ? Cw.fromByteArray(n)
      : Cw.fromByteArray(n.slice(e, t));
  }
  function zC(n, e, t) {
    t = Math.min(n.length, t);
    let r = [],
      i = e;
    for (; i < t; ) {
      let s = n[i],
        o = null,
        a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (i + a <= t) {
        let c, u, l, h;
        switch (a) {
          case 1:
            s < 128 && (o = s);
            break;
          case 2:
            (c = n[i + 1]),
              (c & 192) === 128 &&
                ((h = ((s & 31) << 6) | (c & 63)), h > 127 && (o = h));
            break;
          case 3:
            (c = n[i + 1]),
              (u = n[i + 2]),
              (c & 192) === 128 &&
                (u & 192) === 128 &&
                ((h = ((s & 15) << 12) | ((c & 63) << 6) | (u & 63)),
                h > 2047 && (h < 55296 || h > 57343) && (o = h));
            break;
          case 4:
            (c = n[i + 1]),
              (u = n[i + 2]),
              (l = n[i + 3]),
              (c & 192) === 128 &&
                (u & 192) === 128 &&
                (l & 192) === 128 &&
                ((h =
                  ((s & 15) << 18) |
                  ((c & 63) << 12) |
                  ((u & 63) << 6) |
                  (l & 63)),
                h > 65535 && h < 1114112 && (o = h));
        }
      }
      o === null
        ? ((o = 65533), (a = 1))
        : o > 65535 &&
          ((o -= 65536),
          r.push(((o >>> 10) & 1023) | 55296),
          (o = 56320 | (o & 1023))),
        r.push(o),
        (i += a);
    }
    return f3(r);
  }
  var LC = 4096;
  function f3(n) {
    let e = n.length;
    if (e <= LC) return String.fromCharCode.apply(String, n);
    let t = "",
      r = 0;
    for (; r < e; )
      t += String.fromCharCode.apply(String, n.slice(r, (r += LC)));
    return t;
  }
  function d3(n, e, t) {
    let r = "";
    t = Math.min(n.length, t);
    for (let i = e; i < t; ++i) r += String.fromCharCode(n[i] & 127);
    return r;
  }
  function p3(n, e, t) {
    let r = "";
    t = Math.min(n.length, t);
    for (let i = e; i < t; ++i) r += String.fromCharCode(n[i]);
    return r;
  }
  function g3(n, e, t) {
    let r = n.length;
    (!e || e < 0) && (e = 0), (!t || t < 0 || t > r) && (t = r);
    let i = "";
    for (let s = e; s < t; ++s) i += x3[n[s]];
    return i;
  }
  function m3(n, e, t) {
    let r = n.slice(e, t),
      i = "";
    for (let s = 0; s < r.length - 1; s += 2)
      i += String.fromCharCode(r[s] + r[s + 1] * 256);
    return i;
  }
  _.prototype.slice = function (e, t) {
    let r = this.length;
    (e = ~~e),
      (t = t === void 0 ? r : ~~t),
      e < 0 ? ((e += r), e < 0 && (e = 0)) : e > r && (e = r),
      t < 0 ? ((t += r), t < 0 && (t = 0)) : t > r && (t = r),
      t < e && (t = e);
    let i = this.subarray(e, t);
    return Object.setPrototypeOf(i, _.prototype), i;
  };
  function Qt(n, e, t) {
    if (n % 1 !== 0 || n < 0) throw new RangeError("offset is not uint");
    if (n + e > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  _.prototype.readUintLE = _.prototype.readUIntLE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Qt(e, t, this.length);
    let i = this[e],
      s = 1,
      o = 0;
    for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
    return i;
  };
  _.prototype.readUintBE = _.prototype.readUIntBE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Qt(e, t, this.length);
    let i = this[e + --t],
      s = 1;
    for (; t > 0 && (s *= 256); ) i += this[e + --t] * s;
    return i;
  };
  _.prototype.readUint8 = _.prototype.readUInt8 = function (e, t) {
    return (e = e >>> 0), t || Qt(e, 1, this.length), this[e];
  };
  _.prototype.readUint16LE = _.prototype.readUInt16LE = function (e, t) {
    return (
      (e = e >>> 0), t || Qt(e, 2, this.length), this[e] | (this[e + 1] << 8)
    );
  };
  _.prototype.readUint16BE = _.prototype.readUInt16BE = function (e, t) {
    return (
      (e = e >>> 0), t || Qt(e, 2, this.length), (this[e] << 8) | this[e + 1]
    );
  };
  _.prototype.readUint32LE = _.prototype.readUInt32LE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Qt(e, 4, this.length),
      (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
        this[e + 3] * 16777216
    );
  };
  _.prototype.readUint32BE = _.prototype.readUInt32BE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Qt(e, 4, this.length),
      this[e] * 16777216 +
        ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
    );
  };
  _.prototype.readBigUInt64LE = Ls(function (e) {
    (e = e >>> 0), Nc(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && Nl(e, this.length - 8);
    let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24,
      s = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + r * 2 ** 24;
    return BigInt(i) + (BigInt(s) << BigInt(32));
  });
  _.prototype.readBigUInt64BE = Ls(function (e) {
    (e = e >>> 0), Nc(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && Nl(e, this.length - 8);
    let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e],
      s = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r;
    return (BigInt(i) << BigInt(32)) + BigInt(s);
  });
  _.prototype.readIntLE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Qt(e, t, this.length);
    let i = this[e],
      s = 1,
      o = 0;
    for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
    return (s *= 128), i >= s && (i -= Math.pow(2, 8 * t)), i;
  };
  _.prototype.readIntBE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Qt(e, t, this.length);
    let i = t,
      s = 1,
      o = this[e + --i];
    for (; i > 0 && (s *= 256); ) o += this[e + --i] * s;
    return (s *= 128), o >= s && (o -= Math.pow(2, 8 * t)), o;
  };
  _.prototype.readInt8 = function (e, t) {
    return (
      (e = e >>> 0),
      t || Qt(e, 1, this.length),
      this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
    );
  };
  _.prototype.readInt16LE = function (e, t) {
    (e = e >>> 0), t || Qt(e, 2, this.length);
    let r = this[e] | (this[e + 1] << 8);
    return r & 32768 ? r | 4294901760 : r;
  };
  _.prototype.readInt16BE = function (e, t) {
    (e = e >>> 0), t || Qt(e, 2, this.length);
    let r = this[e + 1] | (this[e] << 8);
    return r & 32768 ? r | 4294901760 : r;
  };
  _.prototype.readInt32LE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Qt(e, 4, this.length),
      this[e] | (this[e + 1] << 8) | (this[e + 2] << 16) | (this[e + 3] << 24)
    );
  };
  _.prototype.readInt32BE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Qt(e, 4, this.length),
      (this[e] << 24) | (this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3]
    );
  };
  _.prototype.readBigInt64LE = Ls(function (e) {
    (e = e >>> 0), Nc(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && Nl(e, this.length - 8);
    let i =
      this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (r << 24);
    return (
      (BigInt(i) << BigInt(32)) +
      BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
    );
  });
  _.prototype.readBigInt64BE = Ls(function (e) {
    (e = e >>> 0), Nc(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && Nl(e, this.length - 8);
    let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (
      (BigInt(i) << BigInt(32)) +
      BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r)
    );
  });
  _.prototype.readFloatLE = function (e, t) {
    return (
      (e = e >>> 0), t || Qt(e, 4, this.length), Oc.read(this, e, !0, 23, 4)
    );
  };
  _.prototype.readFloatBE = function (e, t) {
    return (
      (e = e >>> 0), t || Qt(e, 4, this.length), Oc.read(this, e, !1, 23, 4)
    );
  };
  _.prototype.readDoubleLE = function (e, t) {
    return (
      (e = e >>> 0), t || Qt(e, 8, this.length), Oc.read(this, e, !0, 52, 8)
    );
  };
  _.prototype.readDoubleBE = function (e, t) {
    return (
      (e = e >>> 0), t || Qt(e, 8, this.length), Oc.read(this, e, !1, 52, 8)
    );
  };
  function zn(n, e, t, r, i, s) {
    if (!_.isBuffer(n))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > i || e < s)
      throw new RangeError('"value" argument is out of bounds');
    if (t + r > n.length) throw new RangeError("Index out of range");
  }
  _.prototype.writeUintLE = _.prototype.writeUIntLE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), (r = r >>> 0), !i)) {
      let a = Math.pow(2, 8 * r) - 1;
      zn(this, e, t, r, a, 0);
    }
    let s = 1,
      o = 0;
    for (this[t] = e & 255; ++o < r && (s *= 256); )
      this[t + o] = (e / s) & 255;
    return t + r;
  };
  _.prototype.writeUintBE = _.prototype.writeUIntBE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), (r = r >>> 0), !i)) {
      let a = Math.pow(2, 8 * r) - 1;
      zn(this, e, t, r, a, 0);
    }
    let s = r - 1,
      o = 1;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
      this[t + s] = (e / o) & 255;
    return t + r;
  };
  _.prototype.writeUint8 = _.prototype.writeUInt8 = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 1, 255, 0),
      (this[t] = e & 255),
      t + 1
    );
  };
  _.prototype.writeUint16LE = _.prototype.writeUInt16LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 2, 65535, 0),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      t + 2
    );
  };
  _.prototype.writeUint16BE = _.prototype.writeUInt16BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 2, 65535, 0),
      (this[t] = e >>> 8),
      (this[t + 1] = e & 255),
      t + 2
    );
  };
  _.prototype.writeUint32LE = _.prototype.writeUInt32LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 4, 4294967295, 0),
      (this[t + 3] = e >>> 24),
      (this[t + 2] = e >>> 16),
      (this[t + 1] = e >>> 8),
      (this[t] = e & 255),
      t + 4
    );
  };
  _.prototype.writeUint32BE = _.prototype.writeUInt32BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 4, 4294967295, 0),
      (this[t] = e >>> 24),
      (this[t + 1] = e >>> 16),
      (this[t + 2] = e >>> 8),
      (this[t + 3] = e & 255),
      t + 4
    );
  };
  function jC(n, e, t, r, i) {
    GC(e, r, i, n, t, 7);
    let s = Number(e & BigInt(4294967295));
    (n[t++] = s),
      (s = s >> 8),
      (n[t++] = s),
      (s = s >> 8),
      (n[t++] = s),
      (s = s >> 8),
      (n[t++] = s);
    let o = Number((e >> BigInt(32)) & BigInt(4294967295));
    return (
      (n[t++] = o),
      (o = o >> 8),
      (n[t++] = o),
      (o = o >> 8),
      (n[t++] = o),
      (o = o >> 8),
      (n[t++] = o),
      t
    );
  }
  function WC(n, e, t, r, i) {
    GC(e, r, i, n, t, 7);
    let s = Number(e & BigInt(4294967295));
    (n[t + 7] = s),
      (s = s >> 8),
      (n[t + 6] = s),
      (s = s >> 8),
      (n[t + 5] = s),
      (s = s >> 8),
      (n[t + 4] = s);
    let o = Number((e >> BigInt(32)) & BigInt(4294967295));
    return (
      (n[t + 3] = o),
      (o = o >> 8),
      (n[t + 2] = o),
      (o = o >> 8),
      (n[t + 1] = o),
      (o = o >> 8),
      (n[t] = o),
      t + 8
    );
  }
  _.prototype.writeBigUInt64LE = Ls(function (e, t = 0) {
    return jC(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  _.prototype.writeBigUInt64BE = Ls(function (e, t = 0) {
    return WC(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  _.prototype.writeIntLE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), !i)) {
      let c = Math.pow(2, 8 * r - 1);
      zn(this, e, t, r, c - 1, -c);
    }
    let s = 0,
      o = 1,
      a = 0;
    for (this[t] = e & 255; ++s < r && (o *= 256); )
      e < 0 && a === 0 && this[t + s - 1] !== 0 && (a = 1),
        (this[t + s] = (((e / o) >> 0) - a) & 255);
    return t + r;
  };
  _.prototype.writeIntBE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), !i)) {
      let c = Math.pow(2, 8 * r - 1);
      zn(this, e, t, r, c - 1, -c);
    }
    let s = r - 1,
      o = 1,
      a = 0;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
      e < 0 && a === 0 && this[t + s + 1] !== 0 && (a = 1),
        (this[t + s] = (((e / o) >> 0) - a) & 255);
    return t + r;
  };
  _.prototype.writeInt8 = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 1, 127, -128),
      e < 0 && (e = 255 + e + 1),
      (this[t] = e & 255),
      t + 1
    );
  };
  _.prototype.writeInt16LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 2, 32767, -32768),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      t + 2
    );
  };
  _.prototype.writeInt16BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 2, 32767, -32768),
      (this[t] = e >>> 8),
      (this[t + 1] = e & 255),
      t + 2
    );
  };
  _.prototype.writeInt32LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 4, 2147483647, -2147483648),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      (this[t + 2] = e >>> 16),
      (this[t + 3] = e >>> 24),
      t + 4
    );
  };
  _.prototype.writeInt32BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || zn(this, e, t, 4, 2147483647, -2147483648),
      e < 0 && (e = 4294967295 + e + 1),
      (this[t] = e >>> 24),
      (this[t + 1] = e >>> 16),
      (this[t + 2] = e >>> 8),
      (this[t + 3] = e & 255),
      t + 4
    );
  };
  _.prototype.writeBigInt64LE = Ls(function (e, t = 0) {
    return jC(
      this,
      e,
      t,
      -BigInt("0x8000000000000000"),
      BigInt("0x7fffffffffffffff")
    );
  });
  _.prototype.writeBigInt64BE = Ls(function (e, t = 0) {
    return WC(
      this,
      e,
      t,
      -BigInt("0x8000000000000000"),
      BigInt("0x7fffffffffffffff")
    );
  });
  function HC(n, e, t, r, i, s) {
    if (t + r > n.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  function VC(n, e, t, r, i) {
    return (
      (e = +e),
      (t = t >>> 0),
      i || HC(n, e, t, 4, 34028234663852886e22, -34028234663852886e22),
      Oc.write(n, e, t, r, 23, 4),
      t + 4
    );
  }
  _.prototype.writeFloatLE = function (e, t, r) {
    return VC(this, e, t, !0, r);
  };
  _.prototype.writeFloatBE = function (e, t, r) {
    return VC(this, e, t, !1, r);
  };
  function $C(n, e, t, r, i) {
    return (
      (e = +e),
      (t = t >>> 0),
      i || HC(n, e, t, 8, 17976931348623157e292, -17976931348623157e292),
      Oc.write(n, e, t, r, 52, 8),
      t + 8
    );
  }
  _.prototype.writeDoubleLE = function (e, t, r) {
    return $C(this, e, t, !0, r);
  };
  _.prototype.writeDoubleBE = function (e, t, r) {
    return $C(this, e, t, !1, r);
  };
  _.prototype.copy = function (e, t, r, i) {
    if (!_.isBuffer(e)) throw new TypeError("argument should be a Buffer");
    if (
      (r || (r = 0),
      !i && i !== 0 && (i = this.length),
      t >= e.length && (t = e.length),
      t || (t = 0),
      i > 0 && i < r && (i = r),
      i === r || e.length === 0 || this.length === 0)
    )
      return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
    if (i < 0) throw new RangeError("sourceEnd out of bounds");
    i > this.length && (i = this.length),
      e.length - t < i - r && (i = e.length - t + r);
    let s = i - r;
    return (
      this === e && typeof Uint8Array.prototype.copyWithin == "function"
        ? this.copyWithin(t, r, i)
        : Uint8Array.prototype.set.call(e, this.subarray(r, i), t),
      s
    );
  };
  _.prototype.fill = function (e, t, r, i) {
    if (typeof e == "string") {
      if (
        (typeof t == "string"
          ? ((i = t), (t = 0), (r = this.length))
          : typeof r == "string" && ((i = r), (r = this.length)),
        i !== void 0 && typeof i != "string")
      )
        throw new TypeError("encoding must be a string");
      if (typeof i == "string" && !_.isEncoding(i))
        throw new TypeError("Unknown encoding: " + i);
      if (e.length === 1) {
        let o = e.charCodeAt(0);
        ((i === "utf8" && o < 128) || i === "latin1") && (e = o);
      }
    } else
      typeof e == "number"
        ? (e = e & 255)
        : typeof e == "boolean" && (e = Number(e));
    if (t < 0 || this.length < t || this.length < r)
      throw new RangeError("Out of range index");
    if (r <= t) return this;
    (t = t >>> 0), (r = r === void 0 ? this.length : r >>> 0), e || (e = 0);
    let s;
    if (typeof e == "number") for (s = t; s < r; ++s) this[s] = e;
    else {
      let o = _.isBuffer(e) ? e : _.from(e, i),
        a = o.length;
      if (a === 0)
        throw new TypeError(
          'The value "' + e + '" is invalid for argument "value"'
        );
      for (s = 0; s < r - t; ++s) this[s + t] = o[s % a];
    }
    return this;
  };
  var Lc = {};
  function _w(n, e, t) {
    Lc[n] = class extends t {
      constructor() {
        super(),
          Object.defineProperty(this, "message", {
            value: e.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${n}]`),
          this.stack,
          delete this.name;
      }
      get code() {
        return n;
      }
      set code(i) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: i,
          writable: !0,
        });
      }
      toString() {
        return `${this.name} [${n}]: ${this.message}`;
      }
    };
  }
  _w(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function (n) {
      return n
        ? `${n} is outside of buffer bounds`
        : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  _w(
    "ERR_INVALID_ARG_TYPE",
    function (n, e) {
      return `The "${n}" argument must be of type number. Received type ${typeof e}`;
    },
    TypeError
  );
  _w(
    "ERR_OUT_OF_RANGE",
    function (n, e, t) {
      let r = `The value of "${n}" is out of range.`,
        i = t;
      return (
        Number.isInteger(t) && Math.abs(t) > 2 ** 32
          ? (i = OC(String(t)))
          : typeof t == "bigint" &&
            ((i = String(t)),
            (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) &&
              (i = OC(i)),
            (i += "n")),
        (r += ` It must be ${e}. Received ${i}`),
        r
      );
    },
    RangeError
  );
  function OC(n) {
    let e = "",
      t = n.length,
      r = n[0] === "-" ? 1 : 0;
    for (; t >= r + 4; t -= 3) e = `_${n.slice(t - 3, t)}${e}`;
    return `${n.slice(0, t)}${e}`;
  }
  function y3(n, e, t) {
    Nc(e, "offset"),
      (n[e] === void 0 || n[e + t] === void 0) && Nl(e, n.length - (t + 1));
  }
  function GC(n, e, t, r, i, s) {
    if (n > t || n < e) {
      let o = typeof e == "bigint" ? "n" : "",
        a;
      throw (
        (s > 3
          ? e === 0 || e === BigInt(0)
            ? (a = `>= 0${o} and < 2${o} ** ${(s + 1) * 8}${o}`)
            : (a = `>= -(2${o} ** ${(s + 1) * 8 - 1}${o}) and < 2 ** ${
                (s + 1) * 8 - 1
              }${o}`)
          : (a = `>= ${e}${o} and <= ${t}${o}`),
        new Lc.ERR_OUT_OF_RANGE("value", a, n))
      );
    }
    y3(r, i, s);
  }
  function Nc(n, e) {
    if (typeof n != "number") throw new Lc.ERR_INVALID_ARG_TYPE(e, "number", n);
  }
  function Nl(n, e, t) {
    throw Math.floor(n) !== n
      ? (Nc(n, t), new Lc.ERR_OUT_OF_RANGE(t || "offset", "an integer", n))
      : e < 0
      ? new Lc.ERR_BUFFER_OUT_OF_BOUNDS()
      : new Lc.ERR_OUT_OF_RANGE(
          t || "offset",
          `>= ${t ? 1 : 0} and <= ${e}`,
          n
        );
  }
  var w3 = /[^+/0-9A-Za-z-_]/g;
  function b3(n) {
    if (((n = n.split("=")[0]), (n = n.trim().replace(w3, "")), n.length < 2))
      return "";
    for (; n.length % 4 !== 0; ) n = n + "=";
    return n;
  }
  function Rw(n, e) {
    e = e || 1 / 0;
    let t,
      r = n.length,
      i = null,
      s = [];
    for (let o = 0; o < r; ++o) {
      if (((t = n.charCodeAt(o)), t > 55295 && t < 57344)) {
        if (!i) {
          if (t > 56319) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          } else if (o + 1 === r) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          i = t;
          continue;
        }
        if (t < 56320) {
          (e -= 3) > -1 && s.push(239, 191, 189), (i = t);
          continue;
        }
        t = (((i - 55296) << 10) | (t - 56320)) + 65536;
      } else i && (e -= 3) > -1 && s.push(239, 191, 189);
      if (((i = null), t < 128)) {
        if ((e -= 1) < 0) break;
        s.push(t);
      } else if (t < 2048) {
        if ((e -= 2) < 0) break;
        s.push((t >> 6) | 192, (t & 63) | 128);
      } else if (t < 65536) {
        if ((e -= 3) < 0) break;
        s.push((t >> 12) | 224, ((t >> 6) & 63) | 128, (t & 63) | 128);
      } else if (t < 1114112) {
        if ((e -= 4) < 0) break;
        s.push(
          (t >> 18) | 240,
          ((t >> 12) & 63) | 128,
          ((t >> 6) & 63) | 128,
          (t & 63) | 128
        );
      } else throw new Error("Invalid code point");
    }
    return s;
  }
  function A3(n) {
    let e = [];
    for (let t = 0; t < n.length; ++t) e.push(n.charCodeAt(t) & 255);
    return e;
  }
  function E3(n, e) {
    let t,
      r,
      i,
      s = [];
    for (let o = 0; o < n.length && !((e -= 2) < 0); ++o)
      (t = n.charCodeAt(o)), (r = t >> 8), (i = t % 256), s.push(i), s.push(r);
    return s;
  }
  function KC(n) {
    return Cw.toByteArray(b3(n));
  }
  function rp(n, e, t, r) {
    let i;
    for (i = 0; i < r && !(i + t >= e.length || i >= n.length); ++i)
      e[i + t] = n[i];
    return i;
  }
  function ni(n, e) {
    return (
      n instanceof e ||
      (n != null &&
        n.constructor != null &&
        n.constructor.name != null &&
        n.constructor.name === e.name)
    );
  }
  function Pw(n) {
    return n !== n;
  }
  var x3 = (function () {
    let n = "0123456789abcdef",
      e = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let r = t * 16;
      for (let i = 0; i < 16; ++i) e[r + i] = n[t] + n[i];
    }
    return e;
  })();
  function Ls(n) {
    return typeof BigInt > "u" ? S3 : n;
  }
  function S3() {
    throw new Error("BigInt not supported");
  }
});
var Fw = ve((k) => {
  "use strict";
  p();
  Object.defineProperty(k, "__esModule", { value: !0 });
  k.s16 =
    k.s8 =
    k.nu64be =
    k.u48be =
    k.u40be =
    k.u32be =
    k.u24be =
    k.u16be =
    k.nu64 =
    k.u48 =
    k.u40 =
    k.u32 =
    k.u24 =
    k.u16 =
    k.u8 =
    k.offset =
    k.greedy =
    k.Constant =
    k.UTF8 =
    k.CString =
    k.Blob =
    k.Boolean =
    k.BitField =
    k.BitStructure =
    k.VariantLayout =
    k.Union =
    k.UnionLayoutDiscriminator =
    k.UnionDiscriminator =
    k.Structure =
    k.Sequence =
    k.DoubleBE =
    k.Double =
    k.FloatBE =
    k.Float =
    k.NearInt64BE =
    k.NearInt64 =
    k.NearUInt64BE =
    k.NearUInt64 =
    k.IntBE =
    k.Int =
    k.UIntBE =
    k.UInt =
    k.OffsetLayout =
    k.GreedyCount =
    k.ExternalLayout =
    k.bindConstructorLayout =
    k.nameWithProperty =
    k.Layout =
    k.uint8ArrayToBuffer =
    k.checkUint8Array =
      void 0;
  k.constant =
    k.utf8 =
    k.cstr =
    k.blob =
    k.unionLayoutDiscriminator =
    k.union =
    k.seq =
    k.bits =
    k.struct =
    k.f64be =
    k.f64 =
    k.f32be =
    k.f32 =
    k.ns64be =
    k.s48be =
    k.s40be =
    k.s32be =
    k.s24be =
    k.s16be =
    k.ns64 =
    k.s48 =
    k.s40 =
    k.s32 =
    k.s24 =
      void 0;
  var Ow = qC();
  function zc(n) {
    if (!(n instanceof Uint8Array))
      throw new TypeError("b must be a Uint8Array");
  }
  k.checkUint8Array = zc;
  function He(n) {
    return zc(n), Ow.Buffer.from(n.buffer, n.byteOffset, n.length);
  }
  k.uint8ArrayToBuffer = He;
  var qe = class {
    constructor(e, t) {
      if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
      (this.span = e), (this.property = t);
    }
    makeDestinationObject() {
      return {};
    }
    getSpan(e, t) {
      if (0 > this.span) throw new RangeError("indeterminate span");
      return this.span;
    }
    replicate(e) {
      let t = Object.create(this.constructor.prototype);
      return Object.assign(t, this), (t.property = e), t;
    }
    fromArray(e) {}
  };
  k.Layout = qe;
  function Nw(n, e) {
    return e.property ? n + "[" + e.property + "]" : n;
  }
  k.nameWithProperty = Nw;
  function v3(n, e) {
    if (typeof n != "function")
      throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(n, "layout_"))
      throw new Error("Class is already bound to a layout");
    if (!(e && e instanceof qe)) throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_"))
      throw new Error("layout is already bound to a constructor");
    (n.layout_ = e),
      (e.boundConstructor_ = n),
      (e.makeDestinationObject = () => new n()),
      Object.defineProperty(n.prototype, "encode", {
        value(t, r) {
          return e.encode(this, t, r);
        },
        writable: !0,
      }),
      Object.defineProperty(n, "decode", {
        value(t, r) {
          return e.decode(t, r);
        },
        writable: !0,
      });
  }
  k.bindConstructorLayout = v3;
  var yn = class extends qe {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  };
  k.ExternalLayout = yn;
  var ip = class extends yn {
    constructor(e = 1, t) {
      if (!Number.isInteger(e) || 0 >= e)
        throw new TypeError("elementSpan must be a (positive) integer");
      super(-1, t), (this.elementSpan = e);
    }
    isCount() {
      return !0;
    }
    decode(e, t = 0) {
      zc(e);
      let r = e.length - t;
      return Math.floor(r / this.elementSpan);
    }
    encode(e, t, r) {
      return 0;
    }
  };
  k.GreedyCount = ip;
  var Fl = class extends yn {
    constructor(e, t = 0, r) {
      if (!(e instanceof qe)) throw new TypeError("layout must be a Layout");
      if (!Number.isInteger(t))
        throw new TypeError("offset must be integer or undefined");
      super(e.span, r || e.property), (this.layout = e), (this.offset = t);
    }
    isCount() {
      return this.layout instanceof jn || this.layout instanceof er;
    }
    decode(e, t = 0) {
      return this.layout.decode(e, t + this.offset);
    }
    encode(e, t, r = 0) {
      return this.layout.encode(e, t, r + this.offset);
    }
  };
  k.OffsetLayout = Fl;
  var jn = class extends qe {
    constructor(e, t) {
      if ((super(e, t), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(e, t = 0) {
      return He(e).readUIntLE(t, this.span);
    }
    encode(e, t, r = 0) {
      return He(t).writeUIntLE(e, r, this.span), this.span;
    }
  };
  k.UInt = jn;
  var er = class extends qe {
    constructor(e, t) {
      if ((super(e, t), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(e, t = 0) {
      return He(e).readUIntBE(t, this.span);
    }
    encode(e, t, r = 0) {
      return He(t).writeUIntBE(e, r, this.span), this.span;
    }
  };
  k.UIntBE = er;
  var Ui = class extends qe {
    constructor(e, t) {
      if ((super(e, t), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(e, t = 0) {
      return He(e).readIntLE(t, this.span);
    }
    encode(e, t, r = 0) {
      return He(t).writeIntLE(e, r, this.span), this.span;
    }
  };
  k.Int = Ui;
  var Os = class extends qe {
    constructor(e, t) {
      if ((super(e, t), 6 < this.span))
        throw new RangeError("span must not exceed 6 bytes");
    }
    decode(e, t = 0) {
      return He(e).readIntBE(t, this.span);
    }
    encode(e, t, r = 0) {
      return He(t).writeIntBE(e, r, this.span), this.span;
    }
  };
  k.IntBE = Os;
  var Lw = Math.pow(2, 32);
  function Ep(n) {
    let e = Math.floor(n / Lw),
      t = n - e * Lw;
    return { hi32: e, lo32: t };
  }
  function xp(n, e) {
    return n * Lw + e;
  }
  var sp = class extends qe {
    constructor(e) {
      super(8, e);
    }
    decode(e, t = 0) {
      let r = He(e),
        i = r.readUInt32LE(t),
        s = r.readUInt32LE(t + 4);
      return xp(s, i);
    }
    encode(e, t, r = 0) {
      let i = Ep(e),
        s = He(t);
      return s.writeUInt32LE(i.lo32, r), s.writeUInt32LE(i.hi32, r + 4), 8;
    }
  };
  k.NearUInt64 = sp;
  var op = class extends qe {
    constructor(e) {
      super(8, e);
    }
    decode(e, t = 0) {
      let r = He(e),
        i = r.readUInt32BE(t),
        s = r.readUInt32BE(t + 4);
      return xp(i, s);
    }
    encode(e, t, r = 0) {
      let i = Ep(e),
        s = He(t);
      return s.writeUInt32BE(i.hi32, r), s.writeUInt32BE(i.lo32, r + 4), 8;
    }
  };
  k.NearUInt64BE = op;
  var ap = class extends qe {
    constructor(e) {
      super(8, e);
    }
    decode(e, t = 0) {
      let r = He(e),
        i = r.readUInt32LE(t),
        s = r.readInt32LE(t + 4);
      return xp(s, i);
    }
    encode(e, t, r = 0) {
      let i = Ep(e),
        s = He(t);
      return s.writeUInt32LE(i.lo32, r), s.writeInt32LE(i.hi32, r + 4), 8;
    }
  };
  k.NearInt64 = ap;
  var cp = class extends qe {
    constructor(e) {
      super(8, e);
    }
    decode(e, t = 0) {
      let r = He(e),
        i = r.readInt32BE(t),
        s = r.readUInt32BE(t + 4);
      return xp(i, s);
    }
    encode(e, t, r = 0) {
      let i = Ep(e),
        s = He(t);
      return s.writeInt32BE(i.hi32, r), s.writeUInt32BE(i.lo32, r + 4), 8;
    }
  };
  k.NearInt64BE = cp;
  var up = class extends qe {
    constructor(e) {
      super(4, e);
    }
    decode(e, t = 0) {
      return He(e).readFloatLE(t);
    }
    encode(e, t, r = 0) {
      return He(t).writeFloatLE(e, r), 4;
    }
  };
  k.Float = up;
  var lp = class extends qe {
    constructor(e) {
      super(4, e);
    }
    decode(e, t = 0) {
      return He(e).readFloatBE(t);
    }
    encode(e, t, r = 0) {
      return He(t).writeFloatBE(e, r), 4;
    }
  };
  k.FloatBE = lp;
  var hp = class extends qe {
    constructor(e) {
      super(8, e);
    }
    decode(e, t = 0) {
      return He(e).readDoubleLE(t);
    }
    encode(e, t, r = 0) {
      return He(t).writeDoubleLE(e, r), 8;
    }
  };
  k.Double = hp;
  var fp = class extends qe {
    constructor(e) {
      super(8, e);
    }
    decode(e, t = 0) {
      return He(e).readDoubleBE(t);
    }
    encode(e, t, r = 0) {
      return He(t).writeDoubleBE(e, r), 8;
    }
  };
  k.DoubleBE = fp;
  var dp = class extends qe {
    constructor(e, t, r) {
      if (!(e instanceof qe))
        throw new TypeError("elementLayout must be a Layout");
      if (
        !((t instanceof yn && t.isCount()) || (Number.isInteger(t) && 0 <= t))
      )
        throw new TypeError(
          "count must be non-negative integer or an unsigned integer ExternalLayout"
        );
      let i = -1;
      !(t instanceof yn) && 0 < e.span && (i = t * e.span),
        super(i, r),
        (this.elementLayout = e),
        (this.count = t);
    }
    getSpan(e, t = 0) {
      if (0 <= this.span) return this.span;
      let r = 0,
        i = this.count;
      if (
        (i instanceof yn && (i = i.decode(e, t)), 0 < this.elementLayout.span)
      )
        r = i * this.elementLayout.span;
      else {
        let s = 0;
        for (; s < i; ) (r += this.elementLayout.getSpan(e, t + r)), ++s;
      }
      return r;
    }
    decode(e, t = 0) {
      let r = [],
        i = 0,
        s = this.count;
      for (s instanceof yn && (s = s.decode(e, t)); i < s; )
        r.push(this.elementLayout.decode(e, t)),
          (t += this.elementLayout.getSpan(e, t)),
          (i += 1);
      return r;
    }
    encode(e, t, r = 0) {
      let i = this.elementLayout,
        s = e.reduce((o, a) => o + i.encode(a, t, r + o), 0);
      return this.count instanceof yn && this.count.encode(e.length, t, r), s;
    }
  };
  k.Sequence = dp;
  var pp = class extends qe {
    constructor(e, t, r) {
      if (!(Array.isArray(e) && e.reduce((s, o) => s && o instanceof qe, !0)))
        throw new TypeError("fields must be array of Layout instances");
      typeof t == "boolean" && r === void 0 && ((r = t), (t = void 0));
      for (let s of e)
        if (0 > s.span && s.property === void 0)
          throw new Error(
            "fields cannot contain unnamed variable-length layout"
          );
      let i = -1;
      try {
        i = e.reduce((s, o) => s + o.getSpan(), 0);
      } catch {}
      super(i, t), (this.fields = e), (this.decodePrefixes = !!r);
    }
    getSpan(e, t = 0) {
      if (0 <= this.span) return this.span;
      let r = 0;
      try {
        r = this.fields.reduce((i, s) => {
          let o = s.getSpan(e, t);
          return (t += o), i + o;
        }, 0);
      } catch {
        throw new RangeError("indeterminate span");
      }
      return r;
    }
    decode(e, t = 0) {
      zc(e);
      let r = this.makeDestinationObject();
      for (let i of this.fields)
        if (
          (i.property !== void 0 && (r[i.property] = i.decode(e, t)),
          (t += i.getSpan(e, t)),
          this.decodePrefixes && e.length === t)
        )
          break;
      return r;
    }
    encode(e, t, r = 0) {
      let i = r,
        s = 0,
        o = 0;
      for (let a of this.fields) {
        let c = a.span;
        if (((o = 0 < c ? c : 0), a.property !== void 0)) {
          let u = e[a.property];
          u !== void 0 &&
            ((o = a.encode(u, t, r)), 0 > c && (c = a.getSpan(t, r)));
        }
        (s = r), (r += c);
      }
      return s + o - i;
    }
    fromArray(e) {
      let t = this.makeDestinationObject();
      for (let r of this.fields)
        r.property !== void 0 && 0 < e.length && (t[r.property] = e.shift());
      return t;
    }
    layoutFor(e) {
      if (typeof e != "string") throw new TypeError("property must be string");
      for (let t of this.fields) if (t.property === e) return t;
    }
    offsetOf(e) {
      if (typeof e != "string") throw new TypeError("property must be string");
      let t = 0;
      for (let r of this.fields) {
        if (r.property === e) return t;
        0 > r.span ? (t = -1) : 0 <= t && (t += r.span);
      }
    }
  };
  k.Structure = pp;
  var Ml = class {
    constructor(e) {
      this.property = e;
    }
    decode(e, t) {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode(e, t, r) {
      throw new Error("UnionDiscriminator is abstract");
    }
  };
  k.UnionDiscriminator = Ml;
  var Uc = class extends Ml {
    constructor(e, t) {
      if (!(e instanceof yn && e.isCount()))
        throw new TypeError(
          "layout must be an unsigned integer ExternalLayout"
        );
      super(t || e.property || "variant"), (this.layout = e);
    }
    decode(e, t) {
      return this.layout.decode(e, t);
    }
    encode(e, t, r) {
      return this.layout.encode(e, t, r);
    }
  };
  k.UnionLayoutDiscriminator = Uc;
  var Ul = class extends qe {
    constructor(e, t, r) {
      let i;
      if (e instanceof jn || e instanceof er) i = new Uc(new Fl(e));
      else if (e instanceof yn && e.isCount()) i = new Uc(e);
      else if (e instanceof Ml) i = e;
      else
        throw new TypeError(
          "discr must be a UnionDiscriminator or an unsigned integer layout"
        );
      if ((t === void 0 && (t = null), !(t === null || t instanceof qe)))
        throw new TypeError("defaultLayout must be null or a Layout");
      if (t !== null) {
        if (0 > t.span)
          throw new Error("defaultLayout must have constant span");
        t.property === void 0 && (t = t.replicate("content"));
      }
      let s = -1;
      t &&
        ((s = t.span),
        0 <= s && (e instanceof jn || e instanceof er) && (s += i.layout.span)),
        super(s, r),
        (this.discriminator = i),
        (this.usesPrefixDiscriminator = e instanceof jn || e instanceof er),
        (this.defaultLayout = t),
        (this.registry = {});
      let o = this.defaultGetSourceVariant.bind(this);
      (this.getSourceVariant = function (a) {
        return o(a);
      }),
        (this.configGetSourceVariant = function (a) {
          o = a.bind(this);
        });
    }
    getSpan(e, t = 0) {
      if (0 <= this.span) return this.span;
      let r = this.getVariant(e, t);
      if (!r)
        throw new Error("unable to determine span for unrecognized variant");
      return r.getSpan(e, t);
    }
    defaultGetSourceVariant(e) {
      if (
        Object.prototype.hasOwnProperty.call(e, this.discriminator.property)
      ) {
        if (
          this.defaultLayout &&
          this.defaultLayout.property &&
          Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property)
        )
          return;
        let t = this.registry[e[this.discriminator.property]];
        if (
          t &&
          (!t.layout ||
            (t.property && Object.prototype.hasOwnProperty.call(e, t.property)))
        )
          return t;
      } else
        for (let t in this.registry) {
          let r = this.registry[t];
          if (r.property && Object.prototype.hasOwnProperty.call(e, r.property))
            return r;
        }
      throw new Error("unable to infer src variant");
    }
    decode(e, t = 0) {
      let r,
        i = this.discriminator,
        s = i.decode(e, t),
        o = this.registry[s];
      if (o === void 0) {
        let a = this.defaultLayout,
          c = 0;
        this.usesPrefixDiscriminator && (c = i.layout.span),
          (r = this.makeDestinationObject()),
          (r[i.property] = s),
          (r[a.property] = a.decode(e, t + c));
      } else r = o.decode(e, t);
      return r;
    }
    encode(e, t, r = 0) {
      let i = this.getSourceVariant(e);
      if (i === void 0) {
        let s = this.discriminator,
          o = this.defaultLayout,
          a = 0;
        return (
          this.usesPrefixDiscriminator && (a = s.layout.span),
          s.encode(e[s.property], t, r),
          a + o.encode(e[o.property], t, r + a)
        );
      }
      return i.encode(e, t, r);
    }
    addVariant(e, t, r) {
      let i = new gp(this, e, t, r);
      return (this.registry[e] = i), i;
    }
    getVariant(e, t = 0) {
      let r;
      return (
        e instanceof Uint8Array
          ? (r = this.discriminator.decode(e, t))
          : (r = e),
        this.registry[r]
      );
    }
  };
  k.Union = Ul;
  var gp = class extends qe {
    constructor(e, t, r, i) {
      if (!(e instanceof Ul)) throw new TypeError("union must be a Union");
      if (!Number.isInteger(t) || 0 > t)
        throw new TypeError("variant must be a (non-negative) integer");
      if ((typeof r == "string" && i === void 0 && ((i = r), (r = null)), r)) {
        if (!(r instanceof qe)) throw new TypeError("layout must be a Layout");
        if (
          e.defaultLayout !== null &&
          0 <= r.span &&
          r.span > e.defaultLayout.span
        )
          throw new Error("variant span exceeds span of containing union");
        if (typeof i != "string")
          throw new TypeError("variant must have a String property");
      }
      let s = e.span;
      0 > e.span &&
        ((s = r ? r.span : 0),
        0 <= s &&
          e.usesPrefixDiscriminator &&
          (s += e.discriminator.layout.span)),
        super(s, i),
        (this.union = e),
        (this.variant = t),
        (this.layout = r || null);
    }
    getSpan(e, t = 0) {
      if (0 <= this.span) return this.span;
      let r = 0;
      this.union.usesPrefixDiscriminator &&
        (r = this.union.discriminator.layout.span);
      let i = 0;
      return this.layout && (i = this.layout.getSpan(e, t + r)), r + i;
    }
    decode(e, t = 0) {
      let r = this.makeDestinationObject();
      if (this !== this.union.getVariant(e, t))
        throw new Error("variant mismatch");
      let i = 0;
      return (
        this.union.usesPrefixDiscriminator &&
          (i = this.union.discriminator.layout.span),
        this.layout
          ? (r[this.property] = this.layout.decode(e, t + i))
          : this.property
          ? (r[this.property] = !0)
          : this.union.usesPrefixDiscriminator &&
            (r[this.union.discriminator.property] = this.variant),
        r
      );
    }
    encode(e, t, r = 0) {
      let i = 0;
      if (
        (this.union.usesPrefixDiscriminator &&
          (i = this.union.discriminator.layout.span),
        this.layout && !Object.prototype.hasOwnProperty.call(e, this.property))
      )
        throw new TypeError("variant lacks property " + this.property);
      this.union.discriminator.encode(this.variant, t, r);
      let s = i;
      if (
        this.layout &&
        (this.layout.encode(e[this.property], t, r + i),
        (s += this.layout.getSpan(t, r + i)),
        0 <= this.union.span && s > this.union.span)
      )
        throw new Error("encoded variant overruns containing union");
      return s;
    }
    fromArray(e) {
      if (this.layout) return this.layout.fromArray(e);
    }
  };
  k.VariantLayout = gp;
  function Mc(n) {
    return 0 > n && (n += 4294967296), n;
  }
  var zl = class extends qe {
    constructor(e, t, r) {
      if (!(e instanceof jn || e instanceof er))
        throw new TypeError("word must be a UInt or UIntBE layout");
      if (
        (typeof t == "string" && r === void 0 && ((r = t), (t = !1)),
        4 < e.span)
      )
        throw new RangeError("word cannot exceed 32 bits");
      super(e.span, r), (this.word = e), (this.msb = !!t), (this.fields = []);
      let i = 0;
      (this._packedSetValue = function (s) {
        return (i = Mc(s)), this;
      }),
        (this._packedGetValue = function () {
          return i;
        });
    }
    decode(e, t = 0) {
      let r = this.makeDestinationObject(),
        i = this.word.decode(e, t);
      this._packedSetValue(i);
      for (let s of this.fields)
        s.property !== void 0 && (r[s.property] = s.decode(e));
      return r;
    }
    encode(e, t, r = 0) {
      let i = this.word.decode(t, r);
      this._packedSetValue(i);
      for (let s of this.fields)
        if (s.property !== void 0) {
          let o = e[s.property];
          o !== void 0 && s.encode(o);
        }
      return this.word.encode(this._packedGetValue(), t, r);
    }
    addField(e, t) {
      let r = new jl(this, e, t);
      return this.fields.push(r), r;
    }
    addBoolean(e) {
      let t = new mp(this, e);
      return this.fields.push(t), t;
    }
    fieldFor(e) {
      if (typeof e != "string") throw new TypeError("property must be string");
      for (let t of this.fields) if (t.property === e) return t;
    }
  };
  k.BitStructure = zl;
  var jl = class {
    constructor(e, t, r) {
      if (!(e instanceof zl))
        throw new TypeError("container must be a BitStructure");
      if (!Number.isInteger(t) || 0 >= t)
        throw new TypeError("bits must be positive integer");
      let i = 8 * e.span,
        s = e.fields.reduce((o, a) => o + a.bits, 0);
      if (t + s > i)
        throw new Error(
          "bits too long for span remainder (" +
            (i - s) +
            " of " +
            i +
            " remain)"
        );
      (this.container = e),
        (this.bits = t),
        (this.valueMask = (1 << t) - 1),
        t === 32 && (this.valueMask = 4294967295),
        (this.start = s),
        this.container.msb && (this.start = i - s - t),
        (this.wordMask = Mc(this.valueMask << this.start)),
        (this.property = r);
    }
    decode(e, t) {
      let r = this.container._packedGetValue();
      return Mc(r & this.wordMask) >>> this.start;
    }
    encode(e) {
      if (
        typeof e != "number" ||
        !Number.isInteger(e) ||
        e !== Mc(e & this.valueMask)
      )
        throw new TypeError(
          Nw("BitField.encode", this) +
            " value must be integer not exceeding " +
            this.valueMask
        );
      let t = this.container._packedGetValue(),
        r = Mc(e << this.start);
      this.container._packedSetValue(Mc(t & ~this.wordMask) | r);
    }
  };
  k.BitField = jl;
  var mp = class extends jl {
    constructor(e, t) {
      super(e, 1, t);
    }
    decode(e, t) {
      return !!super.decode(e, t);
    }
    encode(e) {
      typeof e == "boolean" && (e = +e), super.encode(e);
    }
  };
  k.Boolean = mp;
  var yp = class extends qe {
    constructor(e, t) {
      if (
        !((e instanceof yn && e.isCount()) || (Number.isInteger(e) && 0 <= e))
      )
        throw new TypeError(
          "length must be positive integer or an unsigned integer ExternalLayout"
        );
      let r = -1;
      e instanceof yn || (r = e), super(r, t), (this.length = e);
    }
    getSpan(e, t) {
      let r = this.span;
      return 0 > r && (r = this.length.decode(e, t)), r;
    }
    decode(e, t = 0) {
      let r = this.span;
      return 0 > r && (r = this.length.decode(e, t)), He(e).slice(t, t + r);
    }
    encode(e, t, r) {
      let i = this.length;
      if (
        (this.length instanceof yn && (i = e.length),
        !(e instanceof Uint8Array && i === e.length))
      )
        throw new TypeError(
          Nw("Blob.encode", this) +
            " requires (length " +
            i +
            ") Uint8Array as src"
        );
      if (r + i > t.length)
        throw new RangeError("encoding overruns Uint8Array");
      let s = He(e);
      return (
        He(t).write(s.toString("hex"), r, i, "hex"),
        this.length instanceof yn && this.length.encode(i, t, r),
        i
      );
    }
  };
  k.Blob = yp;
  var wp = class extends qe {
    constructor(e) {
      super(-1, e);
    }
    getSpan(e, t = 0) {
      zc(e);
      let r = t;
      for (; r < e.length && e[r] !== 0; ) r += 1;
      return 1 + r - t;
    }
    decode(e, t = 0) {
      let r = this.getSpan(e, t);
      return He(e)
        .slice(t, t + r - 1)
        .toString("utf-8");
    }
    encode(e, t, r = 0) {
      typeof e != "string" && (e = String(e));
      let i = Ow.Buffer.from(e, "utf8"),
        s = i.length;
      if (r + s > t.length) throw new RangeError("encoding overruns Buffer");
      let o = He(t);
      return i.copy(o, r), (o[r + s] = 0), s + 1;
    }
  };
  k.CString = wp;
  var bp = class extends qe {
    constructor(e, t) {
      if (
        (typeof e == "string" && t === void 0 && ((t = e), (e = void 0)),
        e === void 0)
      )
        e = -1;
      else if (!Number.isInteger(e))
        throw new TypeError("maxSpan must be an integer");
      super(-1, t), (this.maxSpan = e);
    }
    getSpan(e, t = 0) {
      return zc(e), e.length - t;
    }
    decode(e, t = 0) {
      let r = this.getSpan(e, t);
      if (0 <= this.maxSpan && this.maxSpan < r)
        throw new RangeError("text length exceeds maxSpan");
      return He(e)
        .slice(t, t + r)
        .toString("utf-8");
    }
    encode(e, t, r = 0) {
      typeof e != "string" && (e = String(e));
      let i = Ow.Buffer.from(e, "utf8"),
        s = i.length;
      if (0 <= this.maxSpan && this.maxSpan < s)
        throw new RangeError("text length exceeds maxSpan");
      if (r + s > t.length) throw new RangeError("encoding overruns Buffer");
      return i.copy(He(t), r), s;
    }
  };
  k.UTF8 = bp;
  var Ap = class extends qe {
    constructor(e, t) {
      super(0, t), (this.value = e);
    }
    decode(e, t) {
      return this.value;
    }
    encode(e, t, r) {
      return 0;
    }
  };
  k.Constant = Ap;
  k.greedy = (n, e) => new ip(n, e);
  k.offset = (n, e, t) => new Fl(n, e, t);
  k.u8 = (n) => new jn(1, n);
  k.u16 = (n) => new jn(2, n);
  k.u24 = (n) => new jn(3, n);
  k.u32 = (n) => new jn(4, n);
  k.u40 = (n) => new jn(5, n);
  k.u48 = (n) => new jn(6, n);
  k.nu64 = (n) => new sp(n);
  k.u16be = (n) => new er(2, n);
  k.u24be = (n) => new er(3, n);
  k.u32be = (n) => new er(4, n);
  k.u40be = (n) => new er(5, n);
  k.u48be = (n) => new er(6, n);
  k.nu64be = (n) => new op(n);
  k.s8 = (n) => new Ui(1, n);
  k.s16 = (n) => new Ui(2, n);
  k.s24 = (n) => new Ui(3, n);
  k.s32 = (n) => new Ui(4, n);
  k.s40 = (n) => new Ui(5, n);
  k.s48 = (n) => new Ui(6, n);
  k.ns64 = (n) => new ap(n);
  k.s16be = (n) => new Os(2, n);
  k.s24be = (n) => new Os(3, n);
  k.s32be = (n) => new Os(4, n);
  k.s40be = (n) => new Os(5, n);
  k.s48be = (n) => new Os(6, n);
  k.ns64be = (n) => new cp(n);
  k.f32 = (n) => new up(n);
  k.f32be = (n) => new lp(n);
  k.f64 = (n) => new hp(n);
  k.f64be = (n) => new fp(n);
  k.struct = (n, e, t) => new pp(n, e, t);
  k.bits = (n, e, t) => new zl(n, e, t);
  k.seq = (n, e, t) => new dp(n, e, t);
  k.union = (n, e, t) => new Ul(n, e, t);
  k.unionLayoutDiscriminator = (n, e) => new Uc(n, e);
  k.blob = (n, e) => new yp(n, e);
  k.cstr = (n) => new wp(n);
  k.utf8 = (n, e) => new bp(n, e);
  k.constant = (n, e) => new Ap(n, e);
});
var QC = ve((jc) => {
  "use strict";
  p();
  Object.defineProperty(jc, "__esModule", { value: !0 });
  var Sp;
  function I3(n) {
    {
      let e = Buffer.from(n);
      e.reverse();
      let t = e.toString("hex");
      return t.length === 0 ? BigInt(0) : BigInt(`0x${t}`);
    }
    return Sp.toBigInt(n, !1);
  }
  jc.toBigIntLE = I3;
  function C3(n) {
    {
      let e = n.toString("hex");
      return e.length === 0 ? BigInt(0) : BigInt(`0x${e}`);
    }
    return Sp.toBigInt(n, !0);
  }
  jc.toBigIntBE = C3;
  function k3(n, e) {
    {
      let t = n.toString(16),
        r = Buffer.from(t.padStart(e * 2, "0").slice(0, e * 2), "hex");
      return r.reverse(), r;
    }
    return Sp.fromBigInt(n, Buffer.allocUnsafe(e), !1);
  }
  jc.toBufferLE = k3;
  function T3(n, e) {
    {
      let t = n.toString(16);
      return Buffer.from(t.padStart(e * 2, "0").slice(0, e * 2), "hex");
    }
    return Sp.fromBigInt(n, Buffer.allocUnsafe(e), !0);
  }
  jc.toBufferBE = T3;
});
function R3(n) {
  return Wl(n) && typeof n[Symbol.iterator] == "function";
}
function Wl(n) {
  return typeof n == "object" && n != null;
}
function vp(n) {
  return Wl(n) && !Array.isArray(n);
}
function Mr(n) {
  return typeof n == "symbol"
    ? n.toString()
    : typeof n == "string"
    ? JSON.stringify(n)
    : `${n}`;
}
function B3(n) {
  let { done: e, value: t } = n.next();
  return e ? void 0 : t;
}
function D3(n, e, t, r) {
  if (n === !0) return;
  n === !1 ? (n = {}) : typeof n == "string" && (n = { message: n });
  let { path: i, branch: s } = e,
    { type: o } = t,
    {
      refinement: a,
      message: c = `Expected a value of type \`${o}\`${
        a ? ` with refinement \`${a}\`` : ""
      }, but received: \`${Mr(r)}\``,
    } = n;
  return $(
    v(
      {
        value: r,
        type: o,
        refinement: a,
        key: i[i.length - 1],
        path: i,
        branch: s,
      },
      n
    ),
    { message: c }
  );
}
function* JC(n, e, t, r) {
  R3(n) || (n = [n]);
  for (let i of n) {
    let s = D3(i, e, t, r);
    s && (yield s);
  }
}
function* Uw(n, e, t = {}) {
  let { path: r = [], branch: i = [n], coerce: s = !1, mask: o = !1 } = t,
    a = { path: r, branch: i, mask: o };
  s && (n = e.coercer(n, a));
  let c = "valid";
  for (let u of e.validator(n, a))
    (u.explanation = t.message), (c = "not_valid"), yield [u, void 0];
  for (let [u, l, h] of e.entries(n, a)) {
    let f = Uw(l, h, {
      path: u === void 0 ? r : [...r, u],
      branch: u === void 0 ? i : [...i, l],
      coerce: s,
      mask: o,
      message: t.message,
    });
    for (let g of f)
      g[0]
        ? ((c = g[0].refinement != null ? "not_refined" : "not_valid"),
          yield [g[0], void 0])
        : s &&
          ((l = g[1]),
          u === void 0
            ? (n = l)
            : n instanceof Map
            ? n.set(u, l)
            : n instanceof Set
            ? n.add(l)
            : Wl(n) && (l !== void 0 || u in n) && (n[u] = l));
  }
  if (c !== "not_valid")
    for (let u of e.refiner(n, a))
      (u.explanation = t.message), (c = "not_refined"), yield [u, void 0];
  c === "valid" && (yield [void 0, n]);
}
function zw(n, e, t) {
  let r = Hl(n, e, { message: t });
  if (r[0]) throw r[0];
}
function Q(n, e, t) {
  let r = Hl(n, e, { coerce: !0, message: t });
  if (r[0]) throw r[0];
  return r[1];
}
function _3(n, e, t) {
  let r = Hl(n, e, { coerce: !0, mask: !0, message: t });
  if (r[0]) throw r[0];
  return r[1];
}
function YC(n, e) {
  return !Hl(n, e)[0];
}
function Hl(n, e, t = {}) {
  let r = Uw(n, e, t),
    i = B3(r);
  return i[0]
    ? [
        new Mw(i[0], function* () {
          for (let o of r) o[0] && (yield o[0]);
        }),
        void 0,
      ]
    : [void 0, i[1]];
}
function Vo(n, e) {
  return new pr({ type: n, schema: null, validator: e });
}
function ZC() {
  return Vo("any", () => !0);
}
function te(n) {
  return new pr({
    type: "array",
    schema: n,
    *entries(e) {
      if (n && Array.isArray(e))
        for (let [t, r] of e.entries()) yield [t, r, n];
    },
    coercer(e) {
      return Array.isArray(e) ? e.slice() : e;
    },
    validator(e) {
      return (
        Array.isArray(e) || `Expected an array value, but received: ${Mr(e)}`
      );
    },
  });
}
function Ur() {
  return Vo("boolean", (n) => typeof n == "boolean");
}
function Ip(n) {
  return Vo(
    "instance",
    (e) =>
      e instanceof n ||
      `Expected a \`${n.name}\` instance, but received: ${Mr(e)}`
  );
}
function bt(n) {
  let e = Mr(n),
    t = typeof n;
  return new pr({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? n : null,
    validator(r) {
      return r === n || `Expected the literal \`${e}\`, but received: ${Mr(r)}`;
    },
  });
}
function P3() {
  return Vo("never", () => !1);
}
function ne(n) {
  return new pr(
    $(v({}, n), {
      validator: (e, t) => e === null || n.validator(e, t),
      refiner: (e, t) => e === null || n.refiner(e, t),
    })
  );
}
function C() {
  return Vo(
    "number",
    (n) =>
      (typeof n == "number" && !isNaN(n)) ||
      `Expected a number, but received: ${Mr(n)}`
  );
}
function de(n) {
  return new pr(
    $(v({}, n), {
      validator: (e, t) => e === void 0 || n.validator(e, t),
      refiner: (e, t) => e === void 0 || n.refiner(e, t),
    })
  );
}
function jw(n, e) {
  return new pr({
    type: "record",
    schema: null,
    *entries(t) {
      if (Wl(t))
        for (let r in t) {
          let i = t[r];
          yield [r, r, n], yield [r, i, e];
        }
    },
    validator(t) {
      return vp(t) || `Expected an object, but received: ${Mr(t)}`;
    },
    coercer(t) {
      return vp(t) ? v({}, t) : t;
    },
  });
}
function G() {
  return Vo(
    "string",
    (n) => typeof n == "string" || `Expected a string, but received: ${Mr(n)}`
  );
}
function Cp(n) {
  let e = P3();
  return new pr({
    type: "tuple",
    schema: null,
    *entries(t) {
      if (Array.isArray(t)) {
        let r = Math.max(n.length, t.length);
        for (let i = 0; i < r; i++) yield [i, t[i], n[i] || e];
      }
    },
    validator(t) {
      return Array.isArray(t) || `Expected an array, but received: ${Mr(t)}`;
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
  });
}
function z(n) {
  let e = Object.keys(n);
  return new pr({
    type: "type",
    schema: n,
    *entries(t) {
      if (Wl(t)) for (let r of e) yield [r, t[r], n[r]];
    },
    validator(t) {
      return vp(t) || `Expected an object, but received: ${Mr(t)}`;
    },
    coercer(t) {
      return vp(t) ? v({}, t) : t;
    },
  });
}
function wn(n) {
  let e = n.map((t) => t.type).join(" | ");
  return new pr({
    type: "union",
    schema: null,
    coercer(t, r) {
      for (let i of n) {
        let [s, o] = i.validate(t, { coerce: !0, mask: r.mask });
        if (!s) return o;
      }
      return t;
    },
    validator(t, r) {
      let i = [];
      for (let s of n) {
        let [...o] = Uw(t, s, r),
          [a] = o;
        if (a[0]) for (let [c] of o) c && i.push(c);
        else return [];
      }
      return [
        `Expected the value to satisfy a union of \`${e}\`, but received: ${Mr(
          t
        )}`,
        ...i,
      ];
    },
  });
}
function $o() {
  return Vo("unknown", () => !0);
}
function Wc(n, e, t) {
  return new pr(
    $(v({}, n), {
      coercer: (r, i) => (YC(r, e) ? n.coercer(t(r, i), i) : n.coercer(r, i)),
    })
  );
}
var Mw,
  pr,
  XC = ot(() => {
    "use strict";
    p();
    Mw = class extends TypeError {
      constructor(e, t) {
        let r,
          u = e,
          { message: i, explanation: s } = u,
          o = ln(u, ["message", "explanation"]),
          { path: a } = e,
          c = a.length === 0 ? i : `At path: ${a.join(".")} -- ${i}`;
        super(s ?? c),
          s != null && (this.cause = c),
          Object.assign(this, o),
          (this.name = this.constructor.name),
          (this.failures = () => r ?? (r = [e, ...t()]));
      }
    };
    pr = class {
      constructor(e) {
        let {
          type: t,
          schema: r,
          validator: i,
          refiner: s,
          coercer: o = (c) => c,
          entries: a = function* () {},
        } = e;
        (this.type = t),
          (this.schema = r),
          (this.entries = a),
          (this.coercer = o),
          i
            ? (this.validator = (c, u) => {
                let l = i(c, u);
                return JC(l, u, this, c);
              })
            : (this.validator = () => []),
          s
            ? (this.refiner = (c, u) => {
                let l = s(c, u);
                return JC(l, u, this, c);
              })
            : (this.refiner = () => []);
      }
      assert(e, t) {
        return zw(e, this, t);
      }
      create(e, t) {
        return Q(e, this, t);
      }
      is(e) {
        return YC(e, this);
      }
      mask(e, t) {
        return _3(e, this, t);
      }
      validate(e, t = {}) {
        return Hl(e, this, t);
      }
    };
  });
var tk = ve((ree, ek) => {
  "use strict";
  p();
  var L3 = (HE(), $g(WE)).v4,
    O3 = function (n, e, t, r) {
      if (typeof n != "string") throw new TypeError(n + " must be a string");
      r = r || {};
      let i = typeof r.version == "number" ? r.version : 2;
      if (i !== 1 && i !== 2) throw new TypeError(i + " must be 1 or 2");
      let s = { method: n };
      if ((i === 2 && (s.jsonrpc = "2.0"), e)) {
        if (typeof e != "object" && !Array.isArray(e))
          throw new TypeError(e + " must be an object, array or omitted");
        s.params = e;
      }
      if (typeof t > "u") {
        let o =
          typeof r.generator == "function"
            ? r.generator
            : function () {
                return L3();
              };
        s.id = o(s, r);
      } else
        i === 2 && t === null
          ? r.notificationIdNull && (s.id = null)
          : (s.id = t);
      return s;
    };
  ek.exports = O3;
});
var rk = ve((see, nk) => {
  "use strict";
  p();
  var N3 = (HE(), $g(WE)).v4,
    F3 = tk(),
    Vl = function (n, e) {
      if (!(this instanceof Vl)) return new Vl(n, e);
      e || (e = {}),
        (this.options = {
          reviver: typeof e.reviver < "u" ? e.reviver : null,
          replacer: typeof e.replacer < "u" ? e.replacer : null,
          generator:
            typeof e.generator < "u"
              ? e.generator
              : function () {
                  return N3();
                },
          version: typeof e.version < "u" ? e.version : 2,
          notificationIdNull:
            typeof e.notificationIdNull == "boolean"
              ? e.notificationIdNull
              : !1,
        }),
        (this.callServer = n);
    };
  nk.exports = Vl;
  Vl.prototype.request = function (n, e, t, r) {
    let i = this,
      s = null,
      o = Array.isArray(n) && typeof e == "function";
    if (this.options.version === 1 && o)
      throw new TypeError("JSON-RPC 1.0 does not support batching");
    if (o || (!o && n && typeof n == "object" && typeof e == "function"))
      (r = e), (s = n);
    else {
      typeof t == "function" && ((r = t), (t = void 0));
      let u = typeof r == "function";
      try {
        s = F3(n, e, t, {
          generator: this.options.generator,
          version: this.options.version,
          notificationIdNull: this.options.notificationIdNull,
        });
      } catch (l) {
        if (u) return r(l);
        throw l;
      }
      if (!u) return s;
    }
    let c;
    try {
      c = JSON.stringify(s, this.options.replacer);
    } catch (u) {
      return r(u);
    }
    return (
      this.callServer(c, function (u, l) {
        i._parseResponse(u, l, r);
      }),
      s
    );
  };
  Vl.prototype._parseResponse = function (n, e, t) {
    if (n) {
      t(n);
      return;
    }
    if (!e) return t();
    let r;
    try {
      r = JSON.parse(e, this.options.reviver);
    } catch (i) {
      return t(i);
    }
    if (t.length === 3)
      if (Array.isArray(r)) {
        let i = function (o) {
            return typeof o.error < "u";
          },
          s = function (o) {
            return !i(o);
          };
        return t(null, r.filter(i), r.filter(s));
      } else return t(null, r.error, r.result);
    t(null, r);
  };
});
var Ak = ve((Gc) => {
  "use strict";
  p();
  var Ww = Wh(),
    Vc = Hh(),
    ik =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : null;
  Gc.Buffer = P;
  Gc.SlowBuffer = H3;
  Gc.INSPECT_MAX_BYTES = 50;
  var kp = 2147483647;
  Gc.kMaxLength = kp;
  P.TYPED_ARRAY_SUPPORT = M3();
  !P.TYPED_ARRAY_SUPPORT &&
    typeof console < "u" &&
    typeof console.error == "function" &&
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  function M3() {
    try {
      let n = new Uint8Array(1),
        e = {
          foo: function () {
            return 42;
          },
        };
      return (
        Object.setPrototypeOf(e, Uint8Array.prototype),
        Object.setPrototypeOf(n, e),
        n.foo() === 42
      );
    } catch {
      return !1;
    }
  }
  Object.defineProperty(P.prototype, "parent", {
    enumerable: !0,
    get: function () {
      if (P.isBuffer(this)) return this.buffer;
    },
  });
  Object.defineProperty(P.prototype, "offset", {
    enumerable: !0,
    get: function () {
      if (P.isBuffer(this)) return this.byteOffset;
    },
  });
  function zi(n) {
    if (n > kp)
      throw new RangeError(
        'The value "' + n + '" is invalid for option "size"'
      );
    let e = new Uint8Array(n);
    return Object.setPrototypeOf(e, P.prototype), e;
  }
  function P(n, e, t) {
    if (typeof n == "number") {
      if (typeof e == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Gw(n);
    }
    return ck(n, e, t);
  }
  P.poolSize = 8192;
  function ck(n, e, t) {
    if (typeof n == "string") return z3(n, e);
    if (ArrayBuffer.isView(n)) return j3(n);
    if (n == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof n
      );
    if (
      ri(n, ArrayBuffer) ||
      (n && ri(n.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < "u" &&
        (ri(n, SharedArrayBuffer) || (n && ri(n.buffer, SharedArrayBuffer))))
    )
      return Vw(n, e, t);
    if (typeof n == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    let r = n.valueOf && n.valueOf();
    if (r != null && r !== n) return P.from(r, e, t);
    let i = W3(n);
    if (i) return i;
    if (
      typeof Symbol < "u" &&
      Symbol.toPrimitive != null &&
      typeof n[Symbol.toPrimitive] == "function"
    )
      return P.from(n[Symbol.toPrimitive]("string"), e, t);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof n
    );
  }
  P.from = function (n, e, t) {
    return ck(n, e, t);
  };
  Object.setPrototypeOf(P.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(P, Uint8Array);
  function uk(n) {
    if (typeof n != "number")
      throw new TypeError('"size" argument must be of type number');
    if (n < 0)
      throw new RangeError(
        'The value "' + n + '" is invalid for option "size"'
      );
  }
  function U3(n, e, t) {
    return (
      uk(n),
      n <= 0
        ? zi(n)
        : e !== void 0
        ? typeof t == "string"
          ? zi(n).fill(e, t)
          : zi(n).fill(e)
        : zi(n)
    );
  }
  P.alloc = function (n, e, t) {
    return U3(n, e, t);
  };
  function Gw(n) {
    return uk(n), zi(n < 0 ? 0 : Kw(n) | 0);
  }
  P.allocUnsafe = function (n) {
    return Gw(n);
  };
  P.allocUnsafeSlow = function (n) {
    return Gw(n);
  };
  function z3(n, e) {
    if (((typeof e != "string" || e === "") && (e = "utf8"), !P.isEncoding(e)))
      throw new TypeError("Unknown encoding: " + e);
    let t = lk(n, e) | 0,
      r = zi(t),
      i = r.write(n, e);
    return i !== t && (r = r.slice(0, i)), r;
  }
  function Hw(n) {
    let e = n.length < 0 ? 0 : Kw(n.length) | 0,
      t = zi(e);
    for (let r = 0; r < e; r += 1) t[r] = n[r] & 255;
    return t;
  }
  function j3(n) {
    if (ri(n, Uint8Array)) {
      let e = new Uint8Array(n);
      return Vw(e.buffer, e.byteOffset, e.byteLength);
    }
    return Hw(n);
  }
  function Vw(n, e, t) {
    if (e < 0 || n.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (n.byteLength < e + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let r;
    return (
      e === void 0 && t === void 0
        ? (r = new Uint8Array(n))
        : t === void 0
        ? (r = new Uint8Array(n, e))
        : (r = new Uint8Array(n, e, t)),
      Object.setPrototypeOf(r, P.prototype),
      r
    );
  }
  function W3(n) {
    if (P.isBuffer(n)) {
      let e = Kw(n.length) | 0,
        t = zi(e);
      return t.length === 0 || n.copy(t, 0, 0, e), t;
    }
    if (n.length !== void 0)
      return typeof n.length != "number" || Qw(n.length) ? zi(0) : Hw(n);
    if (n.type === "Buffer" && Array.isArray(n.data)) return Hw(n.data);
  }
  function Kw(n) {
    if (n >= kp)
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          kp.toString(16) +
          " bytes"
      );
    return n | 0;
  }
  function H3(n) {
    return +n != n && (n = 0), P.alloc(+n);
  }
  P.isBuffer = function (e) {
    return e != null && e._isBuffer === !0 && e !== P.prototype;
  };
  P.compare = function (e, t) {
    if (
      (ri(e, Uint8Array) && (e = P.from(e, e.offset, e.byteLength)),
      ri(t, Uint8Array) && (t = P.from(t, t.offset, t.byteLength)),
      !P.isBuffer(e) || !P.isBuffer(t))
    )
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (e === t) return 0;
    let r = e.length,
      i = t.length;
    for (let s = 0, o = Math.min(r, i); s < o; ++s)
      if (e[s] !== t[s]) {
        (r = e[s]), (i = t[s]);
        break;
      }
    return r < i ? -1 : i < r ? 1 : 0;
  };
  P.isEncoding = function (e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  };
  P.concat = function (e, t) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0) return P.alloc(0);
    let r;
    if (t === void 0) for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
    let i = P.allocUnsafe(t),
      s = 0;
    for (r = 0; r < e.length; ++r) {
      let o = e[r];
      if (ri(o, Uint8Array))
        s + o.length > i.length
          ? (P.isBuffer(o) || (o = P.from(o)), o.copy(i, s))
          : Uint8Array.prototype.set.call(i, o, s);
      else if (P.isBuffer(o)) o.copy(i, s);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      s += o.length;
    }
    return i;
  };
  function lk(n, e) {
    if (P.isBuffer(n)) return n.length;
    if (ArrayBuffer.isView(n) || ri(n, ArrayBuffer)) return n.byteLength;
    if (typeof n != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof n
      );
    let t = n.length,
      r = arguments.length > 2 && arguments[2] === !0;
    if (!r && t === 0) return 0;
    let i = !1;
    for (;;)
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return $w(n).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return bk(n).length;
        default:
          if (i) return r ? -1 : $w(n).length;
          (e = ("" + e).toLowerCase()), (i = !0);
      }
  }
  P.byteLength = lk;
  function V3(n, e, t) {
    let r = !1;
    if (
      ((e === void 0 || e < 0) && (e = 0),
      e > this.length ||
        ((t === void 0 || t > this.length) && (t = this.length), t <= 0) ||
        ((t >>>= 0), (e >>>= 0), t <= e))
    )
      return "";
    for (n || (n = "utf8"); ; )
      switch (n) {
        case "hex":
          return eU(this, e, t);
        case "utf8":
        case "utf-8":
          return fk(this, e, t);
        case "ascii":
          return Z3(this, e, t);
        case "latin1":
        case "binary":
          return X3(this, e, t);
        case "base64":
          return J3(this, e, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return tU(this, e, t);
        default:
          if (r) throw new TypeError("Unknown encoding: " + n);
          (n = (n + "").toLowerCase()), (r = !0);
      }
  }
  P.prototype._isBuffer = !0;
  function Go(n, e, t) {
    let r = n[e];
    (n[e] = n[t]), (n[t] = r);
  }
  P.prototype.swap16 = function () {
    let e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < e; t += 2) Go(this, t, t + 1);
    return this;
  };
  P.prototype.swap32 = function () {
    let e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < e; t += 4) Go(this, t, t + 3), Go(this, t + 1, t + 2);
    return this;
  };
  P.prototype.swap64 = function () {
    let e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < e; t += 8)
      Go(this, t, t + 7),
        Go(this, t + 1, t + 6),
        Go(this, t + 2, t + 5),
        Go(this, t + 3, t + 4);
    return this;
  };
  P.prototype.toString = function () {
    let e = this.length;
    return e === 0
      ? ""
      : arguments.length === 0
      ? fk(this, 0, e)
      : V3.apply(this, arguments);
  };
  P.prototype.toLocaleString = P.prototype.toString;
  P.prototype.equals = function (e) {
    if (!P.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
    return this === e ? !0 : P.compare(this, e) === 0;
  };
  P.prototype.inspect = function () {
    let e = "",
      t = Gc.INSPECT_MAX_BYTES;
    return (
      (e = this.toString("hex", 0, t)
        .replace(/(.{2})/g, "$1 ")
        .trim()),
      this.length > t && (e += " ... "),
      "<Buffer " + e + ">"
    );
  };
  ik && (P.prototype[ik] = P.prototype.inspect);
  P.prototype.compare = function (e, t, r, i, s) {
    if (
      (ri(e, Uint8Array) && (e = P.from(e, e.offset, e.byteLength)),
      !P.isBuffer(e))
    )
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
          typeof e
      );
    if (
      (t === void 0 && (t = 0),
      r === void 0 && (r = e ? e.length : 0),
      i === void 0 && (i = 0),
      s === void 0 && (s = this.length),
      t < 0 || r > e.length || i < 0 || s > this.length)
    )
      throw new RangeError("out of range index");
    if (i >= s && t >= r) return 0;
    if (i >= s) return -1;
    if (t >= r) return 1;
    if (((t >>>= 0), (r >>>= 0), (i >>>= 0), (s >>>= 0), this === e)) return 0;
    let o = s - i,
      a = r - t,
      c = Math.min(o, a),
      u = this.slice(i, s),
      l = e.slice(t, r);
    for (let h = 0; h < c; ++h)
      if (u[h] !== l[h]) {
        (o = u[h]), (a = l[h]);
        break;
      }
    return o < a ? -1 : a < o ? 1 : 0;
  };
  function hk(n, e, t, r, i) {
    if (n.length === 0) return -1;
    if (
      (typeof t == "string"
        ? ((r = t), (t = 0))
        : t > 2147483647
        ? (t = 2147483647)
        : t < -2147483648 && (t = -2147483648),
      (t = +t),
      Qw(t) && (t = i ? 0 : n.length - 1),
      t < 0 && (t = n.length + t),
      t >= n.length)
    ) {
      if (i) return -1;
      t = n.length - 1;
    } else if (t < 0)
      if (i) t = 0;
      else return -1;
    if ((typeof e == "string" && (e = P.from(e, r)), P.isBuffer(e)))
      return e.length === 0 ? -1 : sk(n, e, t, r, i);
    if (typeof e == "number")
      return (
        (e = e & 255),
        typeof Uint8Array.prototype.indexOf == "function"
          ? i
            ? Uint8Array.prototype.indexOf.call(n, e, t)
            : Uint8Array.prototype.lastIndexOf.call(n, e, t)
          : sk(n, [e], t, r, i)
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  function sk(n, e, t, r, i) {
    let s = 1,
      o = n.length,
      a = e.length;
    if (
      r !== void 0 &&
      ((r = String(r).toLowerCase()),
      r === "ucs2" || r === "ucs-2" || r === "utf16le" || r === "utf-16le")
    ) {
      if (n.length < 2 || e.length < 2) return -1;
      (s = 2), (o /= 2), (a /= 2), (t /= 2);
    }
    function c(l, h) {
      return s === 1 ? l[h] : l.readUInt16BE(h * s);
    }
    let u;
    if (i) {
      let l = -1;
      for (u = t; u < o; u++)
        if (c(n, u) === c(e, l === -1 ? 0 : u - l)) {
          if ((l === -1 && (l = u), u - l + 1 === a)) return l * s;
        } else l !== -1 && (u -= u - l), (l = -1);
    } else
      for (t + a > o && (t = o - a), u = t; u >= 0; u--) {
        let l = !0;
        for (let h = 0; h < a; h++)
          if (c(n, u + h) !== c(e, h)) {
            l = !1;
            break;
          }
        if (l) return u;
      }
    return -1;
  }
  P.prototype.includes = function (e, t, r) {
    return this.indexOf(e, t, r) !== -1;
  };
  P.prototype.indexOf = function (e, t, r) {
    return hk(this, e, t, r, !0);
  };
  P.prototype.lastIndexOf = function (e, t, r) {
    return hk(this, e, t, r, !1);
  };
  function $3(n, e, t, r) {
    t = Number(t) || 0;
    let i = n.length - t;
    r ? ((r = Number(r)), r > i && (r = i)) : (r = i);
    let s = e.length;
    r > s / 2 && (r = s / 2);
    let o;
    for (o = 0; o < r; ++o) {
      let a = parseInt(e.substr(o * 2, 2), 16);
      if (Qw(a)) return o;
      n[t + o] = a;
    }
    return o;
  }
  function G3(n, e, t, r) {
    return Tp($w(e, n.length - t), n, t, r);
  }
  function K3(n, e, t, r) {
    return Tp(sU(e), n, t, r);
  }
  function q3(n, e, t, r) {
    return Tp(bk(e), n, t, r);
  }
  function Q3(n, e, t, r) {
    return Tp(oU(e, n.length - t), n, t, r);
  }
  P.prototype.write = function (e, t, r, i) {
    if (t === void 0) (i = "utf8"), (r = this.length), (t = 0);
    else if (r === void 0 && typeof t == "string")
      (i = t), (r = this.length), (t = 0);
    else if (isFinite(t))
      (t = t >>> 0),
        isFinite(r)
          ? ((r = r >>> 0), i === void 0 && (i = "utf8"))
          : ((i = r), (r = void 0));
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    let s = this.length - t;
    if (
      ((r === void 0 || r > s) && (r = s),
      (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds");
    i || (i = "utf8");
    let o = !1;
    for (;;)
      switch (i) {
        case "hex":
          return $3(this, e, t, r);
        case "utf8":
        case "utf-8":
          return G3(this, e, t, r);
        case "ascii":
        case "latin1":
        case "binary":
          return K3(this, e, t, r);
        case "base64":
          return q3(this, e, t, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Q3(this, e, t, r);
        default:
          if (o) throw new TypeError("Unknown encoding: " + i);
          (i = ("" + i).toLowerCase()), (o = !0);
      }
  };
  P.prototype.toJSON = function () {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0),
    };
  };
  function J3(n, e, t) {
    return e === 0 && t === n.length
      ? Ww.fromByteArray(n)
      : Ww.fromByteArray(n.slice(e, t));
  }
  function fk(n, e, t) {
    t = Math.min(n.length, t);
    let r = [],
      i = e;
    for (; i < t; ) {
      let s = n[i],
        o = null,
        a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (i + a <= t) {
        let c, u, l, h;
        switch (a) {
          case 1:
            s < 128 && (o = s);
            break;
          case 2:
            (c = n[i + 1]),
              (c & 192) === 128 &&
                ((h = ((s & 31) << 6) | (c & 63)), h > 127 && (o = h));
            break;
          case 3:
            (c = n[i + 1]),
              (u = n[i + 2]),
              (c & 192) === 128 &&
                (u & 192) === 128 &&
                ((h = ((s & 15) << 12) | ((c & 63) << 6) | (u & 63)),
                h > 2047 && (h < 55296 || h > 57343) && (o = h));
            break;
          case 4:
            (c = n[i + 1]),
              (u = n[i + 2]),
              (l = n[i + 3]),
              (c & 192) === 128 &&
                (u & 192) === 128 &&
                (l & 192) === 128 &&
                ((h =
                  ((s & 15) << 18) |
                  ((c & 63) << 12) |
                  ((u & 63) << 6) |
                  (l & 63)),
                h > 65535 && h < 1114112 && (o = h));
        }
      }
      o === null
        ? ((o = 65533), (a = 1))
        : o > 65535 &&
          ((o -= 65536),
          r.push(((o >>> 10) & 1023) | 55296),
          (o = 56320 | (o & 1023))),
        r.push(o),
        (i += a);
    }
    return Y3(r);
  }
  var ok = 4096;
  function Y3(n) {
    let e = n.length;
    if (e <= ok) return String.fromCharCode.apply(String, n);
    let t = "",
      r = 0;
    for (; r < e; )
      t += String.fromCharCode.apply(String, n.slice(r, (r += ok)));
    return t;
  }
  function Z3(n, e, t) {
    let r = "";
    t = Math.min(n.length, t);
    for (let i = e; i < t; ++i) r += String.fromCharCode(n[i] & 127);
    return r;
  }
  function X3(n, e, t) {
    let r = "";
    t = Math.min(n.length, t);
    for (let i = e; i < t; ++i) r += String.fromCharCode(n[i]);
    return r;
  }
  function eU(n, e, t) {
    let r = n.length;
    (!e || e < 0) && (e = 0), (!t || t < 0 || t > r) && (t = r);
    let i = "";
    for (let s = e; s < t; ++s) i += aU[n[s]];
    return i;
  }
  function tU(n, e, t) {
    let r = n.slice(e, t),
      i = "";
    for (let s = 0; s < r.length - 1; s += 2)
      i += String.fromCharCode(r[s] + r[s + 1] * 256);
    return i;
  }
  P.prototype.slice = function (e, t) {
    let r = this.length;
    (e = ~~e),
      (t = t === void 0 ? r : ~~t),
      e < 0 ? ((e += r), e < 0 && (e = 0)) : e > r && (e = r),
      t < 0 ? ((t += r), t < 0 && (t = 0)) : t > r && (t = r),
      t < e && (t = e);
    let i = this.subarray(e, t);
    return Object.setPrototypeOf(i, P.prototype), i;
  };
  function Jt(n, e, t) {
    if (n % 1 !== 0 || n < 0) throw new RangeError("offset is not uint");
    if (n + e > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  P.prototype.readUintLE = P.prototype.readUIntLE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Jt(e, t, this.length);
    let i = this[e],
      s = 1,
      o = 0;
    for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
    return i;
  };
  P.prototype.readUintBE = P.prototype.readUIntBE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Jt(e, t, this.length);
    let i = this[e + --t],
      s = 1;
    for (; t > 0 && (s *= 256); ) i += this[e + --t] * s;
    return i;
  };
  P.prototype.readUint8 = P.prototype.readUInt8 = function (e, t) {
    return (e = e >>> 0), t || Jt(e, 1, this.length), this[e];
  };
  P.prototype.readUint16LE = P.prototype.readUInt16LE = function (e, t) {
    return (
      (e = e >>> 0), t || Jt(e, 2, this.length), this[e] | (this[e + 1] << 8)
    );
  };
  P.prototype.readUint16BE = P.prototype.readUInt16BE = function (e, t) {
    return (
      (e = e >>> 0), t || Jt(e, 2, this.length), (this[e] << 8) | this[e + 1]
    );
  };
  P.prototype.readUint32LE = P.prototype.readUInt32LE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Jt(e, 4, this.length),
      (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
        this[e + 3] * 16777216
    );
  };
  P.prototype.readUint32BE = P.prototype.readUInt32BE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Jt(e, 4, this.length),
      this[e] * 16777216 +
        ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
    );
  };
  P.prototype.readBigUInt64LE = Ns(function (e) {
    (e = e >>> 0), $c(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && $l(e, this.length - 8);
    let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24,
      s = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + r * 2 ** 24;
    return BigInt(i) + (BigInt(s) << BigInt(32));
  });
  P.prototype.readBigUInt64BE = Ns(function (e) {
    (e = e >>> 0), $c(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && $l(e, this.length - 8);
    let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e],
      s = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r;
    return (BigInt(i) << BigInt(32)) + BigInt(s);
  });
  P.prototype.readIntLE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Jt(e, t, this.length);
    let i = this[e],
      s = 1,
      o = 0;
    for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
    return (s *= 128), i >= s && (i -= Math.pow(2, 8 * t)), i;
  };
  P.prototype.readIntBE = function (e, t, r) {
    (e = e >>> 0), (t = t >>> 0), r || Jt(e, t, this.length);
    let i = t,
      s = 1,
      o = this[e + --i];
    for (; i > 0 && (s *= 256); ) o += this[e + --i] * s;
    return (s *= 128), o >= s && (o -= Math.pow(2, 8 * t)), o;
  };
  P.prototype.readInt8 = function (e, t) {
    return (
      (e = e >>> 0),
      t || Jt(e, 1, this.length),
      this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
    );
  };
  P.prototype.readInt16LE = function (e, t) {
    (e = e >>> 0), t || Jt(e, 2, this.length);
    let r = this[e] | (this[e + 1] << 8);
    return r & 32768 ? r | 4294901760 : r;
  };
  P.prototype.readInt16BE = function (e, t) {
    (e = e >>> 0), t || Jt(e, 2, this.length);
    let r = this[e + 1] | (this[e] << 8);
    return r & 32768 ? r | 4294901760 : r;
  };
  P.prototype.readInt32LE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Jt(e, 4, this.length),
      this[e] | (this[e + 1] << 8) | (this[e + 2] << 16) | (this[e + 3] << 24)
    );
  };
  P.prototype.readInt32BE = function (e, t) {
    return (
      (e = e >>> 0),
      t || Jt(e, 4, this.length),
      (this[e] << 24) | (this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3]
    );
  };
  P.prototype.readBigInt64LE = Ns(function (e) {
    (e = e >>> 0), $c(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && $l(e, this.length - 8);
    let i =
      this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (r << 24);
    return (
      (BigInt(i) << BigInt(32)) +
      BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
    );
  });
  P.prototype.readBigInt64BE = Ns(function (e) {
    (e = e >>> 0), $c(e, "offset");
    let t = this[e],
      r = this[e + 7];
    (t === void 0 || r === void 0) && $l(e, this.length - 8);
    let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (
      (BigInt(i) << BigInt(32)) +
      BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + r)
    );
  });
  P.prototype.readFloatLE = function (e, t) {
    return (
      (e = e >>> 0), t || Jt(e, 4, this.length), Vc.read(this, e, !0, 23, 4)
    );
  };
  P.prototype.readFloatBE = function (e, t) {
    return (
      (e = e >>> 0), t || Jt(e, 4, this.length), Vc.read(this, e, !1, 23, 4)
    );
  };
  P.prototype.readDoubleLE = function (e, t) {
    return (
      (e = e >>> 0), t || Jt(e, 8, this.length), Vc.read(this, e, !0, 52, 8)
    );
  };
  P.prototype.readDoubleBE = function (e, t) {
    return (
      (e = e >>> 0), t || Jt(e, 8, this.length), Vc.read(this, e, !1, 52, 8)
    );
  };
  function Wn(n, e, t, r, i, s) {
    if (!P.isBuffer(n))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > i || e < s)
      throw new RangeError('"value" argument is out of bounds');
    if (t + r > n.length) throw new RangeError("Index out of range");
  }
  P.prototype.writeUintLE = P.prototype.writeUIntLE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), (r = r >>> 0), !i)) {
      let a = Math.pow(2, 8 * r) - 1;
      Wn(this, e, t, r, a, 0);
    }
    let s = 1,
      o = 0;
    for (this[t] = e & 255; ++o < r && (s *= 256); )
      this[t + o] = (e / s) & 255;
    return t + r;
  };
  P.prototype.writeUintBE = P.prototype.writeUIntBE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), (r = r >>> 0), !i)) {
      let a = Math.pow(2, 8 * r) - 1;
      Wn(this, e, t, r, a, 0);
    }
    let s = r - 1,
      o = 1;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
      this[t + s] = (e / o) & 255;
    return t + r;
  };
  P.prototype.writeUint8 = P.prototype.writeUInt8 = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 1, 255, 0),
      (this[t] = e & 255),
      t + 1
    );
  };
  P.prototype.writeUint16LE = P.prototype.writeUInt16LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 2, 65535, 0),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      t + 2
    );
  };
  P.prototype.writeUint16BE = P.prototype.writeUInt16BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 2, 65535, 0),
      (this[t] = e >>> 8),
      (this[t + 1] = e & 255),
      t + 2
    );
  };
  P.prototype.writeUint32LE = P.prototype.writeUInt32LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 4, 4294967295, 0),
      (this[t + 3] = e >>> 24),
      (this[t + 2] = e >>> 16),
      (this[t + 1] = e >>> 8),
      (this[t] = e & 255),
      t + 4
    );
  };
  P.prototype.writeUint32BE = P.prototype.writeUInt32BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 4, 4294967295, 0),
      (this[t] = e >>> 24),
      (this[t + 1] = e >>> 16),
      (this[t + 2] = e >>> 8),
      (this[t + 3] = e & 255),
      t + 4
    );
  };
  function dk(n, e, t, r, i) {
    wk(e, r, i, n, t, 7);
    let s = Number(e & BigInt(4294967295));
    (n[t++] = s),
      (s = s >> 8),
      (n[t++] = s),
      (s = s >> 8),
      (n[t++] = s),
      (s = s >> 8),
      (n[t++] = s);
    let o = Number((e >> BigInt(32)) & BigInt(4294967295));
    return (
      (n[t++] = o),
      (o = o >> 8),
      (n[t++] = o),
      (o = o >> 8),
      (n[t++] = o),
      (o = o >> 8),
      (n[t++] = o),
      t
    );
  }
  function pk(n, e, t, r, i) {
    wk(e, r, i, n, t, 7);
    let s = Number(e & BigInt(4294967295));
    (n[t + 7] = s),
      (s = s >> 8),
      (n[t + 6] = s),
      (s = s >> 8),
      (n[t + 5] = s),
      (s = s >> 8),
      (n[t + 4] = s);
    let o = Number((e >> BigInt(32)) & BigInt(4294967295));
    return (
      (n[t + 3] = o),
      (o = o >> 8),
      (n[t + 2] = o),
      (o = o >> 8),
      (n[t + 1] = o),
      (o = o >> 8),
      (n[t] = o),
      t + 8
    );
  }
  P.prototype.writeBigUInt64LE = Ns(function (e, t = 0) {
    return dk(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  P.prototype.writeBigUInt64BE = Ns(function (e, t = 0) {
    return pk(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  P.prototype.writeIntLE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), !i)) {
      let c = Math.pow(2, 8 * r - 1);
      Wn(this, e, t, r, c - 1, -c);
    }
    let s = 0,
      o = 1,
      a = 0;
    for (this[t] = e & 255; ++s < r && (o *= 256); )
      e < 0 && a === 0 && this[t + s - 1] !== 0 && (a = 1),
        (this[t + s] = (((e / o) >> 0) - a) & 255);
    return t + r;
  };
  P.prototype.writeIntBE = function (e, t, r, i) {
    if (((e = +e), (t = t >>> 0), !i)) {
      let c = Math.pow(2, 8 * r - 1);
      Wn(this, e, t, r, c - 1, -c);
    }
    let s = r - 1,
      o = 1,
      a = 0;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
      e < 0 && a === 0 && this[t + s + 1] !== 0 && (a = 1),
        (this[t + s] = (((e / o) >> 0) - a) & 255);
    return t + r;
  };
  P.prototype.writeInt8 = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 1, 127, -128),
      e < 0 && (e = 255 + e + 1),
      (this[t] = e & 255),
      t + 1
    );
  };
  P.prototype.writeInt16LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 2, 32767, -32768),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      t + 2
    );
  };
  P.prototype.writeInt16BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 2, 32767, -32768),
      (this[t] = e >>> 8),
      (this[t + 1] = e & 255),
      t + 2
    );
  };
  P.prototype.writeInt32LE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 4, 2147483647, -2147483648),
      (this[t] = e & 255),
      (this[t + 1] = e >>> 8),
      (this[t + 2] = e >>> 16),
      (this[t + 3] = e >>> 24),
      t + 4
    );
  };
  P.prototype.writeInt32BE = function (e, t, r) {
    return (
      (e = +e),
      (t = t >>> 0),
      r || Wn(this, e, t, 4, 2147483647, -2147483648),
      e < 0 && (e = 4294967295 + e + 1),
      (this[t] = e >>> 24),
      (this[t + 1] = e >>> 16),
      (this[t + 2] = e >>> 8),
      (this[t + 3] = e & 255),
      t + 4
    );
  };
  P.prototype.writeBigInt64LE = Ns(function (e, t = 0) {
    return dk(
      this,
      e,
      t,
      -BigInt("0x8000000000000000"),
      BigInt("0x7fffffffffffffff")
    );
  });
  P.prototype.writeBigInt64BE = Ns(function (e, t = 0) {
    return pk(
      this,
      e,
      t,
      -BigInt("0x8000000000000000"),
      BigInt("0x7fffffffffffffff")
    );
  });
  function gk(n, e, t, r, i, s) {
    if (t + r > n.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  function mk(n, e, t, r, i) {
    return (
      (e = +e),
      (t = t >>> 0),
      i || gk(n, e, t, 4, 34028234663852886e22, -34028234663852886e22),
      Vc.write(n, e, t, r, 23, 4),
      t + 4
    );
  }
  P.prototype.writeFloatLE = function (e, t, r) {
    return mk(this, e, t, !0, r);
  };
  P.prototype.writeFloatBE = function (e, t, r) {
    return mk(this, e, t, !1, r);
  };
  function yk(n, e, t, r, i) {
    return (
      (e = +e),
      (t = t >>> 0),
      i || gk(n, e, t, 8, 17976931348623157e292, -17976931348623157e292),
      Vc.write(n, e, t, r, 52, 8),
      t + 8
    );
  }
  P.prototype.writeDoubleLE = function (e, t, r) {
    return yk(this, e, t, !0, r);
  };
  P.prototype.writeDoubleBE = function (e, t, r) {
    return yk(this, e, t, !1, r);
  };
  P.prototype.copy = function (e, t, r, i) {
    if (!P.isBuffer(e)) throw new TypeError("argument should be a Buffer");
    if (
      (r || (r = 0),
      !i && i !== 0 && (i = this.length),
      t >= e.length && (t = e.length),
      t || (t = 0),
      i > 0 && i < r && (i = r),
      i === r || e.length === 0 || this.length === 0)
    )
      return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
    if (i < 0) throw new RangeError("sourceEnd out of bounds");
    i > this.length && (i = this.length),
      e.length - t < i - r && (i = e.length - t + r);
    let s = i - r;
    return (
      this === e && typeof Uint8Array.prototype.copyWithin == "function"
        ? this.copyWithin(t, r, i)
        : Uint8Array.prototype.set.call(e, this.subarray(r, i), t),
      s
    );
  };
  P.prototype.fill = function (e, t, r, i) {
    if (typeof e == "string") {
      if (
        (typeof t == "string"
          ? ((i = t), (t = 0), (r = this.length))
          : typeof r == "string" && ((i = r), (r = this.length)),
        i !== void 0 && typeof i != "string")
      )
        throw new TypeError("encoding must be a string");
      if (typeof i == "string" && !P.isEncoding(i))
        throw new TypeError("Unknown encoding: " + i);
      if (e.length === 1) {
        let o = e.charCodeAt(0);
        ((i === "utf8" && o < 128) || i === "latin1") && (e = o);
      }
    } else
      typeof e == "number"
        ? (e = e & 255)
        : typeof e == "boolean" && (e = Number(e));
    if (t < 0 || this.length < t || this.length < r)
      throw new RangeError("Out of range index");
    if (r <= t) return this;
    (t = t >>> 0), (r = r === void 0 ? this.length : r >>> 0), e || (e = 0);
    let s;
    if (typeof e == "number") for (s = t; s < r; ++s) this[s] = e;
    else {
      let o = P.isBuffer(e) ? e : P.from(e, i),
        a = o.length;
      if (a === 0)
        throw new TypeError(
          'The value "' + e + '" is invalid for argument "value"'
        );
      for (s = 0; s < r - t; ++s) this[s + t] = o[s % a];
    }
    return this;
  };
  var Hc = {};
  function qw(n, e, t) {
    Hc[n] = class extends t {
      constructor() {
        super(),
          Object.defineProperty(this, "message", {
            value: e.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${n}]`),
          this.stack,
          delete this.name;
      }
      get code() {
        return n;
      }
      set code(i) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: i,
          writable: !0,
        });
      }
      toString() {
        return `${this.name} [${n}]: ${this.message}`;
      }
    };
  }
  qw(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function (n) {
      return n
        ? `${n} is outside of buffer bounds`
        : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  qw(
    "ERR_INVALID_ARG_TYPE",
    function (n, e) {
      return `The "${n}" argument must be of type number. Received type ${typeof e}`;
    },
    TypeError
  );
  qw(
    "ERR_OUT_OF_RANGE",
    function (n, e, t) {
      let r = `The value of "${n}" is out of range.`,
        i = t;
      return (
        Number.isInteger(t) && Math.abs(t) > 2 ** 32
          ? (i = ak(String(t)))
          : typeof t == "bigint" &&
            ((i = String(t)),
            (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) &&
              (i = ak(i)),
            (i += "n")),
        (r += ` It must be ${e}. Received ${i}`),
        r
      );
    },
    RangeError
  );
  function ak(n) {
    let e = "",
      t = n.length,
      r = n[0] === "-" ? 1 : 0;
    for (; t >= r + 4; t -= 3) e = `_${n.slice(t - 3, t)}${e}`;
    return `${n.slice(0, t)}${e}`;
  }
  function nU(n, e, t) {
    $c(e, "offset"),
      (n[e] === void 0 || n[e + t] === void 0) && $l(e, n.length - (t + 1));
  }
  function wk(n, e, t, r, i, s) {
    if (n > t || n < e) {
      let o = typeof e == "bigint" ? "n" : "",
        a;
      throw (
        (s > 3
          ? e === 0 || e === BigInt(0)
            ? (a = `>= 0${o} and < 2${o} ** ${(s + 1) * 8}${o}`)
            : (a = `>= -(2${o} ** ${(s + 1) * 8 - 1}${o}) and < 2 ** ${
                (s + 1) * 8 - 1
              }${o}`)
          : (a = `>= ${e}${o} and <= ${t}${o}`),
        new Hc.ERR_OUT_OF_RANGE("value", a, n))
      );
    }
    nU(r, i, s);
  }
  function $c(n, e) {
    if (typeof n != "number") throw new Hc.ERR_INVALID_ARG_TYPE(e, "number", n);
  }
  function $l(n, e, t) {
    throw Math.floor(n) !== n
      ? ($c(n, t), new Hc.ERR_OUT_OF_RANGE(t || "offset", "an integer", n))
      : e < 0
      ? new Hc.ERR_BUFFER_OUT_OF_BOUNDS()
      : new Hc.ERR_OUT_OF_RANGE(
          t || "offset",
          `>= ${t ? 1 : 0} and <= ${e}`,
          n
        );
  }
  var rU = /[^+/0-9A-Za-z-_]/g;
  function iU(n) {
    if (((n = n.split("=")[0]), (n = n.trim().replace(rU, "")), n.length < 2))
      return "";
    for (; n.length % 4 !== 0; ) n = n + "=";
    return n;
  }
  function $w(n, e) {
    e = e || 1 / 0;
    let t,
      r = n.length,
      i = null,
      s = [];
    for (let o = 0; o < r; ++o) {
      if (((t = n.charCodeAt(o)), t > 55295 && t < 57344)) {
        if (!i) {
          if (t > 56319) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          } else if (o + 1 === r) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          i = t;
          continue;
        }
        if (t < 56320) {
          (e -= 3) > -1 && s.push(239, 191, 189), (i = t);
          continue;
        }
        t = (((i - 55296) << 10) | (t - 56320)) + 65536;
      } else i && (e -= 3) > -1 && s.push(239, 191, 189);
      if (((i = null), t < 128)) {
        if ((e -= 1) < 0) break;
        s.push(t);
      } else if (t < 2048) {
        if ((e -= 2) < 0) break;
        s.push((t >> 6) | 192, (t & 63) | 128);
      } else if (t < 65536) {
        if ((e -= 3) < 0) break;
        s.push((t >> 12) | 224, ((t >> 6) & 63) | 128, (t & 63) | 128);
      } else if (t < 1114112) {
        if ((e -= 4) < 0) break;
        s.push(
          (t >> 18) | 240,
          ((t >> 12) & 63) | 128,
          ((t >> 6) & 63) | 128,
          (t & 63) | 128
        );
      } else throw new Error("Invalid code point");
    }
    return s;
  }
  function sU(n) {
    let e = [];
    for (let t = 0; t < n.length; ++t) e.push(n.charCodeAt(t) & 255);
    return e;
  }
  function oU(n, e) {
    let t,
      r,
      i,
      s = [];
    for (let o = 0; o < n.length && !((e -= 2) < 0); ++o)
      (t = n.charCodeAt(o)), (r = t >> 8), (i = t % 256), s.push(i), s.push(r);
    return s;
  }
  function bk(n) {
    return Ww.toByteArray(iU(n));
  }
  function Tp(n, e, t, r) {
    let i;
    for (i = 0; i < r && !(i + t >= e.length || i >= n.length); ++i)
      e[i + t] = n[i];
    return i;
  }
  function ri(n, e) {
    return (
      n instanceof e ||
      (n != null &&
        n.constructor != null &&
        n.constructor.name != null &&
        n.constructor.name === e.name)
    );
  }
  function Qw(n) {
    return n !== n;
  }
  var aU = (function () {
    let n = "0123456789abcdef",
      e = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let r = t * 16;
      for (let i = 0; i < 16; ++i) e[r + i] = n[t] + n[i];
    }
    return e;
  })();
  function Ns(n) {
    return typeof BigInt > "u" ? cU : n;
  }
  function cU() {
    throw new Error("BigInt not supported");
  }
});
var xk = ve((lee, Jw) => {
  "use strict";
  p();
  var uU = Object.prototype.hasOwnProperty,
    Tn = "~";
  function Gl() {}
  Object.create &&
    ((Gl.prototype = Object.create(null)), new Gl().__proto__ || (Tn = !1));
  function lU(n, e, t) {
    (this.fn = n), (this.context = e), (this.once = t || !1);
  }
  function Ek(n, e, t, r, i) {
    if (typeof t != "function")
      throw new TypeError("The listener must be a function");
    var s = new lU(t, r || n, i),
      o = Tn ? Tn + e : e;
    return (
      n._events[o]
        ? n._events[o].fn
          ? (n._events[o] = [n._events[o], s])
          : n._events[o].push(s)
        : ((n._events[o] = s), n._eventsCount++),
      n
    );
  }
  function Rp(n, e) {
    --n._eventsCount === 0 ? (n._events = new Gl()) : delete n._events[e];
  }
  function bn() {
    (this._events = new Gl()), (this._eventsCount = 0);
  }
  bn.prototype.eventNames = function () {
    var e = [],
      t,
      r;
    if (this._eventsCount === 0) return e;
    for (r in (t = this._events)) uU.call(t, r) && e.push(Tn ? r.slice(1) : r);
    return Object.getOwnPropertySymbols
      ? e.concat(Object.getOwnPropertySymbols(t))
      : e;
  };
  bn.prototype.listeners = function (e) {
    var t = Tn ? Tn + e : e,
      r = this._events[t];
    if (!r) return [];
    if (r.fn) return [r.fn];
    for (var i = 0, s = r.length, o = new Array(s); i < s; i++) o[i] = r[i].fn;
    return o;
  };
  bn.prototype.listenerCount = function (e) {
    var t = Tn ? Tn + e : e,
      r = this._events[t];
    return r ? (r.fn ? 1 : r.length) : 0;
  };
  bn.prototype.emit = function (e, t, r, i, s, o) {
    var a = Tn ? Tn + e : e;
    if (!this._events[a]) return !1;
    var c = this._events[a],
      u = arguments.length,
      l,
      h;
    if (c.fn) {
      switch ((c.once && this.removeListener(e, c.fn, void 0, !0), u)) {
        case 1:
          return c.fn.call(c.context), !0;
        case 2:
          return c.fn.call(c.context, t), !0;
        case 3:
          return c.fn.call(c.context, t, r), !0;
        case 4:
          return c.fn.call(c.context, t, r, i), !0;
        case 5:
          return c.fn.call(c.context, t, r, i, s), !0;
        case 6:
          return c.fn.call(c.context, t, r, i, s, o), !0;
      }
      for (h = 1, l = new Array(u - 1); h < u; h++) l[h - 1] = arguments[h];
      c.fn.apply(c.context, l);
    } else {
      var f = c.length,
        g;
      for (h = 0; h < f; h++)
        switch ((c[h].once && this.removeListener(e, c[h].fn, void 0, !0), u)) {
          case 1:
            c[h].fn.call(c[h].context);
            break;
          case 2:
            c[h].fn.call(c[h].context, t);
            break;
          case 3:
            c[h].fn.call(c[h].context, t, r);
            break;
          case 4:
            c[h].fn.call(c[h].context, t, r, i);
            break;
          default:
            if (!l)
              for (g = 1, l = new Array(u - 1); g < u; g++)
                l[g - 1] = arguments[g];
            c[h].fn.apply(c[h].context, l);
        }
    }
    return !0;
  };
  bn.prototype.on = function (e, t, r) {
    return Ek(this, e, t, r, !1);
  };
  bn.prototype.once = function (e, t, r) {
    return Ek(this, e, t, r, !0);
  };
  bn.prototype.removeListener = function (e, t, r, i) {
    var s = Tn ? Tn + e : e;
    if (!this._events[s]) return this;
    if (!t) return Rp(this, s), this;
    var o = this._events[s];
    if (o.fn)
      o.fn === t && (!i || o.once) && (!r || o.context === r) && Rp(this, s);
    else {
      for (var a = 0, c = [], u = o.length; a < u; a++)
        (o[a].fn !== t || (i && !o[a].once) || (r && o[a].context !== r)) &&
          c.push(o[a]);
      c.length ? (this._events[s] = c.length === 1 ? c[0] : c) : Rp(this, s);
    }
    return this;
  };
  bn.prototype.removeAllListeners = function (e) {
    var t;
    return (
      e
        ? ((t = Tn ? Tn + e : e), this._events[t] && Rp(this, t))
        : ((this._events = new Gl()), (this._eventsCount = 0)),
      this
    );
  };
  bn.prototype.off = bn.prototype.removeListener;
  bn.prototype.addListener = bn.prototype.on;
  bn.prefixed = Tn;
  bn.EventEmitter = bn;
  typeof Jw < "u" && (Jw.exports = bn);
});
var Bp,
  Sk = ot(() => {
    "use strict";
    p();
    Bp = Et(xk(), 1);
  });
function Ik(n, e) {
  return new hU(n, e);
}
var vk,
  hU,
  fU,
  Ck,
  kk = ot(() => {
    "use strict";
    p();
    vk = Et(Ak(), 1);
    Sk();
    hU = class extends Bp.default {
      socket;
      constructor(n, e, t) {
        super(),
          (this.socket = new window.WebSocket(n, t)),
          (this.socket.onopen = () => this.emit("open")),
          (this.socket.onmessage = (r) => this.emit("message", r.data)),
          (this.socket.onerror = (r) => this.emit("error", r)),
          (this.socket.onclose = (r) => {
            this.emit("close", r.code, r.reason);
          });
      }
      send(n, e, t) {
        let r = t || e;
        try {
          this.socket.send(n), r();
        } catch (i) {
          r(i);
        }
      }
      close(n, e) {
        this.socket.close(n, e);
      }
      addEventListener(n, e, t) {
        this.socket.addEventListener(n, e, t);
      }
    };
    (fU = class {
      encode(n) {
        return JSON.stringify(n);
      }
      decode(n) {
        return JSON.parse(n);
      }
    }),
      (Ck = class extends Bp.default {
        address;
        rpc_id;
        queue;
        options;
        autoconnect;
        ready;
        reconnect;
        reconnect_timer_id;
        reconnect_interval;
        max_reconnects;
        rest_options;
        current_reconnects;
        generate_request_id;
        socket;
        webSocketFactory;
        dataPack;
        constructor(n, e = "ws://localhost:8080", u = {}, a, c) {
          var l = u,
            {
              autoconnect: t = !0,
              reconnect: r = !0,
              reconnect_interval: i = 1e3,
              max_reconnects: s = 5,
            } = l,
            o = ln(l, [
              "autoconnect",
              "reconnect",
              "reconnect_interval",
              "max_reconnects",
            ]);
          super(),
            (this.webSocketFactory = n),
            (this.queue = {}),
            (this.rpc_id = 0),
            (this.address = e),
            (this.autoconnect = t),
            (this.ready = !1),
            (this.reconnect = r),
            (this.reconnect_timer_id = void 0),
            (this.reconnect_interval = i),
            (this.max_reconnects = s),
            (this.rest_options = o),
            (this.current_reconnects = 0),
            (this.generate_request_id = a || (() => ++this.rpc_id)),
            c ? (this.dataPack = c) : (this.dataPack = new fU()),
            this.autoconnect &&
              this._connect(
                this.address,
                v(
                  {
                    autoconnect: this.autoconnect,
                    reconnect: this.reconnect,
                    reconnect_interval: this.reconnect_interval,
                    max_reconnects: this.max_reconnects,
                  },
                  this.rest_options
                )
              );
        }
        connect() {
          this.socket ||
            this._connect(
              this.address,
              v(
                {
                  autoconnect: this.autoconnect,
                  reconnect: this.reconnect,
                  reconnect_interval: this.reconnect_interval,
                  max_reconnects: this.max_reconnects,
                },
                this.rest_options
              )
            );
        }
        call(n, e, t, r) {
          return (
            !r && typeof t == "object" && ((r = t), (t = null)),
            new Promise((i, s) => {
              if (!this.ready) return s(new Error("socket not ready"));
              let o = this.generate_request_id(n, e),
                a = { jsonrpc: "2.0", method: n, params: e || void 0, id: o };
              this.socket.send(this.dataPack.encode(a), r, (c) => {
                if (c) return s(c);
                (this.queue[o] = { promise: [i, s] }),
                  t &&
                    (this.queue[o].timeout = setTimeout(() => {
                      delete this.queue[o], s(new Error("reply timeout"));
                    }, t));
              });
            })
          );
        }
        login(n) {
          return d(this, null, function* () {
            let e = yield this.call("rpc.login", n);
            if (!e) throw new Error("authentication failed");
            return e;
          });
        }
        listMethods() {
          return d(this, null, function* () {
            return yield this.call("__listMethods");
          });
        }
        notify(n, e) {
          return new Promise((t, r) => {
            if (!this.ready) return r(new Error("socket not ready"));
            let i = { jsonrpc: "2.0", method: n, params: e };
            this.socket.send(this.dataPack.encode(i), (s) => {
              if (s) return r(s);
              t();
            });
          });
        }
        subscribe(n) {
          return d(this, null, function* () {
            typeof n == "string" && (n = [n]);
            let e = yield this.call("rpc.on", n);
            if (typeof n == "string" && e[n] !== "ok")
              throw new Error(
                "Failed subscribing to an event '" + n + "' with: " + e[n]
              );
            return e;
          });
        }
        unsubscribe(n) {
          return d(this, null, function* () {
            typeof n == "string" && (n = [n]);
            let e = yield this.call("rpc.off", n);
            if (typeof n == "string" && e[n] !== "ok")
              throw new Error("Failed unsubscribing from an event with: " + e);
            return e;
          });
        }
        close(n, e) {
          this.socket.close(n || 1e3, e);
        }
        setAutoReconnect(n) {
          this.reconnect = n;
        }
        setReconnectInterval(n) {
          this.reconnect_interval = n;
        }
        setMaxReconnects(n) {
          this.max_reconnects = n;
        }
        _connect(n, e) {
          clearTimeout(this.reconnect_timer_id),
            (this.socket = this.webSocketFactory(n, e)),
            this.socket.addEventListener("open", () => {
              (this.ready = !0),
                this.emit("open"),
                (this.current_reconnects = 0);
            }),
            this.socket.addEventListener("message", ({ data: t }) => {
              t instanceof ArrayBuffer && (t = vk.Buffer.from(t).toString());
              try {
                t = this.dataPack.decode(t);
              } catch {
                return;
              }
              if (t.notification && this.listeners(t.notification).length) {
                if (!Object.keys(t.params).length)
                  return this.emit(t.notification);
                let r = [t.notification];
                if (t.params.constructor === Object) r.push(t.params);
                else
                  for (let i = 0; i < t.params.length; i++) r.push(t.params[i]);
                return Promise.resolve().then(() => {
                  this.emit.apply(this, r);
                });
              }
              if (!this.queue[t.id])
                return t.method
                  ? Promise.resolve().then(() => {
                      this.emit(t.method, t?.params);
                    })
                  : void 0;
              "error" in t == "result" in t &&
                this.queue[t.id].promise[1](
                  new Error(
                    'Server response malformed. Response must include either "result" or "error", but not both.'
                  )
                ),
                this.queue[t.id].timeout &&
                  clearTimeout(this.queue[t.id].timeout),
                t.error
                  ? this.queue[t.id].promise[1](t.error)
                  : this.queue[t.id].promise[0](t.result),
                delete this.queue[t.id];
            }),
            this.socket.addEventListener("error", (t) => this.emit("error", t)),
            this.socket.addEventListener("close", ({ code: t, reason: r }) => {
              this.ready && setTimeout(() => this.emit("close", t, r), 0),
                (this.ready = !1),
                (this.socket = void 0),
                t !== 1e3 &&
                  (this.current_reconnects++,
                  this.reconnect &&
                    (this.max_reconnects > this.current_reconnects ||
                      this.max_reconnects === 0) &&
                    (this.reconnect_timer_id = setTimeout(
                      () => this._connect(n, e),
                      this.reconnect_interval
                    )));
            });
        }
      });
  });
function dU(n, e = !1) {
  return e
    ? { h: Number(n & Dp), l: Number((n >> Tk) & Dp) }
    : { h: Number((n >> Tk) & Dp) | 0, l: Number(n & Dp) | 0 };
}
function Rk(n, e = !1) {
  let t = new Uint32Array(n.length),
    r = new Uint32Array(n.length);
  for (let i = 0; i < n.length; i++) {
    let { h: s, l: o } = dU(n[i], e);
    [t[i], r[i]] = [s, o];
  }
  return [t, r];
}
var Dp,
  Tk,
  Bk,
  Dk,
  _k,
  Pk,
  Lk = ot(() => {
    "use strict";
    p();
    (Dp = BigInt(4294967295)), (Tk = BigInt(32));
    (Bk = (n, e, t) => (n << t) | (e >>> (32 - t))),
      (Dk = (n, e, t) => (e << t) | (n >>> (32 - t))),
      (_k = (n, e, t) => (e << (t - 32)) | (n >>> (64 - t))),
      (Pk = (n, e, t) => (n << (t - 32)) | (e >>> (64 - t)));
  });
function EU(n, e = 24) {
  let t = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      t[o] = n[o] ^ n[o + 10] ^ n[o + 20] ^ n[o + 30] ^ n[o + 40];
    for (let o = 0; o < 10; o += 2) {
      let a = (o + 8) % 10,
        c = (o + 2) % 10,
        u = t[c],
        l = t[c + 1],
        h = Ok(u, l, 1) ^ t[a],
        f = Nk(u, l, 1) ^ t[a + 1];
      for (let g = 0; g < 50; g += 10) (n[o + g] ^= h), (n[o + g + 1] ^= f);
    }
    let i = n[2],
      s = n[3];
    for (let o = 0; o < 24; o++) {
      let a = Mk[o],
        c = Ok(i, s, a),
        u = Nk(i, s, a),
        l = Fk[o];
      (i = n[l]), (s = n[l + 1]), (n[l] = c), (n[l + 1] = u);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) t[a] = n[o + a];
      for (let a = 0; a < 10; a++)
        n[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    (n[0] ^= bU[r]), (n[1] ^= AU[r]);
  }
  t.fill(0);
}
var Fk,
  Mk,
  Uk,
  pU,
  Kl,
  gU,
  mU,
  yU,
  wU,
  bU,
  AU,
  Ok,
  Nk,
  _p,
  Fs,
  Cee,
  kee,
  Tee,
  Ree,
  Bee,
  Yw,
  Dee,
  _ee,
  zk,
  Pee,
  Lee,
  jk = ot(() => {
    "use strict";
    p();
    $d();
    Lk();
    qd();
    (Fk = []),
      (Mk = []),
      (Uk = []),
      (pU = BigInt(0)),
      (Kl = BigInt(1)),
      (gU = BigInt(2)),
      (mU = BigInt(7)),
      (yU = BigInt(256)),
      (wU = BigInt(113));
    for (let n = 0, e = Kl, t = 1, r = 0; n < 24; n++) {
      ([t, r] = [r, (2 * t + 3 * r) % 5]),
        Fk.push(2 * (5 * r + t)),
        Mk.push((((n + 1) * (n + 2)) / 2) % 64);
      let i = pU;
      for (let s = 0; s < 7; s++)
        (e = ((e << Kl) ^ ((e >> mU) * wU)) % yU),
          e & gU && (i ^= Kl << ((Kl << BigInt(s)) - Kl));
      Uk.push(i);
    }
    ([bU, AU] = Rk(Uk, !0)),
      (Ok = (n, e, t) => (t > 32 ? _k(n, e, t) : Bk(n, e, t))),
      (Nk = (n, e, t) => (t > 32 ? Pk(n, e, t) : Dk(n, e, t)));
    (_p = class n extends Dc {
      constructor(e, t, r, i = !1, s = 24) {
        if (
          (super(),
          (this.blockLen = e),
          (this.suffix = t),
          (this.outputLen = r),
          (this.enableXOF = i),
          (this.rounds = s),
          (this.pos = 0),
          (this.posOut = 0),
          (this.finished = !1),
          (this.destroyed = !1),
          yw(r),
          0 >= this.blockLen || this.blockLen >= 200)
        )
          throw new Error("Sha3 supports only keccak-f1600 function");
        (this.state = new Uint8Array(200)), (this.state32 = bC(this.state));
      }
      keccak() {
        ww || bw(this.state32),
          EU(this.state32, this.rounds),
          ww || bw(this.state32),
          (this.posOut = 0),
          (this.pos = 0);
      }
      update(e) {
        Bc(this);
        let { blockLen: t, state: r } = this;
        e = _c(e);
        let i = e.length;
        for (let s = 0; s < i; ) {
          let o = Math.min(t - this.pos, i - s);
          for (let a = 0; a < o; a++) r[this.pos++] ^= e[s++];
          this.pos === t && this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished) return;
        this.finished = !0;
        let { state: e, suffix: t, pos: r, blockLen: i } = this;
        (e[r] ^= t),
          t & 128 && r === i - 1 && this.keccak(),
          (e[i - 1] ^= 128),
          this.keccak();
      }
      writeInto(e) {
        Bc(this, !1), Ol(e), this.finish();
        let t = this.state,
          { blockLen: r } = this;
        for (let i = 0, s = e.length; i < s; ) {
          this.posOut >= r && this.keccak();
          let o = Math.min(r - this.posOut, s - i);
          e.set(t.subarray(this.posOut, this.posOut + o), i),
            (this.posOut += o),
            (i += o);
        }
        return e;
      }
      xofInto(e) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(e);
      }
      xof(e) {
        return yw(e), this.xofInto(new Uint8Array(e));
      }
      digestInto(e) {
        if ((Vd(e, this), this.finished))
          throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        (this.destroyed = !0), this.state.fill(0);
      }
      _cloneInto(e) {
        let {
          blockLen: t,
          suffix: r,
          outputLen: i,
          rounds: s,
          enableXOF: o,
        } = this;
        return (
          e || (e = new n(t, r, i, o, s)),
          e.state32.set(this.state32),
          (e.pos = this.pos),
          (e.posOut = this.posOut),
          (e.finished = this.finished),
          (e.rounds = s),
          (e.suffix = r),
          (e.outputLen = i),
          (e.enableXOF = o),
          (e.destroyed = this.destroyed),
          e
        );
      }
    }),
      (Fs = (n, e, t) => Kd(() => new _p(e, n, t))),
      (Cee = Fs(6, 144, 224 / 8)),
      (kee = Fs(6, 136, 256 / 8)),
      (Tee = Fs(6, 104, 384 / 8)),
      (Ree = Fs(6, 72, 512 / 8)),
      (Bee = Fs(1, 144, 224 / 8)),
      (Yw = Fs(1, 136, 256 / 8)),
      (Dee = Fs(1, 104, 384 / 8)),
      (_ee = Fs(1, 72, 512 / 8)),
      (zk = (n, e, t) =>
        AC((r = {}) => new _p(e, n, r.dkLen === void 0 ? t : r.dkLen, !0))),
      (Pee = zk(31, 168, 128 / 8)),
      (Lee = zk(31, 136, 256 / 8));
  });
var xU,
  Ms,
  Us,
  Zw,
  Wk,
  Hk = ot(() => {
    "use strict";
    p();
    $y();
    Do();
    (xU = new Uint32Array([
      1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
      2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
      1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
      264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
      2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
      113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
      1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
      3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
      430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
      1537002063, 1747873779, 1955562222, 104815, 2227730452, 2361852424,
      2428436474, 2756734187, 3204031479, 3329325298,
    ])),
      (Ms = new Uint32Array([
        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
        528734635, 1541459225,
      ])),
      (Us = new Uint32Array(64)),
      (Zw = class extends Ic {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = Ms[0] | 0),
            (this.B = Ms[1] | 0),
            (this.C = Ms[2] | 0),
            (this.D = Ms[3] | 0),
            (this.E = Ms[4] | 0),
            (this.F = Ms[5] | 0),
            (this.G = Ms[6] | 0),
            (this.H = Ms[7] | 0);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: s, F: o, G: a, H: c } = this;
          return [e, t, r, i, s, o, a, c];
        }
        set(e, t, r, i, s, o, a, c) {
          (this.A = e | 0),
            (this.B = t | 0),
            (this.C = r | 0),
            (this.D = i | 0),
            (this.E = s | 0),
            (this.F = o | 0),
            (this.G = a | 0),
            (this.H = c | 0);
        }
        process(e, t) {
          for (let h = 0; h < 16; h++, t += 4) Us[h] = e.getUint32(t, !1);
          for (let h = 16; h < 64; h++) {
            let f = Us[h - 15],
              g = Us[h - 2],
              y = Lr(f, 7) ^ Lr(f, 18) ^ (f >>> 3),
              w = Lr(g, 17) ^ Lr(g, 19) ^ (g >>> 10);
            Us[h] = (w + Us[h - 7] + y + Us[h - 16]) | 0;
          }
          let { A: r, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
          for (let h = 0; h < 64; h++) {
            let f = Lr(a, 6) ^ Lr(a, 11) ^ Lr(a, 25),
              g = (l + f + PI(a, c, u) + xU[h] + Us[h]) | 0,
              w = ((Lr(r, 2) ^ Lr(r, 13) ^ Lr(r, 22)) + LI(r, i, s)) | 0;
            (l = u),
              (u = c),
              (c = a),
              (a = (o + g) | 0),
              (o = s),
              (s = i),
              (i = r),
              (r = (g + w) | 0);
          }
          (r = (r + this.A) | 0),
            (i = (i + this.B) | 0),
            (s = (s + this.C) | 0),
            (o = (o + this.D) | 0),
            (a = (a + this.E) | 0),
            (c = (c + this.F) | 0),
            (u = (u + this.G) | 0),
            (l = (l + this.H) | 0),
            this.set(r, i, s, o, a, c, u, l);
        }
        roundClean() {
          Us.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }),
      (Wk = Td(() => new Zw()));
  });
var Pp,
  Xw,
  Vk = ot(() => {
    "use strict";
    p();
    Cd();
    Do();
    (Pp = class extends vc {
      constructor(e, t) {
        super(), (this.finished = !1), (this.destroyed = !1), RI(e);
        let r = Dl(t);
        if (((this.iHash = e.create()), typeof this.iHash.update != "function"))
          throw new Error(
            "Expected instance of class which extends utils.Hash"
          );
        (this.blockLen = this.iHash.blockLen),
          (this.outputLen = this.iHash.outputLen);
        let i = this.blockLen,
          s = new Uint8Array(i);
        s.set(r.length > i ? e.create().update(r).digest() : r);
        for (let o = 0; o < s.length; o++) s[o] ^= 54;
        this.iHash.update(s), (this.oHash = e.create());
        for (let o = 0; o < s.length; o++) s[o] ^= 106;
        this.oHash.update(s), s.fill(0);
      }
      update(e) {
        return Sc(this), this.iHash.update(e), this;
      }
      digestInto(e) {
        Sc(this),
          xc(e, this.outputLen),
          (this.finished = !0),
          this.iHash.digestInto(e),
          this.oHash.update(e),
          this.oHash.digestInto(e),
          this.destroy();
      }
      digest() {
        let e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
      }
      _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        let {
          oHash: t,
          iHash: r,
          finished: i,
          destroyed: s,
          blockLen: o,
          outputLen: a,
        } = this;
        return (
          (e = e),
          (e.finished = i),
          (e.destroyed = s),
          (e.blockLen = o),
          (e.outputLen = a),
          (e.oHash = t._cloneInto(e.oHash)),
          (e.iHash = r._cloneInto(e.iHash)),
          e
        );
      }
      destroy() {
        (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
      }
    }),
      (Xw = (n, e, t) => new Pp(n, e).update(t).digest());
    Xw.create = (n, e) => new Pp(n, e);
  });
function $k(n) {
  n.lowS !== void 0 && Or("lowS", n.lowS),
    n.prehash !== void 0 && Or("prehash", n.prehash);
}
function SU(n) {
  let e = Ll(n);
  Yr(
    e,
    { a: "field", b: "field" },
    {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function",
    }
  );
  let { endo: t, Fp: r, a: i } = e;
  if (t) {
    if (!r.eql(i, r.ZERO))
      throw new Error(
        "invalid endomorphism, can only be defined for Koblitz curves that have a=0"
      );
    if (
      typeof t != "object" ||
      typeof t.beta != "bigint" ||
      typeof t.splitScalar != "function"
    )
      throw new Error(
        "invalid endomorphism, expected beta: bigint and splitScalar: function"
      );
  }
  return Object.freeze(v({}, e));
}
function CU(n) {
  let e = SU(n),
    { Fp: t } = e,
    r = Bs(e.n, e.nBitLength),
    i =
      e.toBytes ||
      ((w, m, b) => {
        let I = m.toAffine();
        return Oi(Uint8Array.from([4]), t.toBytes(I.x), t.toBytes(I.y));
      }),
    s =
      e.fromBytes ||
      ((w) => {
        let m = w.subarray(1),
          b = t.fromBytes(m.subarray(0, t.BYTES)),
          I = t.fromBytes(m.subarray(t.BYTES, 2 * t.BYTES));
        return { x: b, y: I };
      });
  function o(w) {
    let { a: m, b } = e,
      I = t.sqr(w),
      E = t.mul(I, w);
    return t.add(t.add(E, t.mul(w, m)), b);
  }
  if (!t.eql(t.sqr(e.Gy), o(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(w) {
    return _l(w, Yt, e.n);
  }
  function c(w) {
    let {
      allowedPrivateKeyLengths: m,
      nByteLength: b,
      wrapPrivateKey: I,
      n: E,
    } = e;
    if (m && typeof w != "bigint") {
      if ((ks(w) && (w = Pi(w)), typeof w != "string" || !m.includes(w.length)))
        throw new Error("invalid private key");
      w = w.padStart(b * 2, "0");
    }
    let T;
    try {
      T = typeof w == "bigint" ? w : Li(St("private key", w, b));
    } catch {
      throw new Error(
        "invalid private key, expected hex or " + b + " bytes, got " + typeof w
      );
    }
    return I && (T = it(T, E)), Fn("private key", T, Yt, E), T;
  }
  function u(w) {
    if (!(w instanceof f)) throw new Error("ProjectivePoint expected");
  }
  let l = Oo((w, m) => {
      let { px: b, py: I, pz: E } = w;
      if (t.eql(E, t.ONE)) return { x: b, y: I };
      let T = w.is0();
      m == null && (m = T ? t.ONE : t.inv(E));
      let B = t.mul(b, m),
        L = t.mul(I, m),
        U = t.mul(E, m);
      if (T) return { x: t.ZERO, y: t.ZERO };
      if (!t.eql(U, t.ONE)) throw new Error("invZ was invalid");
      return { x: B, y: L };
    }),
    h = Oo((w) => {
      if (w.is0()) {
        if (e.allowInfinityPoint && !t.is0(w.py)) return;
        throw new Error("bad point: ZERO");
      }
      let { x: m, y: b } = w.toAffine();
      if (!t.isValid(m) || !t.isValid(b))
        throw new Error("bad point: x or y not FE");
      let I = t.sqr(b),
        E = o(m);
      if (!t.eql(I, E)) throw new Error("bad point: equation left != right");
      if (!w.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return !0;
    });
  class f {
    constructor(m, b, I) {
      if (
        ((this.px = m),
        (this.py = b),
        (this.pz = I),
        m == null || !t.isValid(m))
      )
        throw new Error("x required");
      if (b == null || !t.isValid(b)) throw new Error("y required");
      if (I == null || !t.isValid(I)) throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(m) {
      let { x: b, y: I } = m || {};
      if (!m || !t.isValid(b) || !t.isValid(I))
        throw new Error("invalid affine point");
      if (m instanceof f) throw new Error("projective point not allowed");
      let E = (T) => t.eql(T, t.ZERO);
      return E(b) && E(I) ? f.ZERO : new f(b, I, t.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(m) {
      let b = t.invertBatch(m.map((I) => I.pz));
      return m.map((I, E) => I.toAffine(b[E])).map(f.fromAffine);
    }
    static fromHex(m) {
      let b = f.fromAffine(s(St("pointHex", m)));
      return b.assertValidity(), b;
    }
    static fromPrivateKey(m) {
      return f.BASE.multiply(c(m));
    }
    static msm(m, b) {
      return Fd(f, r, m, b);
    }
    _setWindowSize(m) {
      y.setWindowSize(this, m);
    }
    assertValidity() {
      h(this);
    }
    hasEvenY() {
      let { y: m } = this.toAffine();
      if (t.isOdd) return !t.isOdd(m);
      throw new Error("Field doesn't support isOdd");
    }
    equals(m) {
      u(m);
      let { px: b, py: I, pz: E } = this,
        { px: T, py: B, pz: L } = m,
        U = t.eql(t.mul(b, L), t.mul(T, E)),
        j = t.eql(t.mul(I, L), t.mul(B, E));
      return U && j;
    }
    negate() {
      return new f(this.px, t.neg(this.py), this.pz);
    }
    double() {
      let { a: m, b } = e,
        I = t.mul(b, Gk),
        { px: E, py: T, pz: B } = this,
        L = t.ZERO,
        U = t.ZERO,
        j = t.ZERO,
        W = t.mul(E, E),
        be = t.mul(T, T),
        pe = t.mul(B, B),
        ge = t.mul(E, T);
      return (
        (ge = t.add(ge, ge)),
        (j = t.mul(E, B)),
        (j = t.add(j, j)),
        (L = t.mul(m, j)),
        (U = t.mul(I, pe)),
        (U = t.add(L, U)),
        (L = t.sub(be, U)),
        (U = t.add(be, U)),
        (U = t.mul(L, U)),
        (L = t.mul(ge, L)),
        (j = t.mul(I, j)),
        (pe = t.mul(m, pe)),
        (ge = t.sub(W, pe)),
        (ge = t.mul(m, ge)),
        (ge = t.add(ge, j)),
        (j = t.add(W, W)),
        (W = t.add(j, W)),
        (W = t.add(W, pe)),
        (W = t.mul(W, ge)),
        (U = t.add(U, W)),
        (pe = t.mul(T, B)),
        (pe = t.add(pe, pe)),
        (W = t.mul(pe, ge)),
        (L = t.sub(L, W)),
        (j = t.mul(pe, be)),
        (j = t.add(j, j)),
        (j = t.add(j, j)),
        new f(L, U, j)
      );
    }
    add(m) {
      u(m);
      let { px: b, py: I, pz: E } = this,
        { px: T, py: B, pz: L } = m,
        U = t.ZERO,
        j = t.ZERO,
        W = t.ZERO,
        be = e.a,
        pe = t.mul(e.b, Gk),
        ge = t.mul(b, T),
        _e = t.mul(I, B),
        X = t.mul(E, L),
        q = t.add(b, I),
        F = t.add(T, B);
      (q = t.mul(q, F)),
        (F = t.add(ge, _e)),
        (q = t.sub(q, F)),
        (F = t.add(b, E));
      let O = t.add(T, L);
      return (
        (F = t.mul(F, O)),
        (O = t.add(ge, X)),
        (F = t.sub(F, O)),
        (O = t.add(I, E)),
        (U = t.add(B, L)),
        (O = t.mul(O, U)),
        (U = t.add(_e, X)),
        (O = t.sub(O, U)),
        (W = t.mul(be, F)),
        (U = t.mul(pe, X)),
        (W = t.add(U, W)),
        (U = t.sub(_e, W)),
        (W = t.add(_e, W)),
        (j = t.mul(U, W)),
        (_e = t.add(ge, ge)),
        (_e = t.add(_e, ge)),
        (X = t.mul(be, X)),
        (F = t.mul(pe, F)),
        (_e = t.add(_e, X)),
        (X = t.sub(ge, X)),
        (X = t.mul(be, X)),
        (F = t.add(F, X)),
        (ge = t.mul(_e, F)),
        (j = t.add(j, ge)),
        (ge = t.mul(O, F)),
        (U = t.mul(q, U)),
        (U = t.sub(U, ge)),
        (ge = t.mul(q, _e)),
        (W = t.mul(O, W)),
        (W = t.add(W, ge)),
        new f(U, j, W)
      );
    }
    subtract(m) {
      return this.add(m.negate());
    }
    is0() {
      return this.equals(f.ZERO);
    }
    wNAF(m) {
      return y.wNAFCached(this, m, f.normalizeZ);
    }
    multiplyUnsafe(m) {
      let { endo: b, n: I } = e;
      Fn("scalar", m, Wi, I);
      let E = f.ZERO;
      if (m === Wi) return E;
      if (this.is0() || m === Yt) return this;
      if (!b || y.hasPrecomputes(this))
        return y.wNAFCachedUnsafe(this, m, f.normalizeZ);
      let { k1neg: T, k1: B, k2neg: L, k2: U } = b.splitScalar(m),
        j = E,
        W = E,
        be = this;
      for (; B > Wi || U > Wi; )
        B & Yt && (j = j.add(be)),
          U & Yt && (W = W.add(be)),
          (be = be.double()),
          (B >>= Yt),
          (U >>= Yt);
      return (
        T && (j = j.negate()),
        L && (W = W.negate()),
        (W = new f(t.mul(W.px, b.beta), W.py, W.pz)),
        j.add(W)
      );
    }
    multiply(m) {
      let { endo: b, n: I } = e;
      Fn("scalar", m, Yt, I);
      let E, T;
      if (b) {
        let { k1neg: B, k1: L, k2neg: U, k2: j } = b.splitScalar(m),
          { p: W, f: be } = this.wNAF(L),
          { p: pe, f: ge } = this.wNAF(j);
        (W = y.constTimeNegate(B, W)),
          (pe = y.constTimeNegate(U, pe)),
          (pe = new f(t.mul(pe.px, b.beta), pe.py, pe.pz)),
          (E = W.add(pe)),
          (T = be.add(ge));
      } else {
        let { p: B, f: L } = this.wNAF(m);
        (E = B), (T = L);
      }
      return f.normalizeZ([E, T])[0];
    }
    multiplyAndAddUnsafe(m, b, I) {
      let E = f.BASE,
        T = (L, U) =>
          U === Wi || U === Yt || !L.equals(E)
            ? L.multiplyUnsafe(U)
            : L.multiply(U),
        B = T(this, b).add(T(m, I));
      return B.is0() ? void 0 : B;
    }
    toAffine(m) {
      return l(this, m);
    }
    isTorsionFree() {
      let { h: m, isTorsionFree: b } = e;
      if (m === Yt) return !0;
      if (b) return b(f, this);
      throw new Error(
        "isTorsionFree() has not been declared for the elliptic curve"
      );
    }
    clearCofactor() {
      let { h: m, clearCofactor: b } = e;
      return m === Yt ? this : b ? b(f, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(m = !0) {
      return Or("isCompressed", m), this.assertValidity(), i(f, this, m);
    }
    toHex(m = !0) {
      return Or("isCompressed", m), Pi(this.toRawBytes(m));
    }
  }
  (f.BASE = new f(e.Gx, e.Gy, t.ONE)), (f.ZERO = new f(t.ZERO, t.ONE, t.ZERO));
  let g = e.nBitLength,
    y = Nd(f, e.endo ? Math.ceil(g / 2) : g);
  return {
    CURVE: e,
    ProjectivePoint: f,
    normPrivateKeyToScalar: c,
    weierstrassEquation: o,
    isWithinCurveOrder: a,
  };
}
function kU(n) {
  let e = Ll(n);
  return (
    Yr(
      e,
      { hash: "hash", hmac: "function", randomBytes: "function" },
      { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
    ),
    Object.freeze(v({ lowS: !0 }, e))
  );
}
function Kk(n) {
  let e = kU(n),
    { Fp: t, n: r } = e,
    i = t.BYTES + 1,
    s = 2 * t.BYTES + 1;
  function o(X) {
    return it(X, r);
  }
  function a(X) {
    return Ld(X, r);
  }
  let {
      ProjectivePoint: c,
      normPrivateKeyToScalar: u,
      weierstrassEquation: l,
      isWithinCurveOrder: h,
    } = CU(
      $(v({}, e), {
        toBytes(X, q, F) {
          let O = q.toAffine(),
            K = t.toBytes(O.x),
            H = Oi;
          return (
            Or("isCompressed", F),
            F
              ? H(Uint8Array.from([q.hasEvenY() ? 2 : 3]), K)
              : H(Uint8Array.from([4]), K, t.toBytes(O.y))
          );
        },
        fromBytes(X) {
          let q = X.length,
            F = X[0],
            O = X.subarray(1);
          if (q === i && (F === 2 || F === 3)) {
            let K = Li(O);
            if (!_l(K, Yt, t.ORDER)) throw new Error("Point is not on curve");
            let H = l(K),
              he;
            try {
              he = t.sqrt(H);
            } catch (Pe) {
              let ye = Pe instanceof Error ? ": " + Pe.message : "";
              throw new Error("Point is not on curve" + ye);
            }
            let Ee = (he & Yt) === Yt;
            return ((F & 1) === 1) !== Ee && (he = t.neg(he)), { x: K, y: he };
          } else if (q === s && F === 4) {
            let K = t.fromBytes(O.subarray(0, t.BYTES)),
              H = t.fromBytes(O.subarray(t.BYTES, 2 * t.BYTES));
            return { x: K, y: H };
          } else {
            let K = i,
              H = s;
            throw new Error(
              "invalid Point, expected length of " +
                K +
                ", or uncompressed " +
                H +
                ", got " +
                q
            );
          }
        },
      })
    ),
    f = (X) => Pi(Rs(X, e.nByteLength));
  function g(X) {
    let q = r >> Yt;
    return X > q;
  }
  function y(X) {
    return g(X) ? o(-X) : X;
  }
  let w = (X, q, F) => Li(X.slice(q, F));
  class m {
    constructor(q, F, O) {
      (this.r = q), (this.s = F), (this.recovery = O), this.assertValidity();
    }
    static fromCompact(q) {
      let F = e.nByteLength;
      return (
        (q = St("compactSignature", q, F * 2)),
        new m(w(q, 0, F), w(q, F, 2 * F))
      );
    }
    static fromDER(q) {
      let { r: F, s: O } = ji.toSig(St("DER", q));
      return new m(F, O);
    }
    assertValidity() {
      Fn("r", this.r, Yt, r), Fn("s", this.s, Yt, r);
    }
    addRecoveryBit(q) {
      return new m(this.r, this.s, q);
    }
    recoverPublicKey(q) {
      let { r: F, s: O, recovery: K } = this,
        H = L(St("msgHash", q));
      if (K == null || ![0, 1, 2, 3].includes(K))
        throw new Error("recovery id invalid");
      let he = K === 2 || K === 3 ? F + e.n : F;
      if (he >= t.ORDER) throw new Error("recovery id 2 or 3 invalid");
      let Ee = K & 1 ? "03" : "02",
        Se = c.fromHex(Ee + f(he)),
        Pe = a(he),
        ye = o(-H * Pe),
        ze = o(O * Pe),
        nt = c.BASE.multiplyAndAddUnsafe(Se, ye, ze);
      if (!nt) throw new Error("point at infinify");
      return nt.assertValidity(), nt;
    }
    hasHighS() {
      return g(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new m(this.r, o(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return Po(this.toDERHex());
    }
    toDERHex() {
      return ji.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return Po(this.toCompactHex());
    }
    toCompactHex() {
      return f(this.r) + f(this.s);
    }
  }
  let b = {
    isValidPrivateKey(X) {
      try {
        return u(X), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: u,
    randomPrivateKey: () => {
      let X = nw(e.n);
      return $I(e.randomBytes(X), e.n);
    },
    precompute(X = 8, q = c.BASE) {
      return q._setWindowSize(X), q.multiply(BigInt(3)), q;
    },
  };
  function I(X, q = !0) {
    return c.fromPrivateKey(X).toRawBytes(q);
  }
  function E(X) {
    let q = ks(X),
      F = typeof X == "string",
      O = (q || F) && X.length;
    return q
      ? O === i || O === s
      : F
      ? O === 2 * i || O === 2 * s
      : X instanceof c;
  }
  function T(X, q, F = !0) {
    if (E(X)) throw new Error("first arg must be private key");
    if (!E(q)) throw new Error("second arg must be public key");
    return c.fromHex(q).multiply(u(X)).toRawBytes(F);
  }
  let B =
      e.bits2int ||
      function (X) {
        if (X.length > 8192) throw new Error("input is too large");
        let q = Li(X),
          F = X.length * 8 - e.nBitLength;
        return F > 0 ? q >> BigInt(F) : q;
      },
    L =
      e.bits2int_modN ||
      function (X) {
        return o(B(X));
      },
    U = Pl(e.nBitLength);
  function j(X) {
    return Fn("num < 2^" + e.nBitLength, X, Wi, U), Rs(X, e.nByteLength);
  }
  function W(X, q, F = be) {
    if (["recovered", "canonical"].some((Ht) => Ht in F))
      throw new Error("sign() legacy options not supported");
    let { hash: O, randomBytes: K } = e,
      { lowS: H, prehash: he, extraEntropy: Ee } = F;
    H == null && (H = !0),
      (X = St("msgHash", X)),
      $k(F),
      he && (X = St("prehashed msgHash", O(X)));
    let Se = L(X),
      Pe = u(q),
      ye = [j(Pe), j(Se)];
    if (Ee != null && Ee !== !1) {
      let Ht = Ee === !0 ? K(t.BYTES) : Ee;
      ye.push(St("extraEntropy", Ht));
    }
    let ze = Oi(...ye),
      nt = Se;
    function Wt(Ht) {
      let nn = B(Ht);
      if (!h(nn)) return;
      let un = a(nn),
        Dn = c.BASE.multiply(nn).toAffine(),
        En = o(Dn.x);
      if (En === Wi) return;
      let jr = o(un * o(nt + En * Pe));
      if (jr === Wi) return;
      let di = (Dn.x === En ? 0 : 2) | Number(Dn.y & Yt),
        Au = jr;
      return H && g(jr) && ((Au = y(jr)), (di ^= 1)), new m(En, Au, di);
    }
    return { seed: ze, k2sig: Wt };
  }
  let be = { lowS: e.lowS, prehash: !1 },
    pe = { lowS: e.lowS, prehash: !1 };
  function ge(X, q, F = be) {
    let { seed: O, k2sig: K } = W(X, q, F),
      H = e;
    return Zy(H.hash.outputLen, H.nByteLength, H.hmac)(O, K);
  }
  c.BASE._setWindowSize(8);
  function _e(X, q, F, O = pe) {
    let K = X;
    (q = St("msgHash", q)), (F = St("publicKey", F));
    let { lowS: H, prehash: he, format: Ee } = O;
    if (($k(O), "strict" in O))
      throw new Error("options.strict was renamed to lowS");
    if (Ee !== void 0 && Ee !== "compact" && Ee !== "der")
      throw new Error("format must be compact or der");
    let Se = typeof K == "string" || ks(K),
      Pe =
        !Se &&
        !Ee &&
        typeof K == "object" &&
        K !== null &&
        typeof K.r == "bigint" &&
        typeof K.s == "bigint";
    if (!Se && !Pe)
      throw new Error(
        "invalid signature, expected Uint8Array, hex string or Signature instance"
      );
    let ye, ze;
    try {
      if ((Pe && (ye = new m(K.r, K.s)), Se)) {
        try {
          Ee !== "compact" && (ye = m.fromDER(K));
        } catch (di) {
          if (!(di instanceof ji.Err)) throw di;
        }
        !ye && Ee !== "der" && (ye = m.fromCompact(K));
      }
      ze = c.fromHex(F);
    } catch {
      return !1;
    }
    if (!ye || (H && ye.hasHighS())) return !1;
    he && (q = e.hash(q));
    let { r: nt, s: Wt } = ye,
      Ht = L(q),
      nn = a(Wt),
      un = o(Ht * nn),
      Dn = o(nt * nn),
      En = c.BASE.multiplyAndAddUnsafe(ze, un, Dn)?.toAffine();
    return En ? o(En.x) === nt : !1;
  }
  return {
    CURVE: e,
    getPublicKey: I,
    getSharedSecret: T,
    sign: ge,
    verify: _e,
    ProjectivePoint: c,
    Signature: m,
    utils: b,
  };
}
var vU,
  IU,
  ji,
  Wi,
  Yt,
  qee,
  Gk,
  Qee,
  qk = ot(() => {
    "use strict";
    p();
    aw();
    kc();
    No();
    No();
    ({ bytesToNumberBE: vU, hexToBytes: IU } = Pd),
      (ji = {
        Err: class extends Error {
          constructor(e = "") {
            super(e);
          }
        },
        _tlv: {
          encode: (n, e) => {
            let { Err: t } = ji;
            if (n < 0 || n > 256) throw new t("tlv.encode: wrong tag");
            if (e.length & 1) throw new t("tlv.encode: unpadded data");
            let r = e.length / 2,
              i = _o(r);
            if ((i.length / 2) & 128)
              throw new t("tlv.encode: long form length too big");
            let s = r > 127 ? _o((i.length / 2) | 128) : "";
            return _o(n) + s + i + e;
          },
          decode(n, e) {
            let { Err: t } = ji,
              r = 0;
            if (n < 0 || n > 256) throw new t("tlv.encode: wrong tag");
            if (e.length < 2 || e[r++] !== n)
              throw new t("tlv.decode: wrong tlv");
            let i = e[r++],
              s = !!(i & 128),
              o = 0;
            if (!s) o = i;
            else {
              let c = i & 127;
              if (!c)
                throw new t(
                  "tlv.decode(long): indefinite length not supported"
                );
              if (c > 4)
                throw new t("tlv.decode(long): byte length is too big");
              let u = e.subarray(r, r + c);
              if (u.length !== c)
                throw new t("tlv.decode: length bytes not complete");
              if (u[0] === 0)
                throw new t("tlv.decode(long): zero leftmost byte");
              for (let l of u) o = (o << 8) | l;
              if (((r += c), o < 128))
                throw new t("tlv.decode(long): not minimal encoding");
            }
            let a = e.subarray(r, r + o);
            if (a.length !== o) throw new t("tlv.decode: wrong value length");
            return { v: a, l: e.subarray(r + o) };
          },
        },
        _int: {
          encode(n) {
            let { Err: e } = ji;
            if (n < Wi)
              throw new e("integer: negative integers are not allowed");
            let t = _o(n);
            if ((Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1))
              throw new e("unexpected DER parsing assertion: unpadded hex");
            return t;
          },
          decode(n) {
            let { Err: e } = ji;
            if (n[0] & 128) throw new e("invalid signature integer: negative");
            if (n[0] === 0 && !(n[1] & 128))
              throw new e(
                "invalid signature integer: unnecessary leading zero"
              );
            return vU(n);
          },
        },
        toSig(n) {
          let { Err: e, _int: t, _tlv: r } = ji,
            i = typeof n == "string" ? IU(n) : n;
          Cc(i);
          let { v: s, l: o } = r.decode(48, i);
          if (o.length)
            throw new e("invalid signature: left bytes after parsing");
          let { v: a, l: c } = r.decode(2, s),
            { v: u, l } = r.decode(2, c);
          if (l.length)
            throw new e("invalid signature: left bytes after parsing");
          return { r: t.decode(a), s: t.decode(u) };
        },
        hexFromSig(n) {
          let { _tlv: e, _int: t } = ji,
            r = e.encode(2, t.encode(n.r)),
            i = e.encode(2, t.encode(n.s)),
            s = r + i;
          return e.encode(48, s);
        },
      }),
      (Wi = BigInt(0)),
      (Yt = BigInt(1)),
      (qee = BigInt(2)),
      (Gk = BigInt(3)),
      (Qee = BigInt(4));
  });
function TU(n) {
  return { hash: n, hmac: (e, ...t) => Xw(n, e, Vy(...t)), randomBytes: Rd };
}
function Qk(n, e) {
  let t = (r) => Kk(v(v({}, n), TU(r)));
  return Object.freeze($(v({}, t(e)), { create: t }));
}
var Jk = ot(() => {
  "use strict";
  p();
  Vk();
  Do();
  qk();
});
function BU(n) {
  let e = Xk,
    t = BigInt(3),
    r = BigInt(6),
    i = BigInt(11),
    s = BigInt(22),
    o = BigInt(23),
    a = BigInt(44),
    c = BigInt(88),
    u = (n * n * n) % e,
    l = (u * u * n) % e,
    h = (wt(l, t, e) * l) % e,
    f = (wt(h, t, e) * l) % e,
    g = (wt(f, eb, e) * u) % e,
    y = (wt(g, i, e) * g) % e,
    w = (wt(y, s, e) * y) % e,
    m = (wt(w, a, e) * w) % e,
    b = (wt(m, c, e) * m) % e,
    I = (wt(b, a, e) * w) % e,
    E = (wt(I, t, e) * l) % e,
    T = (wt(E, o, e) * y) % e,
    B = (wt(T, r, e) * u) % e,
    L = wt(B, eb, e);
  if (!tb.eql(tb.sqr(L), n)) throw new Error("Cannot find square root");
  return L;
}
var Xk,
  Yk,
  RU,
  eb,
  Zk,
  tb,
  ql,
  cte,
  ute,
  e2 = ot(() => {
    "use strict";
    p();
    Hk();
    Jk();
    kc();
    (Xk = BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
    )),
      (Yk = BigInt(
        "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
      )),
      (RU = BigInt(1)),
      (eb = BigInt(2)),
      (Zk = (n, e) => (n + e / eb) / e);
    (tb = Bs(Xk, void 0, void 0, { sqrt: BU })),
      (ql = Qk(
        {
          a: BigInt(0),
          b: BigInt(7),
          Fp: tb,
          n: Yk,
          Gx: BigInt(
            "55066263022277343669578718895168534326250603453777594175500187360389116729240"
          ),
          Gy: BigInt(
            "32670510020758816978083085130507043184471273380659243275938904335757337482424"
          ),
          h: BigInt(1),
          lowS: !0,
          endo: {
            beta: BigInt(
              "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
            ),
            splitScalar: (n) => {
              let e = Yk,
                t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                r = -RU * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                s = t,
                o = BigInt("0x100000000000000000000000000000000"),
                a = Zk(s * n, e),
                c = Zk(-r * n, e),
                u = it(n - a * t - c * i, e),
                l = it(-a * r - c * s, e),
                h = u > o,
                f = l > o;
              if ((h && (u = e - u), f && (l = e - l), u > o || l > o))
                throw new Error("splitScalar: Endomorphism failed, k=" + n);
              return { k1neg: h, k1: u, k2neg: f, k2: l };
            },
          },
        },
        Wk
      )),
      (cte = BigInt(0)),
      (ute = ql.ProjectivePoint);
  });
var U6 = {};
Vg(U6, {
  Account: () => lb,
  AddressLookupTableAccount: () => eh,
  AddressLookupTableInstruction: () => Ab,
  AddressLookupTableProgram: () => nh,
  Authorized: () => Gp,
  BLOCKHASH_CACHE_TIMEOUT_MS: () => R2,
  BPF_LOADER_DEPRECATED_PROGRAM_ID: () => LU,
  BPF_LOADER_PROGRAM_ID: () => XU,
  BpfLoader: () => gb,
  COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => oi,
  ComputeBudgetInstruction: () => Eb,
  ComputeBudgetProgram: () => rh,
  Connection: () => Jc,
  Ed25519Program: () => Vp,
  Enum: () => ub,
  EpochSchedule: () => jp,
  FeeCalculatorLayout: () => C2,
  Keypair: () => Hp,
  LAMPORTS_PER_SOL: () => M6,
  LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => Vi,
  Loader: () => pb,
  Lockup: () => Zo,
  MAX_SEED_LENGTH: () => x2,
  Message: () => ui,
  MessageAccountKeys: () => Jo,
  MessageV0: () => Kc,
  NONCE_ACCOUNT_LENGTH: () => fb,
  NonceAccount: () => zp,
  PACKET_DATA_SIZE: () => js,
  PUBLIC_KEY_LENGTH: () => ci,
  PublicKey: () => J,
  SIGNATURE_LENGTH_IN_BYTES: () => Qo,
  SOLANA_SCHEMA: () => Jl,
  STAKE_CONFIG_ID: () => z2,
  STAKE_INSTRUCTION_LAYOUTS: () => Zt,
  SYSTEM_INSTRUCTION_LAYOUTS: () => ft,
  SYSVAR_CLOCK_PUBKEY: () => ii,
  SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => VU,
  SYSVAR_INSTRUCTIONS_PUBKEY: () => $U,
  SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => Op,
  SYSVAR_RENT_PUBKEY: () => qc,
  SYSVAR_REWARDS_PUBKEY: () => GU,
  SYSVAR_SLOT_HASHES_PUBKEY: () => KU,
  SYSVAR_SLOT_HISTORY_PUBKEY: () => qU,
  SYSVAR_STAKE_HISTORY_PUBKEY: () => Np,
  Secp256k1Program: () => $p,
  SendTransactionError: () => Yo,
  SolanaJSONRPCError: () => ce,
  SolanaJSONRPCErrorCode: () => QU,
  StakeAuthorizationLayout: () => R6,
  StakeInstruction: () => xb,
  StakeProgram: () => Yc,
  Struct: () => Yl,
  SystemInstruction: () => db,
  SystemProgram: () => an,
  Transaction: () => Ne,
  TransactionExpiredBlockheightExceededError: () => Zl,
  TransactionExpiredNonceInvalidError: () => zs,
  TransactionExpiredTimeoutError: () => Xl,
  TransactionInstruction: () => tt,
  TransactionMessage: () => Up,
  TransactionStatus: () => Hi,
  VALIDATOR_INFO_KEY: () => j2,
  VERSION_PREFIX_MASK: () => qp,
  VOTE_PROGRAM_ID: () => _6,
  ValidatorInfo: () => vb,
  VersionedMessage: () => sh,
  VersionedTransaction: () => $i,
  VoteAccount: () => Ib,
  VoteAuthorizationLayout: () => B6,
  VoteInit: () => Kp,
  VoteInstruction: () => Sb,
  VoteProgram: () => Zc,
  clusterApiUrl: () => N6,
  sendAndConfirmRawTransaction: () => F6,
  sendAndConfirmTransaction: () => hb,
});
function n2(n) {
  try {
    return Mo.ExtendedPoint.fromHex(n), !0;
  } catch {
    return !1;
  }
}
function PU(n) {
  return n._bn !== void 0;
}
function S2(n, e) {
  let t = (i) => {
      if (i.span >= 0) return i.span;
      if (typeof i.alloc == "function") return i.alloc(e[i.property]);
      if ("count" in i && "elementLayout" in i) {
        let s = e[i.property];
        if (Array.isArray(s)) return s.length * t(i.elementLayout);
      } else if ("fields" in i) return S2({ layout: i }, e[i.property]);
      return 0;
    },
    r = 0;
  return (
    n.layout.fields.forEach((i) => {
      r += t(i);
    }),
    r
  );
}
function Hn(n) {
  let e = 0,
    t = 0;
  for (;;) {
    let r = n.shift();
    if (((e |= (r & 127) << (t * 7)), (t += 1), !(r & 128))) break;
  }
  return e;
}
function tr(n, e) {
  let t = e;
  for (;;) {
    let r = t & 127;
    if (((t >>= 7), t == 0)) {
      n.push(r);
      break;
    } else (r |= 128), n.push(r);
  }
}
function Ve(n, e) {
  if (!n) throw new Error(e || "Assertion failed");
}
function si(n) {
  if (n.length === 0) throw new Error(v2);
  return n.shift();
}
function Vn(n, ...e) {
  let [t] = e;
  if (e.length === 2 ? t + (e[1] ?? 0) > n.length : t >= n.length)
    throw new Error(v2);
  return n.splice(...e);
}
function hb(n, e, t, r) {
  return d(this, null, function* () {
    let i = r && {
        skipPreflight: r.skipPreflight,
        preflightCommitment: r.preflightCommitment || r.commitment,
        maxRetries: r.maxRetries,
        minContextSlot: r.minContextSlot,
      },
      s = yield n.sendTransaction(e, t, i),
      o;
    if (e.recentBlockhash != null && e.lastValidBlockHeight != null)
      o = (yield n.confirmTransaction(
        {
          abortSignal: r?.abortSignal,
          signature: s,
          blockhash: e.recentBlockhash,
          lastValidBlockHeight: e.lastValidBlockHeight,
        },
        r && r.commitment
      )).value;
    else if (e.minNonceContextSlot != null && e.nonceInfo != null) {
      let { nonceInstruction: a } = e.nonceInfo,
        c = a.keys[0].pubkey;
      o = (yield n.confirmTransaction(
        {
          abortSignal: r?.abortSignal,
          minContextSlot: e.minNonceContextSlot,
          nonceAccountPubkey: c,
          nonceValue: e.nonceInfo.nonce,
          signature: s,
        },
        r && r.commitment
      )).value;
    } else
      r?.abortSignal != null &&
        console.warn(
          "sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."
        ),
        (o = (yield n.confirmTransaction(s, r && r.commitment)).value);
    if (o.err)
      throw s != null
        ? new Yo({
            action: "send",
            signature: s,
            transactionMessage: `Status: (${JSON.stringify(o)})`,
          })
        : new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);
    return s;
  });
}
function Ko(n) {
  return new Promise((e) => setTimeout(e, n));
}
function Ue(n, e) {
  let t = n.layout.span >= 0 ? n.layout.span : S2(n, e),
    r = we.Buffer.alloc(t),
    i = Object.assign({ instruction: n.index }, e);
  return n.layout.encode(i, r), r;
}
function Ze(n, e) {
  let t;
  try {
    t = n.layout.decode(e);
  } catch (r) {
    throw new Error("invalid instruction; " + r);
  }
  if (t.instruction !== n.index)
    throw new Error(
      `invalid instruction; instruction index mismatch ${t.instruction} != ${n.index}`
    );
  return t;
}
function e4(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function t4() {
  if (i2) return nb;
  i2 = 1;
  var n = Object.prototype.toString,
    e =
      Object.keys ||
      function (r) {
        var i = [];
        for (var s in r) i.push(s);
        return i;
      };
  function t(r, i) {
    var s, o, a, c, u, l, h;
    if (r === !0) return "true";
    if (r === !1) return "false";
    switch (typeof r) {
      case "object":
        if (r === null) return null;
        if (r.toJSON && typeof r.toJSON == "function") return t(r.toJSON(), i);
        if (((h = n.call(r)), h === "[object Array]")) {
          for (a = "[", o = r.length - 1, s = 0; s < o; s++)
            a += t(r[s], !0) + ",";
          return o > -1 && (a += t(r[s], !0)), a + "]";
        } else if (h === "[object Object]") {
          for (c = e(r).sort(), o = c.length, a = "", s = 0; s < o; )
            (u = c[s]),
              (l = t(r[u], !1)),
              l !== void 0 &&
                (a && (a += ","), (a += JSON.stringify(u) + ":" + l)),
              s++;
          return "{" + a + "}";
        } else return JSON.stringify(r);
      case "function":
      case "undefined":
        return i ? null : void 0;
      case "string":
        return JSON.stringify(r);
      default:
        return isFinite(r) ? r : null;
    }
  }
  return (
    (nb = function (r) {
      var i = t(r, !1);
      if (i !== void 0) return "" + i;
    }),
    nb
  );
}
function rb(n) {
  let e = 0;
  for (; n > 1; ) (n /= 2), e++;
  return e;
}
function r4(n) {
  return n === 0
    ? 1
    : (n--,
      (n |= n >> 1),
      (n |= n >> 2),
      (n |= n >> 4),
      (n |= n >> 8),
      (n |= n >> 16),
      (n |= n >> 32),
      n + 1);
}
function s4(n, e) {
  let t;
  try {
    t = n.layout.decode(e);
  } catch (r) {
    throw new Error("invalid instruction; " + r);
  }
  if (t.typeIndex !== n.index)
    throw new Error(
      `invalid account data; account type mismatch ${t.typeIndex} != ${n.index}`
    );
  return t;
}
function c4(n) {
  let e = n.match(a4);
  if (e == null) throw TypeError(`Failed to validate endpoint URL \`${n}\``);
  let [t, r, i, s] = e,
    o = n.startsWith("https:") ? "wss:" : "ws:",
    a = i == null ? null : parseInt(i.slice(1), 10),
    c = a == null ? "" : `:${a + 1}`;
  return `${o}//${r}${c}${s}`;
}
function u4(n) {
  if (/^https?:/.test(n) === !1)
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  return n;
}
function ht(n) {
  let e, t;
  if (typeof n == "string") e = n;
  else if (n) {
    let r = n,
      { commitment: i } = r,
      s = ln(r, ["commitment"]);
    (e = i), (t = s);
  }
  return { commitment: e, config: t };
}
function a2(n) {
  return n.map((e) =>
    "memcmp" in e
      ? $(v({}, e), {
          memcmp: $(v({}, e.memcmp), {
            encoding: e.memcmp.encoding ?? "base58",
          }),
        })
      : e
  );
}
function B2(n) {
  return wn([
    z({ jsonrpc: bt("2.0"), id: G(), result: n }),
    z({
      jsonrpc: bt("2.0"),
      id: G(),
      error: z({ code: $o(), message: G(), data: de(ZC()) }),
    }),
  ]);
}
function Re(n) {
  return Wc(B2(n), l4, (e) =>
    "error" in e ? e : $(v({}, e), { result: Q(e.result, n) })
  );
}
function kt(n) {
  return Re(z({ context: z({ slot: C() }), value: n }));
}
function Qp(n) {
  return z({ context: z({ slot: C() }), value: n });
}
function ib(n, e) {
  return n === 0
    ? new Kc({
        header: e.header,
        staticAccountKeys: e.accountKeys.map((t) => new J(t)),
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: e.instructions.map((t) => ({
          programIdIndex: t.programIdIndex,
          accountKeyIndexes: t.accounts,
          data: Xt.default.decode(t.data),
        })),
        addressTableLookups: e.addressTableLookups,
      })
    : new ui(e);
}
function v4(n, e, t, r, i, s) {
  let o = t || i4,
    a;
  s != null &&
    console.warn(
      "You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."
    );
  let c;
  return (
    r &&
      (c = (l, h) =>
        d(this, null, function* () {
          let f = yield new Promise((g, y) => {
            try {
              r(l, h, (w, m) => g([w, m]));
            } catch (w) {
              y(w);
            }
          });
          return yield o(...f);
        })),
    new A2.default(
      (l, h) =>
        d(this, null, function* () {
          let f = {
            method: "POST",
            body: l,
            agent: a,
            headers: Object.assign(
              { "Content-Type": "application/json" },
              e || {},
              I6
            ),
          };
          try {
            let g = 5,
              y,
              w = 500;
            for (
              ;
              c ? (y = yield c(n, f)) : (y = yield o(n, f)),
                !(y.status !== 429 || i === !0 || ((g -= 1), g === 0));

            )
              console.error(
                `Server responded with ${y.status} ${y.statusText}.  Retrying after ${w}ms delay...`
              ),
                yield Ko(w),
                (w *= 2);
            let m = yield y.text();
            y.ok
              ? h(null, m)
              : h(new Error(`${y.status} ${y.statusText}: ${m}`));
          } catch (g) {
            g instanceof Error && h(g);
          }
        }),
      {}
    )
  );
}
function I4(n) {
  return (e, t) =>
    new Promise((r, i) => {
      n.request(e, t, (s, o) => {
        if (s) {
          i(s);
          return;
        }
        r(o);
      });
    });
}
function C4(n) {
  return (e) =>
    new Promise((t, r) => {
      e.length === 0 && t([]);
      let i = e.map((s) => n.request(s.methodName, s.args));
      n.request(i, (s, o) => {
        if (s) {
          r(s);
          return;
        }
        t(o);
      });
    });
}
function L6({ authorizedVoter: n, epoch: e }) {
  return { epoch: e, authorizedVoter: new J(n) };
}
function y2({
  authorizedPubkey: n,
  epochOfLastAuthorizedSwitch: e,
  targetEpoch: t,
}) {
  return {
    authorizedPubkey: new J(n),
    epochOfLastAuthorizedSwitch: e,
    targetEpoch: t,
  };
}
function O6({ buf: n, idx: e, isEmpty: t }) {
  return t ? [] : [...n.slice(e + 1).map(y2), ...n.slice(0, e).map(y2)];
}
function N6(n, e) {
  let t = e === !1 ? "http" : "https";
  if (!n) return w2[t].devnet;
  let r = w2[t][n];
  if (!r) throw new Error(`Unknown ${t} cluster: ${n}`);
  return r;
}
function F6(n, e, t, r) {
  return d(this, null, function* () {
    let i, s;
    (t && Object.prototype.hasOwnProperty.call(t, "lastValidBlockHeight")) ||
    (t && Object.prototype.hasOwnProperty.call(t, "nonceValue"))
      ? ((i = t), (s = r))
      : (s = t);
    let o = s && {
        skipPreflight: s.skipPreflight,
        preflightCommitment: s.preflightCommitment || s.commitment,
        minContextSlot: s.minContextSlot,
      },
      a = yield n.sendRawTransaction(e, o),
      c = s && s.commitment,
      l = (yield i ? n.confirmTransaction(i, c) : n.confirmTransaction(a, c))
        .value;
    if (l.err)
      throw a != null
        ? new Yo({
            action: o?.skipPreflight ? "send" : "simulate",
            signature: a,
            transactionMessage: `Status: (${JSON.stringify(l)})`,
          })
        : new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);
    return a;
  });
}
var we,
  cb,
  Xt,
  Xc,
  A,
  b2,
  ih,
  A2,
  DU,
  t2,
  Fp,
  Cb,
  _U,
  Be,
  Yl,
  ub,
  Jl,
  E2,
  x2,
  ci,
  r2,
  J,
  lb,
  LU,
  js,
  qp,
  Qo,
  Zl,
  Xl,
  zs,
  Jo,
  Le,
  OU,
  qo,
  NU,
  FU,
  MU,
  UU,
  Mp,
  v2,
  ui,
  Kc,
  sh,
  Hi,
  zU,
  tt,
  Ne,
  Up,
  $i,
  jU,
  WU,
  HU,
  I2,
  ii,
  VU,
  $U,
  Op,
  qc,
  GU,
  KU,
  qU,
  Np,
  Yo,
  QU,
  ce,
  C2,
  k2,
  fb,
  zp,
  JU,
  YU,
  Qc,
  db,
  ft,
  an,
  ZU,
  pb,
  XU,
  gb,
  nb,
  i2,
  n4,
  s2,
  Ql,
  jp,
  i4,
  mb,
  o2,
  eh,
  o4,
  a4,
  vt,
  T2,
  kb,
  R2,
  l4,
  h4,
  f4,
  d4,
  p4,
  g4,
  m4,
  y4,
  Xo,
  w4,
  b4,
  A4,
  E4,
  x4,
  c2,
  S4,
  k4,
  T4,
  R4,
  B4,
  D4,
  _4,
  P4,
  L4,
  yb,
  O4,
  N4,
  wb,
  F4,
  M4,
  th,
  U4,
  z4,
  bb,
  j4,
  W4,
  H4,
  V4,
  $4,
  G4,
  K4,
  q4,
  Q4,
  J4,
  Y4,
  Z4,
  X4,
  e6,
  u2,
  t6,
  n6,
  r6,
  i6,
  s6,
  D2,
  Tb,
  _2,
  P2,
  L2,
  O2,
  o6,
  a6,
  N2,
  F2,
  Wp,
  M2,
  Jp,
  Rb,
  eu,
  ea,
  c6,
  u6,
  l6,
  h6,
  f6,
  d6,
  p6,
  l2,
  sb,
  Lp,
  g6,
  m6,
  y6,
  w6,
  b6,
  A6,
  E6,
  x6,
  S6,
  v6,
  I6,
  Jc,
  Hp,
  Vi,
  Ab,
  nh,
  Eb,
  oi,
  rh,
  h2,
  f2,
  d2,
  p2,
  Vp,
  C6,
  k6,
  g2,
  ob,
  m2,
  T6,
  ab,
  $p,
  U2,
  z2,
  Gp,
  Zo,
  xb,
  Zt,
  R6,
  Yc,
  Kp,
  Sb,
  ai,
  B6,
  Zc,
  j2,
  D6,
  vb,
  _6,
  P6,
  Ib,
  w2,
  M6,
  tu = ot(() => {
    "use strict";
    p();
    we = Et(kI());
    XI();
    (cb = Et(VE())), (Xt = Et(Hd()));
    vC();
    (Xc = Et(DC())), (A = Et(Fw())), (b2 = Et(Fw())), (ih = Et(QC()));
    XC();
    A2 = Et(rk());
    kk();
    jk();
    e2();
    (DU = Mo.utils.randomPrivateKey),
      (t2 = () => {
        let n = Mo.utils.randomPrivateKey(),
          e = Fp(n),
          t = new Uint8Array(64);
        return t.set(n), t.set(e, 32), { publicKey: e, secretKey: t };
      }),
      (Fp = Mo.getPublicKey);
    (Cb = (n, e) => Mo.sign(n, e.slice(0, 32))),
      (_U = Mo.verify),
      (Be = (n) =>
        we.Buffer.isBuffer(n)
          ? n
          : n instanceof Uint8Array
          ? we.Buffer.from(n.buffer, n.byteOffset, n.byteLength)
          : we.Buffer.from(n)),
      (Yl = class {
        constructor(e) {
          Object.assign(this, e);
        }
        encode() {
          return we.Buffer.from((0, Xc.serialize)(Jl, this));
        }
        static decode(e) {
          return (0, Xc.deserialize)(Jl, this, e);
        }
        static decodeUnchecked(e) {
          return (0, Xc.deserializeUnchecked)(Jl, this, e);
        }
      }),
      (ub = class extends Yl {
        constructor(e) {
          if ((super(e), (this.enum = ""), Object.keys(e).length !== 1))
            throw new Error("Enum can only take single value");
          Object.keys(e).map((t) => {
            this.enum = t;
          });
        }
      }),
      (Jl = new Map()),
      (x2 = 32),
      (ci = 32);
    (r2 = 1),
      (J = class n extends Yl {
        constructor(e) {
          if ((super({}), (this._bn = void 0), PU(e))) this._bn = e._bn;
          else {
            if (typeof e == "string") {
              let t = Xt.default.decode(e);
              if (t.length != ci) throw new Error("Invalid public key input");
              this._bn = new cb.default(t);
            } else this._bn = new cb.default(e);
            if (this._bn.byteLength() > ci)
              throw new Error("Invalid public key input");
          }
        }
        static unique() {
          let e = new n(r2);
          return (r2 += 1), new n(e.toBuffer());
        }
        equals(e) {
          return this._bn.eq(e._bn);
        }
        toBase58() {
          return Xt.default.encode(this.toBytes());
        }
        toJSON() {
          return this.toBase58();
        }
        toBytes() {
          let e = this.toBuffer();
          return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
        }
        toBuffer() {
          let e = this._bn.toArrayLike(we.Buffer);
          if (e.length === ci) return e;
          let t = we.Buffer.alloc(32);
          return e.copy(t, 32 - e.length), t;
        }
        get [Symbol.toStringTag]() {
          return `PublicKey(${this.toString()})`;
        }
        toString() {
          return this.toBase58();
        }
        static createWithSeed(e, t, r) {
          return d(this, null, function* () {
            let i = we.Buffer.concat([
                e.toBuffer(),
                we.Buffer.from(t),
                r.toBuffer(),
              ]),
              s = Ew(i);
            return new n(s);
          });
        }
        static createProgramAddressSync(e, t) {
          let r = we.Buffer.alloc(0);
          e.forEach(function (s) {
            if (s.length > x2) throw new TypeError("Max seed length exceeded");
            r = we.Buffer.concat([r, Be(s)]);
          }),
            (r = we.Buffer.concat([
              r,
              t.toBuffer(),
              we.Buffer.from("ProgramDerivedAddress"),
            ]));
          let i = Ew(r);
          if (n2(i))
            throw new Error("Invalid seeds, address must fall off the curve");
          return new n(i);
        }
        static createProgramAddress(e, t) {
          return d(this, null, function* () {
            return this.createProgramAddressSync(e, t);
          });
        }
        static findProgramAddressSync(e, t) {
          let r = 255,
            i;
          for (; r != 0; ) {
            try {
              let s = e.concat(we.Buffer.from([r]));
              i = this.createProgramAddressSync(s, t);
            } catch (s) {
              if (s instanceof TypeError) throw s;
              r--;
              continue;
            }
            return [i, r];
          }
          throw new Error("Unable to find a viable program address nonce");
        }
        static findProgramAddress(e, t) {
          return d(this, null, function* () {
            return this.findProgramAddressSync(e, t);
          });
        }
        static isOnCurve(e) {
          let t = new n(e);
          return n2(t.toBytes());
        }
      });
    E2 = J;
    J.default = new E2("11111111111111111111111111111111");
    Jl.set(J, { kind: "struct", fields: [["_bn", "u256"]] });
    (lb = class {
      constructor(e) {
        if (((this._publicKey = void 0), (this._secretKey = void 0), e)) {
          let t = Be(e);
          if (e.length !== 64) throw new Error("bad secret key size");
          (this._publicKey = t.slice(32, 64)),
            (this._secretKey = t.slice(0, 32));
        } else
          (this._secretKey = Be(DU())),
            (this._publicKey = Be(Fp(this._secretKey)));
      }
      get publicKey() {
        return new J(this._publicKey);
      }
      get secretKey() {
        return we.Buffer.concat([this._secretKey, this._publicKey], 64);
      }
    }),
      (LU = new J("BPFLoader1111111111111111111111111111111111")),
      (js = 1232),
      (qp = 127),
      (Qo = 64),
      (Zl = class extends Error {
        constructor(e) {
          super(`Signature ${e} has expired: block height exceeded.`),
            (this.signature = void 0),
            (this.signature = e);
        }
      });
    Object.defineProperty(Zl.prototype, "name", {
      value: "TransactionExpiredBlockheightExceededError",
    });
    Xl = class extends Error {
      constructor(e, t) {
        super(
          `Transaction was not confirmed in ${t.toFixed(
            2
          )} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`
        ),
          (this.signature = void 0),
          (this.signature = e);
      }
    };
    Object.defineProperty(Xl.prototype, "name", {
      value: "TransactionExpiredTimeoutError",
    });
    zs = class extends Error {
      constructor(e) {
        super(`Signature ${e} has expired: the nonce is no longer valid.`),
          (this.signature = void 0),
          (this.signature = e);
      }
    };
    Object.defineProperty(zs.prototype, "name", {
      value: "TransactionExpiredNonceInvalidError",
    });
    (Jo = class {
      constructor(e, t) {
        (this.staticAccountKeys = void 0),
          (this.accountKeysFromLookups = void 0),
          (this.staticAccountKeys = e),
          (this.accountKeysFromLookups = t);
      }
      keySegments() {
        let e = [this.staticAccountKeys];
        return (
          this.accountKeysFromLookups &&
            (e.push(this.accountKeysFromLookups.writable),
            e.push(this.accountKeysFromLookups.readonly)),
          e
        );
      }
      get(e) {
        for (let t of this.keySegments()) {
          if (e < t.length) return t[e];
          e -= t.length;
        }
      }
      get length() {
        return this.keySegments().flat().length;
      }
      compileInstructions(e) {
        if (this.length > 256)
          throw new Error(
            "Account index overflow encountered during compilation"
          );
        let r = new Map();
        this.keySegments()
          .flat()
          .forEach((s, o) => {
            r.set(s.toBase58(), o);
          });
        let i = (s) => {
          let o = r.get(s.toBase58());
          if (o === void 0)
            throw new Error(
              "Encountered an unknown instruction account key during compilation"
            );
          return o;
        };
        return e.map((s) => ({
          programIdIndex: i(s.programId),
          accountKeyIndexes: s.keys.map((o) => i(o.pubkey)),
          data: s.data,
        }));
      }
    }),
      (Le = (n = "publicKey") => A.blob(32, n)),
      (OU = (n = "signature") => A.blob(64, n)),
      (qo = (n = "string") => {
        let e = A.struct(
            [
              A.u32("length"),
              A.u32("lengthPadding"),
              A.blob(A.offset(A.u32(), -8), "chars"),
            ],
            n
          ),
          t = e.decode.bind(e),
          r = e.encode.bind(e),
          i = e;
        return (
          (i.decode = (s, o) => t(s, o).chars.toString()),
          (i.encode = (s, o, a) => {
            let c = { chars: we.Buffer.from(s, "utf8") };
            return r(c, o, a);
          }),
          (i.alloc = (s) =>
            A.u32().span + A.u32().span + we.Buffer.from(s, "utf8").length),
          i
        );
      }),
      (NU = (n = "authorized") =>
        A.struct([Le("staker"), Le("withdrawer")], n)),
      (FU = (n = "lockup") =>
        A.struct(
          [A.ns64("unixTimestamp"), A.ns64("epoch"), Le("custodian")],
          n
        )),
      (MU = (n = "voteInit") =>
        A.struct(
          [
            Le("nodePubkey"),
            Le("authorizedVoter"),
            Le("authorizedWithdrawer"),
            A.u8("commission"),
          ],
          n
        )),
      (UU = (n = "voteAuthorizeWithSeedArgs") =>
        A.struct(
          [
            A.u32("voteAuthorizationType"),
            Le("currentAuthorityDerivedKeyOwnerPubkey"),
            qo("currentAuthorityDerivedKeySeed"),
            Le("newAuthorized"),
          ],
          n
        ));
    (Mp = class n {
      constructor(e, t) {
        (this.payer = void 0),
          (this.keyMetaMap = void 0),
          (this.payer = e),
          (this.keyMetaMap = t);
      }
      static compile(e, t) {
        let r = new Map(),
          i = (o) => {
            let a = o.toBase58(),
              c = r.get(a);
            return (
              c === void 0 &&
                ((c = { isSigner: !1, isWritable: !1, isInvoked: !1 }),
                r.set(a, c)),
              c
            );
          },
          s = i(t);
        (s.isSigner = !0), (s.isWritable = !0);
        for (let o of e) {
          i(o.programId).isInvoked = !0;
          for (let a of o.keys) {
            let c = i(a.pubkey);
            (c.isSigner ||= a.isSigner), (c.isWritable ||= a.isWritable);
          }
        }
        return new n(t, r);
      }
      getMessageComponents() {
        let e = [...this.keyMetaMap.entries()];
        Ve(e.length <= 256, "Max static account keys length exceeded");
        let t = e.filter(([, c]) => c.isSigner && c.isWritable),
          r = e.filter(([, c]) => c.isSigner && !c.isWritable),
          i = e.filter(([, c]) => !c.isSigner && c.isWritable),
          s = e.filter(([, c]) => !c.isSigner && !c.isWritable),
          o = {
            numRequiredSignatures: t.length + r.length,
            numReadonlySignedAccounts: r.length,
            numReadonlyUnsignedAccounts: s.length,
          };
        {
          Ve(t.length > 0, "Expected at least one writable signer key");
          let [c] = t[0];
          Ve(
            c === this.payer.toBase58(),
            "Expected first writable signer key to be the fee payer"
          );
        }
        let a = [
          ...t.map(([c]) => new J(c)),
          ...r.map(([c]) => new J(c)),
          ...i.map(([c]) => new J(c)),
          ...s.map(([c]) => new J(c)),
        ];
        return [o, a];
      }
      extractTableLookup(e) {
        let [t, r] = this.drainKeysFoundInLookupTable(
            e.state.addresses,
            (o) => !o.isSigner && !o.isInvoked && o.isWritable
          ),
          [i, s] = this.drainKeysFoundInLookupTable(
            e.state.addresses,
            (o) => !o.isSigner && !o.isInvoked && !o.isWritable
          );
        if (!(t.length === 0 && i.length === 0))
          return [
            { accountKey: e.key, writableIndexes: t, readonlyIndexes: i },
            { writable: r, readonly: s },
          ];
      }
      drainKeysFoundInLookupTable(e, t) {
        let r = new Array(),
          i = new Array();
        for (let [s, o] of this.keyMetaMap.entries())
          if (t(o)) {
            let a = new J(s),
              c = e.findIndex((u) => u.equals(a));
            c >= 0 &&
              (Ve(c < 256, "Max lookup table index exceeded"),
              r.push(c),
              i.push(a),
              this.keyMetaMap.delete(s));
          }
        return [r, i];
      }
    }),
      (v2 = "Reached end of buffer unexpectedly");
    (ui = class n {
      constructor(e) {
        (this.header = void 0),
          (this.accountKeys = void 0),
          (this.recentBlockhash = void 0),
          (this.instructions = void 0),
          (this.indexToProgramIds = new Map()),
          (this.header = e.header),
          (this.accountKeys = e.accountKeys.map((t) => new J(t))),
          (this.recentBlockhash = e.recentBlockhash),
          (this.instructions = e.instructions),
          this.instructions.forEach((t) =>
            this.indexToProgramIds.set(
              t.programIdIndex,
              this.accountKeys[t.programIdIndex]
            )
          );
      }
      get version() {
        return "legacy";
      }
      get staticAccountKeys() {
        return this.accountKeys;
      }
      get compiledInstructions() {
        return this.instructions.map((e) => ({
          programIdIndex: e.programIdIndex,
          accountKeyIndexes: e.accounts,
          data: Xt.default.decode(e.data),
        }));
      }
      get addressTableLookups() {
        return [];
      }
      getAccountKeys() {
        return new Jo(this.staticAccountKeys);
      }
      static compile(e) {
        let t = Mp.compile(e.instructions, e.payerKey),
          [r, i] = t.getMessageComponents(),
          o = new Jo(i)
            .compileInstructions(e.instructions)
            .map((a) => ({
              programIdIndex: a.programIdIndex,
              accounts: a.accountKeyIndexes,
              data: Xt.default.encode(a.data),
            }));
        return new n({
          header: r,
          accountKeys: i,
          recentBlockhash: e.recentBlockhash,
          instructions: o,
        });
      }
      isAccountSigner(e) {
        return e < this.header.numRequiredSignatures;
      }
      isAccountWritable(e) {
        let t = this.header.numRequiredSignatures;
        if (e >= this.header.numRequiredSignatures) {
          let r = e - t,
            s =
              this.accountKeys.length -
              t -
              this.header.numReadonlyUnsignedAccounts;
          return r < s;
        } else {
          let r = t - this.header.numReadonlySignedAccounts;
          return e < r;
        }
      }
      isProgramId(e) {
        return this.indexToProgramIds.has(e);
      }
      programIds() {
        return [...this.indexToProgramIds.values()];
      }
      nonProgramIds() {
        return this.accountKeys.filter((e, t) => !this.isProgramId(t));
      }
      serialize() {
        let e = this.accountKeys.length,
          t = [];
        tr(t, e);
        let r = this.instructions.map((h) => {
            let { accounts: f, programIdIndex: g } = h,
              y = Array.from(Xt.default.decode(h.data)),
              w = [];
            tr(w, f.length);
            let m = [];
            return (
              tr(m, y.length),
              {
                programIdIndex: g,
                keyIndicesCount: we.Buffer.from(w),
                keyIndices: f,
                dataLength: we.Buffer.from(m),
                data: y,
              }
            );
          }),
          i = [];
        tr(i, r.length);
        let s = we.Buffer.alloc(js);
        we.Buffer.from(i).copy(s);
        let o = i.length;
        r.forEach((h) => {
          let g = A.struct([
            A.u8("programIdIndex"),
            A.blob(h.keyIndicesCount.length, "keyIndicesCount"),
            A.seq(A.u8("keyIndex"), h.keyIndices.length, "keyIndices"),
            A.blob(h.dataLength.length, "dataLength"),
            A.seq(A.u8("userdatum"), h.data.length, "data"),
          ]).encode(h, s, o);
          o += g;
        }),
          (s = s.slice(0, o));
        let a = A.struct([
            A.blob(1, "numRequiredSignatures"),
            A.blob(1, "numReadonlySignedAccounts"),
            A.blob(1, "numReadonlyUnsignedAccounts"),
            A.blob(t.length, "keyCount"),
            A.seq(Le("key"), e, "keys"),
            Le("recentBlockhash"),
          ]),
          c = {
            numRequiredSignatures: we.Buffer.from([
              this.header.numRequiredSignatures,
            ]),
            numReadonlySignedAccounts: we.Buffer.from([
              this.header.numReadonlySignedAccounts,
            ]),
            numReadonlyUnsignedAccounts: we.Buffer.from([
              this.header.numReadonlyUnsignedAccounts,
            ]),
            keyCount: we.Buffer.from(t),
            keys: this.accountKeys.map((h) => Be(h.toBytes())),
            recentBlockhash: Xt.default.decode(this.recentBlockhash),
          },
          u = we.Buffer.alloc(2048),
          l = a.encode(c, u);
        return s.copy(u, l), u.slice(0, l + s.length);
      }
      static from(e) {
        let t = [...e],
          r = si(t);
        if (r !== (r & qp))
          throw new Error(
            "Versioned messages must be deserialized with VersionedMessage.deserialize()"
          );
        let i = si(t),
          s = si(t),
          o = Hn(t),
          a = [];
        for (let f = 0; f < o; f++) {
          let g = Vn(t, 0, ci);
          a.push(new J(we.Buffer.from(g)));
        }
        let c = Vn(t, 0, ci),
          u = Hn(t),
          l = [];
        for (let f = 0; f < u; f++) {
          let g = si(t),
            y = Hn(t),
            w = Vn(t, 0, y),
            m = Hn(t),
            b = Vn(t, 0, m),
            I = Xt.default.encode(we.Buffer.from(b));
          l.push({ programIdIndex: g, accounts: w, data: I });
        }
        let h = {
          header: {
            numRequiredSignatures: r,
            numReadonlySignedAccounts: i,
            numReadonlyUnsignedAccounts: s,
          },
          recentBlockhash: Xt.default.encode(we.Buffer.from(c)),
          accountKeys: a,
          instructions: l,
        };
        return new n(h);
      }
    }),
      (Kc = class n {
        constructor(e) {
          (this.header = void 0),
            (this.staticAccountKeys = void 0),
            (this.recentBlockhash = void 0),
            (this.compiledInstructions = void 0),
            (this.addressTableLookups = void 0),
            (this.header = e.header),
            (this.staticAccountKeys = e.staticAccountKeys),
            (this.recentBlockhash = e.recentBlockhash),
            (this.compiledInstructions = e.compiledInstructions),
            (this.addressTableLookups = e.addressTableLookups);
        }
        get version() {
          return 0;
        }
        get numAccountKeysFromLookups() {
          let e = 0;
          for (let t of this.addressTableLookups)
            e += t.readonlyIndexes.length + t.writableIndexes.length;
          return e;
        }
        getAccountKeys(e) {
          let t;
          if (e && "accountKeysFromLookups" in e && e.accountKeysFromLookups) {
            if (
              this.numAccountKeysFromLookups !=
              e.accountKeysFromLookups.writable.length +
                e.accountKeysFromLookups.readonly.length
            )
              throw new Error(
                "Failed to get account keys because of a mismatch in the number of account keys from lookups"
              );
            t = e.accountKeysFromLookups;
          } else if (
            e &&
            "addressLookupTableAccounts" in e &&
            e.addressLookupTableAccounts
          )
            t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
          else if (this.addressTableLookups.length > 0)
            throw new Error(
              "Failed to get account keys because address table lookups were not resolved"
            );
          return new Jo(this.staticAccountKeys, t);
        }
        isAccountSigner(e) {
          return e < this.header.numRequiredSignatures;
        }
        isAccountWritable(e) {
          let t = this.header.numRequiredSignatures,
            r = this.staticAccountKeys.length;
          if (e >= r) {
            let i = e - r,
              s = this.addressTableLookups.reduce(
                (o, a) => o + a.writableIndexes.length,
                0
              );
            return i < s;
          } else if (e >= this.header.numRequiredSignatures) {
            let i = e - t,
              o = r - t - this.header.numReadonlyUnsignedAccounts;
            return i < o;
          } else {
            let i = t - this.header.numReadonlySignedAccounts;
            return e < i;
          }
        }
        resolveAddressTableLookups(e) {
          let t = { writable: [], readonly: [] };
          for (let r of this.addressTableLookups) {
            let i = e.find((s) => s.key.equals(r.accountKey));
            if (!i)
              throw new Error(
                `Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`
              );
            for (let s of r.writableIndexes)
              if (s < i.state.addresses.length)
                t.writable.push(i.state.addresses[s]);
              else
                throw new Error(
                  `Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`
                );
            for (let s of r.readonlyIndexes)
              if (s < i.state.addresses.length)
                t.readonly.push(i.state.addresses[s]);
              else
                throw new Error(
                  `Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`
                );
          }
          return t;
        }
        static compile(e) {
          let t = Mp.compile(e.instructions, e.payerKey),
            r = new Array(),
            i = { writable: new Array(), readonly: new Array() },
            s = e.addressLookupTableAccounts || [];
          for (let l of s) {
            let h = t.extractTableLookup(l);
            if (h !== void 0) {
              let [f, { writable: g, readonly: y }] = h;
              r.push(f), i.writable.push(...g), i.readonly.push(...y);
            }
          }
          let [o, a] = t.getMessageComponents(),
            u = new Jo(a, i).compileInstructions(e.instructions);
          return new n({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: e.recentBlockhash,
            compiledInstructions: u,
            addressTableLookups: r,
          });
        }
        serialize() {
          let e = Array();
          tr(e, this.staticAccountKeys.length);
          let t = this.serializeInstructions(),
            r = Array();
          tr(r, this.compiledInstructions.length);
          let i = this.serializeAddressTableLookups(),
            s = Array();
          tr(s, this.addressTableLookups.length);
          let o = A.struct([
              A.u8("prefix"),
              A.struct(
                [
                  A.u8("numRequiredSignatures"),
                  A.u8("numReadonlySignedAccounts"),
                  A.u8("numReadonlyUnsignedAccounts"),
                ],
                "header"
              ),
              A.blob(e.length, "staticAccountKeysLength"),
              A.seq(Le(), this.staticAccountKeys.length, "staticAccountKeys"),
              Le("recentBlockhash"),
              A.blob(r.length, "instructionsLength"),
              A.blob(t.length, "serializedInstructions"),
              A.blob(s.length, "addressTableLookupsLength"),
              A.blob(i.length, "serializedAddressTableLookups"),
            ]),
            a = new Uint8Array(js),
            u = o.encode(
              {
                prefix: 128,
                header: this.header,
                staticAccountKeysLength: new Uint8Array(e),
                staticAccountKeys: this.staticAccountKeys.map((l) =>
                  l.toBytes()
                ),
                recentBlockhash: Xt.default.decode(this.recentBlockhash),
                instructionsLength: new Uint8Array(r),
                serializedInstructions: t,
                addressTableLookupsLength: new Uint8Array(s),
                serializedAddressTableLookups: i,
              },
              a
            );
          return a.slice(0, u);
        }
        serializeInstructions() {
          let e = 0,
            t = new Uint8Array(js);
          for (let r of this.compiledInstructions) {
            let i = Array();
            tr(i, r.accountKeyIndexes.length);
            let s = Array();
            tr(s, r.data.length);
            let o = A.struct([
              A.u8("programIdIndex"),
              A.blob(i.length, "encodedAccountKeyIndexesLength"),
              A.seq(A.u8(), r.accountKeyIndexes.length, "accountKeyIndexes"),
              A.blob(s.length, "encodedDataLength"),
              A.blob(r.data.length, "data"),
            ]);
            e += o.encode(
              {
                programIdIndex: r.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(i),
                accountKeyIndexes: r.accountKeyIndexes,
                encodedDataLength: new Uint8Array(s),
                data: r.data,
              },
              t,
              e
            );
          }
          return t.slice(0, e);
        }
        serializeAddressTableLookups() {
          let e = 0,
            t = new Uint8Array(js);
          for (let r of this.addressTableLookups) {
            let i = Array();
            tr(i, r.writableIndexes.length);
            let s = Array();
            tr(s, r.readonlyIndexes.length);
            let o = A.struct([
              Le("accountKey"),
              A.blob(i.length, "encodedWritableIndexesLength"),
              A.seq(A.u8(), r.writableIndexes.length, "writableIndexes"),
              A.blob(s.length, "encodedReadonlyIndexesLength"),
              A.seq(A.u8(), r.readonlyIndexes.length, "readonlyIndexes"),
            ]);
            e += o.encode(
              {
                accountKey: r.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(i),
                writableIndexes: r.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(s),
                readonlyIndexes: r.readonlyIndexes,
              },
              t,
              e
            );
          }
          return t.slice(0, e);
        }
        static deserialize(e) {
          let t = [...e],
            r = si(t),
            i = r & qp;
          Ve(r !== i, "Expected versioned message but received legacy message");
          let s = i;
          Ve(
            s === 0,
            `Expected versioned message with version 0 but found version ${s}`
          );
          let o = {
              numRequiredSignatures: si(t),
              numReadonlySignedAccounts: si(t),
              numReadonlyUnsignedAccounts: si(t),
            },
            a = [],
            c = Hn(t);
          for (let y = 0; y < c; y++) a.push(new J(Vn(t, 0, ci)));
          let u = Xt.default.encode(Vn(t, 0, ci)),
            l = Hn(t),
            h = [];
          for (let y = 0; y < l; y++) {
            let w = si(t),
              m = Hn(t),
              b = Vn(t, 0, m),
              I = Hn(t),
              E = new Uint8Array(Vn(t, 0, I));
            h.push({ programIdIndex: w, accountKeyIndexes: b, data: E });
          }
          let f = Hn(t),
            g = [];
          for (let y = 0; y < f; y++) {
            let w = new J(Vn(t, 0, ci)),
              m = Hn(t),
              b = Vn(t, 0, m),
              I = Hn(t),
              E = Vn(t, 0, I);
            g.push({ accountKey: w, writableIndexes: b, readonlyIndexes: E });
          }
          return new n({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: u,
            compiledInstructions: h,
            addressTableLookups: g,
          });
        }
      }),
      (sh = {
        deserializeMessageVersion(n) {
          let e = n[0],
            t = e & qp;
          return t === e ? "legacy" : t;
        },
        deserialize: (n) => {
          let e = sh.deserializeMessageVersion(n);
          if (e === "legacy") return ui.from(n);
          if (e === 0) return Kc.deserialize(n);
          throw new Error(
            `Transaction message version ${e} deserialization is not supported`
          );
        },
      }),
      (Hi = (function (n) {
        return (
          (n[(n.BLOCKHEIGHT_EXCEEDED = 0)] = "BLOCKHEIGHT_EXCEEDED"),
          (n[(n.PROCESSED = 1)] = "PROCESSED"),
          (n[(n.TIMED_OUT = 2)] = "TIMED_OUT"),
          (n[(n.NONCE_INVALID = 3)] = "NONCE_INVALID"),
          n
        );
      })({})),
      (zU = we.Buffer.alloc(Qo).fill(0)),
      (tt = class {
        constructor(e) {
          (this.keys = void 0),
            (this.programId = void 0),
            (this.data = we.Buffer.alloc(0)),
            (this.programId = e.programId),
            (this.keys = e.keys),
            e.data && (this.data = e.data);
        }
        toJSON() {
          return {
            keys: this.keys.map(
              ({ pubkey: e, isSigner: t, isWritable: r }) => ({
                pubkey: e.toJSON(),
                isSigner: t,
                isWritable: r,
              })
            ),
            programId: this.programId.toJSON(),
            data: [...this.data],
          };
        }
      }),
      (Ne = class n {
        get signature() {
          return this.signatures.length > 0
            ? this.signatures[0].signature
            : null;
        }
        constructor(e) {
          if (
            ((this.signatures = []),
            (this.feePayer = void 0),
            (this.instructions = []),
            (this.recentBlockhash = void 0),
            (this.lastValidBlockHeight = void 0),
            (this.nonceInfo = void 0),
            (this.minNonceContextSlot = void 0),
            (this._message = void 0),
            (this._json = void 0),
            !!e)
          )
            if (
              (e.feePayer && (this.feePayer = e.feePayer),
              e.signatures && (this.signatures = e.signatures),
              Object.prototype.hasOwnProperty.call(e, "nonceInfo"))
            ) {
              let { minContextSlot: t, nonceInfo: r } = e;
              (this.minNonceContextSlot = t), (this.nonceInfo = r);
            } else if (
              Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")
            ) {
              let { blockhash: t, lastValidBlockHeight: r } = e;
              (this.recentBlockhash = t), (this.lastValidBlockHeight = r);
            } else {
              let { recentBlockhash: t, nonceInfo: r } = e;
              r && (this.nonceInfo = r), (this.recentBlockhash = t);
            }
        }
        toJSON() {
          return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo
              ? {
                  nonce: this.nonceInfo.nonce,
                  nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
                }
              : null,
            instructions: this.instructions.map((e) => e.toJSON()),
            signers: this.signatures.map(({ publicKey: e }) => e.toJSON()),
          };
        }
        add(...e) {
          if (e.length === 0) throw new Error("No instructions");
          return (
            e.forEach((t) => {
              "instructions" in t
                ? (this.instructions = this.instructions.concat(t.instructions))
                : "data" in t && "programId" in t && "keys" in t
                ? this.instructions.push(t)
                : this.instructions.push(new tt(t));
            }),
            this
          );
        }
        compileMessage() {
          if (
            this._message &&
            JSON.stringify(this.toJSON()) === JSON.stringify(this._json)
          )
            return this._message;
          let e, t;
          if (
            (this.nonceInfo
              ? ((e = this.nonceInfo.nonce),
                this.instructions[0] != this.nonceInfo.nonceInstruction
                  ? (t = [
                      this.nonceInfo.nonceInstruction,
                      ...this.instructions,
                    ])
                  : (t = this.instructions))
              : ((e = this.recentBlockhash), (t = this.instructions)),
            !e)
          )
            throw new Error("Transaction recentBlockhash required");
          t.length < 1 && console.warn("No instructions provided");
          let r;
          if (this.feePayer) r = this.feePayer;
          else if (this.signatures.length > 0 && this.signatures[0].publicKey)
            r = this.signatures[0].publicKey;
          else throw new Error("Transaction fee payer required");
          for (let w = 0; w < t.length; w++)
            if (t[w].programId === void 0)
              throw new Error(
                `Transaction instruction index ${w} has undefined program id`
              );
          let i = [],
            s = [];
          t.forEach((w) => {
            w.keys.forEach((b) => {
              s.push(v({}, b));
            });
            let m = w.programId.toString();
            i.includes(m) || i.push(m);
          }),
            i.forEach((w) => {
              s.push({ pubkey: new J(w), isSigner: !1, isWritable: !1 });
            });
          let o = [];
          s.forEach((w) => {
            let m = w.pubkey.toString(),
              b = o.findIndex((I) => I.pubkey.toString() === m);
            b > -1
              ? ((o[b].isWritable = o[b].isWritable || w.isWritable),
                (o[b].isSigner = o[b].isSigner || w.isSigner))
              : o.push(w);
          }),
            o.sort(function (w, m) {
              if (w.isSigner !== m.isSigner) return w.isSigner ? -1 : 1;
              if (w.isWritable !== m.isWritable) return w.isWritable ? -1 : 1;
              let b = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: !1,
                numeric: !1,
                caseFirst: "lower",
              };
              return w.pubkey
                .toBase58()
                .localeCompare(m.pubkey.toBase58(), "en", b);
            });
          let a = o.findIndex((w) => w.pubkey.equals(r));
          if (a > -1) {
            let [w] = o.splice(a, 1);
            (w.isSigner = !0), (w.isWritable = !0), o.unshift(w);
          } else o.unshift({ pubkey: r, isSigner: !0, isWritable: !0 });
          for (let w of this.signatures) {
            let m = o.findIndex((b) => b.pubkey.equals(w.publicKey));
            if (m > -1)
              o[m].isSigner ||
                ((o[m].isSigner = !0),
                console.warn(
                  "Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."
                ));
            else throw new Error(`unknown signer: ${w.publicKey.toString()}`);
          }
          let c = 0,
            u = 0,
            l = 0,
            h = [],
            f = [];
          o.forEach(({ pubkey: w, isSigner: m, isWritable: b }) => {
            m
              ? (h.push(w.toString()), (c += 1), b || (u += 1))
              : (f.push(w.toString()), b || (l += 1));
          });
          let g = h.concat(f),
            y = t.map((w) => {
              let { data: m, programId: b } = w;
              return {
                programIdIndex: g.indexOf(b.toString()),
                accounts: w.keys.map((I) => g.indexOf(I.pubkey.toString())),
                data: Xt.default.encode(m),
              };
            });
          return (
            y.forEach((w) => {
              Ve(w.programIdIndex >= 0), w.accounts.forEach((m) => Ve(m >= 0));
            }),
            new ui({
              header: {
                numRequiredSignatures: c,
                numReadonlySignedAccounts: u,
                numReadonlyUnsignedAccounts: l,
              },
              accountKeys: g,
              recentBlockhash: e,
              instructions: y,
            })
          );
        }
        _compile() {
          let e = this.compileMessage(),
            t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
          return (
            (this.signatures.length === t.length &&
              this.signatures.every((i, s) => t[s].equals(i.publicKey))) ||
              (this.signatures = t.map((r) => ({
                signature: null,
                publicKey: r,
              }))),
            e
          );
        }
        serializeMessage() {
          return this._compile().serialize();
        }
        getEstimatedFee(e) {
          return d(this, null, function* () {
            return (yield e.getFeeForMessage(this.compileMessage())).value;
          });
        }
        setSigners(...e) {
          if (e.length === 0) throw new Error("No signers");
          let t = new Set();
          this.signatures = e
            .filter((r) => {
              let i = r.toString();
              return t.has(i) ? !1 : (t.add(i), !0);
            })
            .map((r) => ({ signature: null, publicKey: r }));
        }
        sign(...e) {
          if (e.length === 0) throw new Error("No signers");
          let t = new Set(),
            r = [];
          for (let s of e) {
            let o = s.publicKey.toString();
            t.has(o) || (t.add(o), r.push(s));
          }
          this.signatures = r.map((s) => ({
            signature: null,
            publicKey: s.publicKey,
          }));
          let i = this._compile();
          this._partialSign(i, ...r);
        }
        partialSign(...e) {
          if (e.length === 0) throw new Error("No signers");
          let t = new Set(),
            r = [];
          for (let s of e) {
            let o = s.publicKey.toString();
            t.has(o) || (t.add(o), r.push(s));
          }
          let i = this._compile();
          this._partialSign(i, ...r);
        }
        _partialSign(e, ...t) {
          let r = e.serialize();
          t.forEach((i) => {
            let s = Cb(r, i.secretKey);
            this._addSignature(i.publicKey, Be(s));
          });
        }
        addSignature(e, t) {
          this._compile(), this._addSignature(e, t);
        }
        _addSignature(e, t) {
          Ve(t.length === 64);
          let r = this.signatures.findIndex((i) => e.equals(i.publicKey));
          if (r < 0) throw new Error(`unknown signer: ${e.toString()}`);
          this.signatures[r].signature = we.Buffer.from(t);
        }
        verifySignatures(e = !0) {
          return !this._getMessageSignednessErrors(this.serializeMessage(), e);
        }
        _getMessageSignednessErrors(e, t) {
          let r = {};
          for (let { signature: i, publicKey: s } of this.signatures)
            i === null
              ? t && (r.missing ||= []).push(s)
              : _U(i, e, s.toBytes()) || (r.invalid ||= []).push(s);
          return r.invalid || r.missing ? r : void 0;
        }
        serialize(e) {
          let { requireAllSignatures: t, verifySignatures: r } = Object.assign(
              { requireAllSignatures: !0, verifySignatures: !0 },
              e
            ),
            i = this.serializeMessage();
          if (r) {
            let s = this._getMessageSignednessErrors(i, t);
            if (s) {
              let o = "Signature verification failed.";
              throw (
                (s.invalid &&
                  (o += `
Invalid signature for public key${
                    s.invalid.length === 1 ? "" : "(s)"
                  } [\`${s.invalid.map((a) => a.toBase58()).join("`, `")}\`].`),
                s.missing &&
                  (o += `
Missing signature for public key${
                    s.missing.length === 1 ? "" : "(s)"
                  } [\`${s.missing.map((a) => a.toBase58()).join("`, `")}\`].`),
                new Error(o))
              );
            }
          }
          return this._serialize(i);
        }
        _serialize(e) {
          let { signatures: t } = this,
            r = [];
          tr(r, t.length);
          let i = r.length + t.length * 64 + e.length,
            s = we.Buffer.alloc(i);
          return (
            Ve(t.length < 256),
            we.Buffer.from(r).copy(s, 0),
            t.forEach(({ signature: o }, a) => {
              o !== null &&
                (Ve(o.length === 64, "signature has invalid length"),
                we.Buffer.from(o).copy(s, r.length + a * 64));
            }),
            e.copy(s, r.length + t.length * 64),
            Ve(s.length <= js, `Transaction too large: ${s.length} > ${js}`),
            s
          );
        }
        get keys() {
          return (
            Ve(this.instructions.length === 1),
            this.instructions[0].keys.map((e) => e.pubkey)
          );
        }
        get programId() {
          return (
            Ve(this.instructions.length === 1), this.instructions[0].programId
          );
        }
        get data() {
          return Ve(this.instructions.length === 1), this.instructions[0].data;
        }
        static from(e) {
          let t = [...e],
            r = Hn(t),
            i = [];
          for (let s = 0; s < r; s++) {
            let o = Vn(t, 0, Qo);
            i.push(Xt.default.encode(we.Buffer.from(o)));
          }
          return n.populate(ui.from(t), i);
        }
        static populate(e, t = []) {
          let r = new n();
          return (
            (r.recentBlockhash = e.recentBlockhash),
            e.header.numRequiredSignatures > 0 &&
              (r.feePayer = e.accountKeys[0]),
            t.forEach((i, s) => {
              let o = {
                signature:
                  i == Xt.default.encode(zU) ? null : Xt.default.decode(i),
                publicKey: e.accountKeys[s],
              };
              r.signatures.push(o);
            }),
            e.instructions.forEach((i) => {
              let s = i.accounts.map((o) => {
                let a = e.accountKeys[o];
                return {
                  pubkey: a,
                  isSigner:
                    r.signatures.some(
                      (c) => c.publicKey.toString() === a.toString()
                    ) || e.isAccountSigner(o),
                  isWritable: e.isAccountWritable(o),
                };
              });
              r.instructions.push(
                new tt({
                  keys: s,
                  programId: e.accountKeys[i.programIdIndex],
                  data: Xt.default.decode(i.data),
                })
              );
            }),
            (r._message = e),
            (r._json = r.toJSON()),
            r
          );
        }
      }),
      (Up = class n {
        constructor(e) {
          (this.payerKey = void 0),
            (this.instructions = void 0),
            (this.recentBlockhash = void 0),
            (this.payerKey = e.payerKey),
            (this.instructions = e.instructions),
            (this.recentBlockhash = e.recentBlockhash);
        }
        static decompile(e, t) {
          let { header: r, compiledInstructions: i, recentBlockhash: s } = e,
            {
              numRequiredSignatures: o,
              numReadonlySignedAccounts: a,
              numReadonlyUnsignedAccounts: c,
            } = r,
            u = o - a;
          Ve(u > 0, "Message header is invalid");
          let l = e.staticAccountKeys.length - o - c;
          Ve(l >= 0, "Message header is invalid");
          let h = e.getAccountKeys(t),
            f = h.get(0);
          if (f === void 0)
            throw new Error(
              "Failed to decompile message because no account keys were found"
            );
          let g = [];
          for (let y of i) {
            let w = [];
            for (let b of y.accountKeyIndexes) {
              let I = h.get(b);
              if (I === void 0)
                throw new Error(
                  `Failed to find key for account key index ${b}`
                );
              let E = b < o,
                T;
              E
                ? (T = b < u)
                : b < h.staticAccountKeys.length
                ? (T = b - o < l)
                : (T =
                    b - h.staticAccountKeys.length <
                    h.accountKeysFromLookups.writable.length),
                w.push({
                  pubkey: I,
                  isSigner: b < r.numRequiredSignatures,
                  isWritable: T,
                });
            }
            let m = h.get(y.programIdIndex);
            if (m === void 0)
              throw new Error(
                `Failed to find program id for program id index ${y.programIdIndex}`
              );
            g.push(new tt({ programId: m, data: Be(y.data), keys: w }));
          }
          return new n({ payerKey: f, instructions: g, recentBlockhash: s });
        }
        compileToLegacyMessage() {
          return ui.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
          });
        }
        compileToV0Message(e) {
          return Kc.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
            addressLookupTableAccounts: e,
          });
        }
      }),
      ($i = class n {
        get version() {
          return this.message.version;
        }
        constructor(e, t) {
          if (
            ((this.signatures = void 0), (this.message = void 0), t !== void 0)
          )
            Ve(
              t.length === e.header.numRequiredSignatures,
              "Expected signatures length to be equal to the number of required signatures"
            ),
              (this.signatures = t);
          else {
            let r = [];
            for (let i = 0; i < e.header.numRequiredSignatures; i++)
              r.push(new Uint8Array(Qo));
            this.signatures = r;
          }
          this.message = e;
        }
        serialize() {
          let e = this.message.serialize(),
            t = Array();
          tr(t, this.signatures.length);
          let r = A.struct([
              A.blob(t.length, "encodedSignaturesLength"),
              A.seq(OU(), this.signatures.length, "signatures"),
              A.blob(e.length, "serializedMessage"),
            ]),
            i = new Uint8Array(2048),
            s = r.encode(
              {
                encodedSignaturesLength: new Uint8Array(t),
                signatures: this.signatures,
                serializedMessage: e,
              },
              i
            );
          return i.slice(0, s);
        }
        static deserialize(e) {
          let t = [...e],
            r = [],
            i = Hn(t);
          for (let o = 0; o < i; o++) r.push(new Uint8Array(Vn(t, 0, Qo)));
          let s = sh.deserialize(new Uint8Array(t));
          return new n(s, r);
        }
        sign(e) {
          let t = this.message.serialize(),
            r = this.message.staticAccountKeys.slice(
              0,
              this.message.header.numRequiredSignatures
            );
          for (let i of e) {
            let s = r.findIndex((o) => o.equals(i.publicKey));
            Ve(
              s >= 0,
              `Cannot sign with non signer key ${i.publicKey.toBase58()}`
            ),
              (this.signatures[s] = Cb(t, i.secretKey));
          }
        }
        addSignature(e, t) {
          Ve(t.byteLength === 64, "Signature must be 64 bytes long");
          let i = this.message.staticAccountKeys
            .slice(0, this.message.header.numRequiredSignatures)
            .findIndex((s) => s.equals(e));
          Ve(
            i >= 0,
            `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`
          ),
            (this.signatures[i] = t);
        }
      }),
      (jU = 160),
      (WU = 64),
      (HU = jU / WU),
      (I2 = 1e3 / HU),
      (ii = new J("SysvarC1ock11111111111111111111111111111111")),
      (VU = new J("SysvarEpochSchedu1e111111111111111111111111")),
      ($U = new J("Sysvar1nstructions1111111111111111111111111")),
      (Op = new J("SysvarRecentB1ockHashes11111111111111111111")),
      (qc = new J("SysvarRent111111111111111111111111111111111")),
      (GU = new J("SysvarRewards111111111111111111111111111111")),
      (KU = new J("SysvarS1otHashes111111111111111111111111111")),
      (qU = new J("SysvarS1otHistory11111111111111111111111111")),
      (Np = new J("SysvarStakeHistory1111111111111111111111111")),
      (Yo = class extends Error {
        constructor({
          action: e,
          signature: t,
          transactionMessage: r,
          logs: i,
        }) {
          let s = i
              ? `Logs: 
${JSON.stringify(i.slice(-10), null, 2)}. `
              : "",
            o =
              "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.",
            a;
          switch (e) {
            case "send":
              a =
                `Transaction ${t} resulted in an error. 
${r}. ` +
                s +
                o;
              break;
            case "simulate":
              a =
                `Simulation failed. 
Message: ${r}. 
` +
                s +
                o;
              break;
            default:
              a = `Unknown action '${((c) => c)(e)}'`;
          }
          super(a),
            (this.signature = void 0),
            (this.transactionMessage = void 0),
            (this.transactionLogs = void 0),
            (this.signature = t),
            (this.transactionMessage = r),
            (this.transactionLogs = i || void 0);
        }
        get transactionError() {
          return {
            message: this.transactionMessage,
            logs: Array.isArray(this.transactionLogs)
              ? this.transactionLogs
              : void 0,
          };
        }
        get logs() {
          let e = this.transactionLogs;
          if (!(e != null && typeof e == "object" && "then" in e)) return e;
        }
        getLogs(e) {
          return d(this, null, function* () {
            return (
              Array.isArray(this.transactionLogs) ||
                (this.transactionLogs = new Promise((t, r) => {
                  e.getTransaction(this.signature)
                    .then((i) => {
                      if (i && i.meta && i.meta.logMessages) {
                        let s = i.meta.logMessages;
                        (this.transactionLogs = s), t(s);
                      } else r(new Error("Log messages not found"));
                    })
                    .catch(r);
                })),
              yield this.transactionLogs
            );
          });
        }
      }),
      (QU = {
        JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
        JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:
          -32003,
        JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
        JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
        JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:
          -32006,
        JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
        JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
        JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
        JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
        JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
        JSON_RPC_SCAN_ERROR: -32012,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
        JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
        JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
        JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,
      }),
      (ce = class extends Error {
        constructor({ code: e, message: t, data: r }, i) {
          super(i != null ? `${i}: ${t}` : t),
            (this.code = void 0),
            (this.data = void 0),
            (this.code = e),
            (this.data = r),
            (this.name = "SolanaJSONRPCError");
        }
      });
    (C2 = A.nu64("lamportsPerSignature")),
      (k2 = A.struct([
        A.u32("version"),
        A.u32("state"),
        Le("authorizedPubkey"),
        Le("nonce"),
        A.struct([C2], "feeCalculator"),
      ])),
      (fb = k2.span),
      (zp = class n {
        constructor(e) {
          (this.authorizedPubkey = void 0),
            (this.nonce = void 0),
            (this.feeCalculator = void 0),
            (this.authorizedPubkey = e.authorizedPubkey),
            (this.nonce = e.nonce),
            (this.feeCalculator = e.feeCalculator);
        }
        static fromAccountData(e) {
          let t = k2.decode(Be(e), 0);
          return new n({
            authorizedPubkey: new J(t.authorizedPubkey),
            nonce: new J(t.nonce).toString(),
            feeCalculator: t.feeCalculator,
          });
        }
      }),
      (JU = (n) => {
        let e = n.decode.bind(n),
          t = n.encode.bind(n);
        return { decode: e, encode: t };
      }),
      (YU = (n) => (e) => {
        let t = (0, b2.blob)(n, e),
          { encode: r, decode: i } = JU(t),
          s = t;
        return (
          (s.decode = (o, a) => {
            let c = i(o, a);
            return (0, ih.toBigIntLE)(we.Buffer.from(c));
          }),
          (s.encode = (o, a, c) => {
            let u = (0, ih.toBufferLE)(o, n);
            return r(u, a, c);
          }),
          s
        );
      }),
      (Qc = YU(8)),
      (db = class {
        constructor() {}
        static decodeInstructionType(e) {
          this.checkProgramId(e.programId);
          let r = A.u32("instruction").decode(e.data),
            i;
          for (let [s, o] of Object.entries(ft))
            if (o.index == r) {
              i = s;
              break;
            }
          if (!i)
            throw new Error(
              "Instruction type incorrect; not a SystemInstruction"
            );
          return i;
        }
        static decodeCreateAccount(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
          let { lamports: t, space: r, programId: i } = Ze(ft.Create, e.data);
          return {
            fromPubkey: e.keys[0].pubkey,
            newAccountPubkey: e.keys[1].pubkey,
            lamports: t,
            space: r,
            programId: new J(i),
          };
        }
        static decodeTransfer(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
          let { lamports: t } = Ze(ft.Transfer, e.data);
          return {
            fromPubkey: e.keys[0].pubkey,
            toPubkey: e.keys[1].pubkey,
            lamports: t,
          };
        }
        static decodeTransferWithSeed(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
          let {
            lamports: t,
            seed: r,
            programId: i,
          } = Ze(ft.TransferWithSeed, e.data);
          return {
            fromPubkey: e.keys[0].pubkey,
            basePubkey: e.keys[1].pubkey,
            toPubkey: e.keys[2].pubkey,
            lamports: t,
            seed: r,
            programId: new J(i),
          };
        }
        static decodeAllocate(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
          let { space: t } = Ze(ft.Allocate, e.data);
          return { accountPubkey: e.keys[0].pubkey, space: t };
        }
        static decodeAllocateWithSeed(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
          let {
            base: t,
            seed: r,
            space: i,
            programId: s,
          } = Ze(ft.AllocateWithSeed, e.data);
          return {
            accountPubkey: e.keys[0].pubkey,
            basePubkey: new J(t),
            seed: r,
            space: i,
            programId: new J(s),
          };
        }
        static decodeAssign(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
          let { programId: t } = Ze(ft.Assign, e.data);
          return { accountPubkey: e.keys[0].pubkey, programId: new J(t) };
        }
        static decodeAssignWithSeed(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
          let {
            base: t,
            seed: r,
            programId: i,
          } = Ze(ft.AssignWithSeed, e.data);
          return {
            accountPubkey: e.keys[0].pubkey,
            basePubkey: new J(t),
            seed: r,
            programId: new J(i),
          };
        }
        static decodeCreateWithSeed(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
          let {
            base: t,
            seed: r,
            lamports: i,
            space: s,
            programId: o,
          } = Ze(ft.CreateWithSeed, e.data);
          return {
            fromPubkey: e.keys[0].pubkey,
            newAccountPubkey: e.keys[1].pubkey,
            basePubkey: new J(t),
            seed: r,
            lamports: i,
            space: s,
            programId: new J(o),
          };
        }
        static decodeNonceInitialize(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
          let { authorized: t } = Ze(ft.InitializeNonceAccount, e.data);
          return { noncePubkey: e.keys[0].pubkey, authorizedPubkey: new J(t) };
        }
        static decodeNonceAdvance(e) {
          return (
            this.checkProgramId(e.programId),
            this.checkKeyLength(e.keys, 3),
            Ze(ft.AdvanceNonceAccount, e.data),
            {
              noncePubkey: e.keys[0].pubkey,
              authorizedPubkey: e.keys[2].pubkey,
            }
          );
        }
        static decodeNonceWithdraw(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
          let { lamports: t } = Ze(ft.WithdrawNonceAccount, e.data);
          return {
            noncePubkey: e.keys[0].pubkey,
            toPubkey: e.keys[1].pubkey,
            authorizedPubkey: e.keys[4].pubkey,
            lamports: t,
          };
        }
        static decodeNonceAuthorize(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
          let { authorized: t } = Ze(ft.AuthorizeNonceAccount, e.data);
          return {
            noncePubkey: e.keys[0].pubkey,
            authorizedPubkey: e.keys[1].pubkey,
            newAuthorizedPubkey: new J(t),
          };
        }
        static checkProgramId(e) {
          if (!e.equals(an.programId))
            throw new Error(
              "invalid instruction; programId is not SystemProgram"
            );
        }
        static checkKeyLength(e, t) {
          if (e.length < t)
            throw new Error(
              `invalid instruction; found ${e.length} keys, expected at least ${t}`
            );
        }
      }),
      (ft = Object.freeze({
        Create: {
          index: 0,
          layout: A.struct([
            A.u32("instruction"),
            A.ns64("lamports"),
            A.ns64("space"),
            Le("programId"),
          ]),
        },
        Assign: {
          index: 1,
          layout: A.struct([A.u32("instruction"), Le("programId")]),
        },
        Transfer: {
          index: 2,
          layout: A.struct([A.u32("instruction"), Qc("lamports")]),
        },
        CreateWithSeed: {
          index: 3,
          layout: A.struct([
            A.u32("instruction"),
            Le("base"),
            qo("seed"),
            A.ns64("lamports"),
            A.ns64("space"),
            Le("programId"),
          ]),
        },
        AdvanceNonceAccount: {
          index: 4,
          layout: A.struct([A.u32("instruction")]),
        },
        WithdrawNonceAccount: {
          index: 5,
          layout: A.struct([A.u32("instruction"), A.ns64("lamports")]),
        },
        InitializeNonceAccount: {
          index: 6,
          layout: A.struct([A.u32("instruction"), Le("authorized")]),
        },
        AuthorizeNonceAccount: {
          index: 7,
          layout: A.struct([A.u32("instruction"), Le("authorized")]),
        },
        Allocate: {
          index: 8,
          layout: A.struct([A.u32("instruction"), A.ns64("space")]),
        },
        AllocateWithSeed: {
          index: 9,
          layout: A.struct([
            A.u32("instruction"),
            Le("base"),
            qo("seed"),
            A.ns64("space"),
            Le("programId"),
          ]),
        },
        AssignWithSeed: {
          index: 10,
          layout: A.struct([
            A.u32("instruction"),
            Le("base"),
            qo("seed"),
            Le("programId"),
          ]),
        },
        TransferWithSeed: {
          index: 11,
          layout: A.struct([
            A.u32("instruction"),
            Qc("lamports"),
            qo("seed"),
            Le("programId"),
          ]),
        },
        UpgradeNonceAccount: {
          index: 12,
          layout: A.struct([A.u32("instruction")]),
        },
      })),
      (an = class n {
        constructor() {}
        static createAccount(e) {
          let t = ft.Create,
            r = Ue(t, {
              lamports: e.lamports,
              space: e.space,
              programId: Be(e.programId.toBuffer()),
            });
          return new tt({
            keys: [
              { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
              { pubkey: e.newAccountPubkey, isSigner: !0, isWritable: !0 },
            ],
            programId: this.programId,
            data: r,
          });
        }
        static transfer(e) {
          let t, r;
          if ("basePubkey" in e) {
            let i = ft.TransferWithSeed;
            (t = Ue(i, {
              lamports: BigInt(e.lamports),
              seed: e.seed,
              programId: Be(e.programId.toBuffer()),
            })),
              (r = [
                { pubkey: e.fromPubkey, isSigner: !1, isWritable: !0 },
                { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
                { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
              ]);
          } else {
            let i = ft.Transfer;
            (t = Ue(i, { lamports: BigInt(e.lamports) })),
              (r = [
                { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
                { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
              ]);
          }
          return new tt({ keys: r, programId: this.programId, data: t });
        }
        static assign(e) {
          let t, r;
          if ("basePubkey" in e) {
            let i = ft.AssignWithSeed;
            (t = Ue(i, {
              base: Be(e.basePubkey.toBuffer()),
              seed: e.seed,
              programId: Be(e.programId.toBuffer()),
            })),
              (r = [
                { pubkey: e.accountPubkey, isSigner: !1, isWritable: !0 },
                { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
              ]);
          } else {
            let i = ft.Assign;
            (t = Ue(i, { programId: Be(e.programId.toBuffer()) })),
              (r = [{ pubkey: e.accountPubkey, isSigner: !0, isWritable: !0 }]);
          }
          return new tt({ keys: r, programId: this.programId, data: t });
        }
        static createAccountWithSeed(e) {
          let t = ft.CreateWithSeed,
            r = Ue(t, {
              base: Be(e.basePubkey.toBuffer()),
              seed: e.seed,
              lamports: e.lamports,
              space: e.space,
              programId: Be(e.programId.toBuffer()),
            }),
            i = [
              { pubkey: e.fromPubkey, isSigner: !0, isWritable: !0 },
              { pubkey: e.newAccountPubkey, isSigner: !1, isWritable: !0 },
            ];
          return (
            e.basePubkey.equals(e.fromPubkey) ||
              i.push({ pubkey: e.basePubkey, isSigner: !0, isWritable: !1 }),
            new tt({ keys: i, programId: this.programId, data: r })
          );
        }
        static createNonceAccount(e) {
          let t = new Ne();
          "basePubkey" in e && "seed" in e
            ? t.add(
                n.createAccountWithSeed({
                  fromPubkey: e.fromPubkey,
                  newAccountPubkey: e.noncePubkey,
                  basePubkey: e.basePubkey,
                  seed: e.seed,
                  lamports: e.lamports,
                  space: fb,
                  programId: this.programId,
                })
              )
            : t.add(
                n.createAccount({
                  fromPubkey: e.fromPubkey,
                  newAccountPubkey: e.noncePubkey,
                  lamports: e.lamports,
                  space: fb,
                  programId: this.programId,
                })
              );
          let r = {
            noncePubkey: e.noncePubkey,
            authorizedPubkey: e.authorizedPubkey,
          };
          return t.add(this.nonceInitialize(r)), t;
        }
        static nonceInitialize(e) {
          let t = ft.InitializeNonceAccount,
            r = Ue(t, { authorized: Be(e.authorizedPubkey.toBuffer()) }),
            i = {
              keys: [
                { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
                { pubkey: Op, isSigner: !1, isWritable: !1 },
                { pubkey: qc, isSigner: !1, isWritable: !1 },
              ],
              programId: this.programId,
              data: r,
            };
          return new tt(i);
        }
        static nonceAdvance(e) {
          let t = ft.AdvanceNonceAccount,
            r = Ue(t),
            i = {
              keys: [
                { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
                { pubkey: Op, isSigner: !1, isWritable: !1 },
                { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 },
              ],
              programId: this.programId,
              data: r,
            };
          return new tt(i);
        }
        static nonceWithdraw(e) {
          let t = ft.WithdrawNonceAccount,
            r = Ue(t, { lamports: e.lamports });
          return new tt({
            keys: [
              { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
              { pubkey: e.toPubkey, isSigner: !1, isWritable: !0 },
              { pubkey: Op, isSigner: !1, isWritable: !1 },
              { pubkey: qc, isSigner: !1, isWritable: !1 },
              { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: r,
          });
        }
        static nonceAuthorize(e) {
          let t = ft.AuthorizeNonceAccount,
            r = Ue(t, { authorized: Be(e.newAuthorizedPubkey.toBuffer()) });
          return new tt({
            keys: [
              { pubkey: e.noncePubkey, isSigner: !1, isWritable: !0 },
              { pubkey: e.authorizedPubkey, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: r,
          });
        }
        static allocate(e) {
          let t, r;
          if ("basePubkey" in e) {
            let i = ft.AllocateWithSeed;
            (t = Ue(i, {
              base: Be(e.basePubkey.toBuffer()),
              seed: e.seed,
              space: e.space,
              programId: Be(e.programId.toBuffer()),
            })),
              (r = [
                { pubkey: e.accountPubkey, isSigner: !1, isWritable: !0 },
                { pubkey: e.basePubkey, isSigner: !0, isWritable: !1 },
              ]);
          } else {
            let i = ft.Allocate;
            (t = Ue(i, { space: e.space })),
              (r = [{ pubkey: e.accountPubkey, isSigner: !0, isWritable: !0 }]);
          }
          return new tt({ keys: r, programId: this.programId, data: t });
        }
      });
    an.programId = new J("11111111111111111111111111111111");
    (ZU = js - 300),
      (pb = (() => {
        class n {
          constructor() {}
          static getMinNumSignatures(t) {
            return 2 * (Math.ceil(t / n.chunkSize) + 1 + 1);
          }
          static load(t, r, i, s, o) {
            return d(this, null, function* () {
              {
                let f = yield t.getMinimumBalanceForRentExemption(o.length),
                  g = yield t.getAccountInfo(i.publicKey, "confirmed"),
                  y = null;
                if (g !== null) {
                  if (g.executable)
                    return (
                      console.error(
                        "Program load failed, account is already executable"
                      ),
                      !1
                    );
                  g.data.length !== o.length &&
                    ((y = y || new Ne()),
                    y.add(
                      an.allocate({
                        accountPubkey: i.publicKey,
                        space: o.length,
                      })
                    )),
                    g.owner.equals(s) ||
                      ((y = y || new Ne()),
                      y.add(
                        an.assign({ accountPubkey: i.publicKey, programId: s })
                      )),
                    g.lamports < f &&
                      ((y = y || new Ne()),
                      y.add(
                        an.transfer({
                          fromPubkey: r.publicKey,
                          toPubkey: i.publicKey,
                          lamports: f - g.lamports,
                        })
                      ));
                } else y = new Ne().add(an.createAccount({ fromPubkey: r.publicKey, newAccountPubkey: i.publicKey, lamports: f > 0 ? f : 1, space: o.length, programId: s }));
                y !== null &&
                  (yield hb(t, y, [r, i], { commitment: "confirmed" }));
              }
              let a = A.struct([
                  A.u32("instruction"),
                  A.u32("offset"),
                  A.u32("bytesLength"),
                  A.u32("bytesLengthPadding"),
                  A.seq(A.u8("byte"), A.offset(A.u32(), -8), "bytes"),
                ]),
                c = n.chunkSize,
                u = 0,
                l = o,
                h = [];
              for (; l.length > 0; ) {
                let f = l.slice(0, c),
                  g = we.Buffer.alloc(c + 16);
                a.encode(
                  {
                    instruction: 0,
                    offset: u,
                    bytes: f,
                    bytesLength: 0,
                    bytesLengthPadding: 0,
                  },
                  g
                );
                let y = new Ne().add({
                  keys: [{ pubkey: i.publicKey, isSigner: !0, isWritable: !0 }],
                  programId: s,
                  data: g,
                });
                h.push(hb(t, y, [r, i], { commitment: "confirmed" })),
                  t._rpcEndpoint.includes("solana.com") && (yield Ko(1e3 / 4)),
                  (u += c),
                  (l = l.slice(c));
              }
              yield Promise.all(h);
              {
                let f = A.struct([A.u32("instruction")]),
                  g = we.Buffer.alloc(f.span);
                f.encode({ instruction: 1 }, g);
                let y = new Ne().add({
                    keys: [
                      { pubkey: i.publicKey, isSigner: !0, isWritable: !0 },
                      { pubkey: qc, isSigner: !1, isWritable: !1 },
                    ],
                    programId: s,
                    data: g,
                  }),
                  w = "processed",
                  m = yield t.sendTransaction(y, [r, i], {
                    preflightCommitment: w,
                  }),
                  { context: b, value: I } = yield t.confirmTransaction(
                    {
                      signature: m,
                      lastValidBlockHeight: y.lastValidBlockHeight,
                      blockhash: y.recentBlockhash,
                    },
                    w
                  );
                if (I.err)
                  throw new Error(
                    `Transaction ${m} failed (${JSON.stringify(I)})`
                  );
                for (;;) {
                  try {
                    if ((yield t.getSlot({ commitment: w })) > b.slot) break;
                  } catch {}
                  yield new Promise((E) => setTimeout(E, Math.round(I2 / 2)));
                }
              }
              return !0;
            });
          }
        }
        return (n.chunkSize = ZU), n;
      })()),
      (XU = new J("BPFLoader2111111111111111111111111111111111")),
      (gb = class {
        static getMinNumSignatures(e) {
          return pb.getMinNumSignatures(e);
        }
        static load(e, t, r, i, s) {
          return pb.load(e, t, r, s, i);
        }
      });
    (n4 = t4()), (s2 = e4(n4)), (Ql = 32);
    (jp = class {
      constructor(e, t, r, i, s) {
        (this.slotsPerEpoch = void 0),
          (this.leaderScheduleSlotOffset = void 0),
          (this.warmup = void 0),
          (this.firstNormalEpoch = void 0),
          (this.firstNormalSlot = void 0),
          (this.slotsPerEpoch = e),
          (this.leaderScheduleSlotOffset = t),
          (this.warmup = r),
          (this.firstNormalEpoch = i),
          (this.firstNormalSlot = s);
      }
      getEpoch(e) {
        return this.getEpochAndSlotIndex(e)[0];
      }
      getEpochAndSlotIndex(e) {
        if (e < this.firstNormalSlot) {
          let t = rb(r4(e + Ql + 1)) - rb(Ql) - 1,
            r = this.getSlotsInEpoch(t),
            i = e - (r - Ql);
          return [t, i];
        } else {
          let t = e - this.firstNormalSlot,
            r = Math.floor(t / this.slotsPerEpoch),
            i = this.firstNormalEpoch + r,
            s = t % this.slotsPerEpoch;
          return [i, s];
        }
      }
      getFirstSlotInEpoch(e) {
        return e <= this.firstNormalEpoch
          ? (Math.pow(2, e) - 1) * Ql
          : (e - this.firstNormalEpoch) * this.slotsPerEpoch +
              this.firstNormalSlot;
      }
      getLastSlotInEpoch(e) {
        return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1;
      }
      getSlotsInEpoch(e) {
        return e < this.firstNormalEpoch
          ? Math.pow(2, e + rb(Ql))
          : this.slotsPerEpoch;
      }
    }),
      (i4 = globalThis.fetch),
      (mb = class extends Ck {
        constructor(e, t, r) {
          let i = (s) => {
            let o = Ik(
              s,
              v(
                {
                  autoconnect: !0,
                  max_reconnects: 5,
                  reconnect: !0,
                  reconnect_interval: 1e3,
                },
                t
              )
            );
            return (
              "socket" in o
                ? (this.underlyingSocket = o.socket)
                : (this.underlyingSocket = o),
              o
            );
          };
          super(i, e, t, r), (this.underlyingSocket = void 0);
        }
        call(...e) {
          let t = this.underlyingSocket?.readyState;
          return t === 1
            ? super.call(...e)
            : Promise.reject(
                new Error(
                  "Tried to call a JSON-RPC method `" +
                    e[0] +
                    "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                    t +
                    ")"
                )
              );
        }
        notify(...e) {
          let t = this.underlyingSocket?.readyState;
          return t === 1
            ? super.notify(...e)
            : Promise.reject(
                new Error(
                  "Tried to send a JSON-RPC notification `" +
                    e[0] +
                    "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
                    t +
                    ")"
                )
              );
        }
      });
    (o2 = 56),
      (eh = class {
        constructor(e) {
          (this.key = void 0),
            (this.state = void 0),
            (this.key = e.key),
            (this.state = e.state);
        }
        isActive() {
          let e = BigInt("0xffffffffffffffff");
          return this.state.deactivationSlot === e;
        }
        static deserialize(e) {
          let t = s4(o4, e),
            r = e.length - o2;
          Ve(r >= 0, "lookup table is invalid"),
            Ve(r % 32 === 0, "lookup table is invalid");
          let i = r / 32,
            { addresses: s } = A.struct([A.seq(Le(), i, "addresses")]).decode(
              e.slice(o2)
            );
          return {
            deactivationSlot: t.deactivationSlot,
            lastExtendedSlot: t.lastExtendedSlot,
            lastExtendedSlotStartIndex: t.lastExtendedStartIndex,
            authority:
              t.authority.length !== 0 ? new J(t.authority[0]) : void 0,
            addresses: s.map((o) => new J(o)),
          };
        }
      }),
      (o4 = {
        index: 1,
        layout: A.struct([
          A.u32("typeIndex"),
          Qc("deactivationSlot"),
          A.nu64("lastExtendedSlot"),
          A.u8("lastExtendedStartIndex"),
          A.u8(),
          A.seq(Le(), A.offset(A.u8(), -1), "authority"),
        ]),
      }),
      (a4 = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i);
    (vt = Wc(Ip(J), G(), (n) => new J(n))),
      (T2 = Cp([G(), bt("base64")])),
      (kb = Wc(Ip(we.Buffer), T2, (n) => we.Buffer.from(n[0], "base64"))),
      (R2 = 30 * 1e3);
    l4 = B2($o());
    (h4 = z({
      foundation: C(),
      foundationTerm: C(),
      initial: C(),
      taper: C(),
      terminal: C(),
    })),
      (f4 = Re(
        te(
          ne(
            z({
              epoch: C(),
              effectiveSlot: C(),
              amount: C(),
              postBalance: C(),
              commission: de(ne(C())),
            })
          )
        )
      )),
      (d4 = te(z({ slot: C(), prioritizationFee: C() }))),
      (p4 = z({ total: C(), validator: C(), foundation: C(), epoch: C() })),
      (g4 = z({
        epoch: C(),
        slotIndex: C(),
        slotsInEpoch: C(),
        absoluteSlot: C(),
        blockHeight: de(C()),
        transactionCount: de(C()),
      })),
      (m4 = z({
        slotsPerEpoch: C(),
        leaderScheduleSlotOffset: C(),
        warmup: Ur(),
        firstNormalEpoch: C(),
        firstNormalSlot: C(),
      })),
      (y4 = jw(G(), te(C()))),
      (Xo = ne(wn([z({}), G()]))),
      (w4 = z({ err: Xo })),
      (b4 = bt("receivedSignature")),
      (A4 = z({ "solana-core": G(), "feature-set": de(C()) })),
      (E4 = z({ program: G(), programId: vt, parsed: $o() })),
      (x4 = z({ programId: vt, accounts: te(vt), data: G() })),
      (c2 = kt(
        z({
          err: ne(wn([z({}), G()])),
          logs: ne(te(G())),
          accounts: de(
            ne(
              te(
                ne(
                  z({
                    executable: Ur(),
                    owner: G(),
                    lamports: C(),
                    data: te(G()),
                    rentEpoch: de(C()),
                  })
                )
              )
            )
          ),
          unitsConsumed: de(C()),
          returnData: de(
            ne(z({ programId: G(), data: Cp([G(), bt("base64")]) }))
          ),
          innerInstructions: de(
            ne(te(z({ index: C(), instructions: te(wn([E4, x4])) })))
          ),
        })
      )),
      (S4 = kt(
        z({
          byIdentity: jw(G(), te(C())),
          range: z({ firstSlot: C(), lastSlot: C() }),
        })
      ));
    (k4 = Re(h4)),
      (T4 = Re(p4)),
      (R4 = Re(d4)),
      (B4 = Re(g4)),
      (D4 = Re(m4)),
      (_4 = Re(y4)),
      (P4 = Re(C())),
      (L4 = kt(
        z({
          total: C(),
          circulating: C(),
          nonCirculating: C(),
          nonCirculatingAccounts: te(vt),
        })
      )),
      (yb = z({
        amount: G(),
        uiAmount: ne(C()),
        decimals: C(),
        uiAmountString: de(G()),
      })),
      (O4 = kt(
        te(
          z({
            address: vt,
            amount: G(),
            uiAmount: ne(C()),
            decimals: C(),
            uiAmountString: de(G()),
          })
        )
      )),
      (N4 = kt(
        te(
          z({
            pubkey: vt,
            account: z({
              executable: Ur(),
              owner: vt,
              lamports: C(),
              data: kb,
              rentEpoch: C(),
            }),
          })
        )
      )),
      (wb = z({ program: G(), parsed: $o(), space: C() })),
      (F4 = kt(
        te(
          z({
            pubkey: vt,
            account: z({
              executable: Ur(),
              owner: vt,
              lamports: C(),
              data: wb,
              rentEpoch: C(),
            }),
          })
        )
      )),
      (M4 = kt(te(z({ lamports: C(), address: vt })))),
      (th = z({
        executable: Ur(),
        owner: vt,
        lamports: C(),
        data: kb,
        rentEpoch: C(),
      })),
      (U4 = z({ pubkey: vt, account: th })),
      (z4 = Wc(wn([Ip(we.Buffer), wb]), wn([T2, wb]), (n) =>
        Array.isArray(n) ? Q(n, kb) : n
      )),
      (bb = z({
        executable: Ur(),
        owner: vt,
        lamports: C(),
        data: z4,
        rentEpoch: C(),
      })),
      (j4 = z({ pubkey: vt, account: bb })),
      (W4 = z({
        state: wn([
          bt("active"),
          bt("inactive"),
          bt("activating"),
          bt("deactivating"),
        ]),
        active: C(),
        inactive: C(),
      })),
      (H4 = Re(
        te(
          z({
            signature: G(),
            slot: C(),
            err: Xo,
            memo: ne(G()),
            blockTime: de(ne(C())),
          })
        )
      )),
      (V4 = Re(
        te(
          z({
            signature: G(),
            slot: C(),
            err: Xo,
            memo: ne(G()),
            blockTime: de(ne(C())),
          })
        )
      )),
      ($4 = z({ subscription: C(), result: Qp(th) })),
      (G4 = z({ pubkey: vt, account: th })),
      (K4 = z({ subscription: C(), result: Qp(G4) })),
      (q4 = z({ parent: C(), slot: C(), root: C() })),
      (Q4 = z({ subscription: C(), result: q4 })),
      (J4 = wn([
        z({
          type: wn([
            bt("firstShredReceived"),
            bt("completed"),
            bt("optimisticConfirmation"),
            bt("root"),
          ]),
          slot: C(),
          timestamp: C(),
        }),
        z({ type: bt("createdBank"), parent: C(), slot: C(), timestamp: C() }),
        z({
          type: bt("frozen"),
          slot: C(),
          timestamp: C(),
          stats: z({
            numTransactionEntries: C(),
            numSuccessfulTransactions: C(),
            numFailedTransactions: C(),
            maxTransactionsPerEntry: C(),
          }),
        }),
        z({ type: bt("dead"), slot: C(), timestamp: C(), err: G() }),
      ])),
      (Y4 = z({ subscription: C(), result: J4 })),
      (Z4 = z({ subscription: C(), result: Qp(wn([w4, b4])) })),
      (X4 = z({ subscription: C(), result: C() })),
      (e6 = z({
        pubkey: G(),
        gossip: ne(G()),
        tpu: ne(G()),
        rpc: ne(G()),
        version: ne(G()),
      })),
      (u2 = z({
        votePubkey: G(),
        nodePubkey: G(),
        activatedStake: C(),
        epochVoteAccount: Ur(),
        epochCredits: te(Cp([C(), C(), C()])),
        commission: C(),
        lastVote: C(),
        rootSlot: ne(C()),
      })),
      (t6 = Re(z({ current: te(u2), delinquent: te(u2) }))),
      (n6 = wn([bt("processed"), bt("confirmed"), bt("finalized")])),
      (r6 = z({
        slot: C(),
        confirmations: ne(C()),
        err: Xo,
        confirmationStatus: de(n6),
      })),
      (i6 = kt(te(ne(r6)))),
      (s6 = Re(C())),
      (D2 = z({
        accountKey: vt,
        writableIndexes: te(C()),
        readonlyIndexes: te(C()),
      })),
      (Tb = z({
        signatures: te(G()),
        message: z({
          accountKeys: te(G()),
          header: z({
            numRequiredSignatures: C(),
            numReadonlySignedAccounts: C(),
            numReadonlyUnsignedAccounts: C(),
          }),
          instructions: te(
            z({ accounts: te(C()), data: G(), programIdIndex: C() })
          ),
          recentBlockhash: G(),
          addressTableLookups: de(te(D2)),
        }),
      })),
      (_2 = z({
        pubkey: vt,
        signer: Ur(),
        writable: Ur(),
        source: de(wn([bt("transaction"), bt("lookupTable")])),
      })),
      (P2 = z({ accountKeys: te(_2), signatures: te(G()) })),
      (L2 = z({ parsed: $o(), program: G(), programId: vt })),
      (O2 = z({ accounts: te(vt), data: G(), programId: vt })),
      (o6 = wn([O2, L2])),
      (a6 = wn([
        z({ parsed: $o(), program: G(), programId: G() }),
        z({ accounts: te(G()), data: G(), programId: G() }),
      ])),
      (N2 = Wc(o6, a6, (n) => ("accounts" in n ? Q(n, O2) : Q(n, L2)))),
      (F2 = z({
        signatures: te(G()),
        message: z({
          accountKeys: te(_2),
          instructions: te(N2),
          recentBlockhash: G(),
          addressTableLookups: de(ne(te(D2))),
        }),
      })),
      (Wp = z({
        accountIndex: C(),
        mint: G(),
        owner: de(G()),
        programId: de(G()),
        uiTokenAmount: yb,
      })),
      (M2 = z({ writable: te(vt), readonly: te(vt) })),
      (Jp = z({
        err: Xo,
        fee: C(),
        innerInstructions: de(
          ne(
            te(
              z({
                index: C(),
                instructions: te(
                  z({ accounts: te(C()), data: G(), programIdIndex: C() })
                ),
              })
            )
          )
        ),
        preBalances: te(C()),
        postBalances: te(C()),
        logMessages: de(ne(te(G()))),
        preTokenBalances: de(ne(te(Wp))),
        postTokenBalances: de(ne(te(Wp))),
        loadedAddresses: de(M2),
        computeUnitsConsumed: de(C()),
      })),
      (Rb = z({
        err: Xo,
        fee: C(),
        innerInstructions: de(ne(te(z({ index: C(), instructions: te(N2) })))),
        preBalances: te(C()),
        postBalances: te(C()),
        logMessages: de(ne(te(G()))),
        preTokenBalances: de(ne(te(Wp))),
        postTokenBalances: de(ne(te(Wp))),
        loadedAddresses: de(M2),
        computeUnitsConsumed: de(C()),
      })),
      (eu = wn([bt(0), bt("legacy")])),
      (ea = z({
        pubkey: G(),
        lamports: C(),
        postBalance: ne(C()),
        rewardType: ne(G()),
        commission: de(ne(C())),
      })),
      (c6 = Re(
        ne(
          z({
            blockhash: G(),
            previousBlockhash: G(),
            parentSlot: C(),
            transactions: te(
              z({ transaction: Tb, meta: ne(Jp), version: de(eu) })
            ),
            rewards: de(te(ea)),
            blockTime: ne(C()),
            blockHeight: ne(C()),
          })
        )
      )),
      (u6 = Re(
        ne(
          z({
            blockhash: G(),
            previousBlockhash: G(),
            parentSlot: C(),
            rewards: de(te(ea)),
            blockTime: ne(C()),
            blockHeight: ne(C()),
          })
        )
      )),
      (l6 = Re(
        ne(
          z({
            blockhash: G(),
            previousBlockhash: G(),
            parentSlot: C(),
            transactions: te(
              z({ transaction: P2, meta: ne(Jp), version: de(eu) })
            ),
            rewards: de(te(ea)),
            blockTime: ne(C()),
            blockHeight: ne(C()),
          })
        )
      )),
      (h6 = Re(
        ne(
          z({
            blockhash: G(),
            previousBlockhash: G(),
            parentSlot: C(),
            transactions: te(
              z({ transaction: F2, meta: ne(Rb), version: de(eu) })
            ),
            rewards: de(te(ea)),
            blockTime: ne(C()),
            blockHeight: ne(C()),
          })
        )
      )),
      (f6 = Re(
        ne(
          z({
            blockhash: G(),
            previousBlockhash: G(),
            parentSlot: C(),
            transactions: te(
              z({ transaction: P2, meta: ne(Rb), version: de(eu) })
            ),
            rewards: de(te(ea)),
            blockTime: ne(C()),
            blockHeight: ne(C()),
          })
        )
      )),
      (d6 = Re(
        ne(
          z({
            blockhash: G(),
            previousBlockhash: G(),
            parentSlot: C(),
            rewards: de(te(ea)),
            blockTime: ne(C()),
            blockHeight: ne(C()),
          })
        )
      )),
      (p6 = Re(
        ne(
          z({
            blockhash: G(),
            previousBlockhash: G(),
            parentSlot: C(),
            transactions: te(z({ transaction: Tb, meta: ne(Jp) })),
            rewards: de(te(ea)),
            blockTime: ne(C()),
          })
        )
      )),
      (l2 = Re(
        ne(
          z({
            blockhash: G(),
            previousBlockhash: G(),
            parentSlot: C(),
            signatures: te(G()),
            blockTime: ne(C()),
          })
        )
      )),
      (sb = Re(
        ne(
          z({
            slot: C(),
            meta: ne(Jp),
            blockTime: de(ne(C())),
            transaction: Tb,
            version: de(eu),
          })
        )
      )),
      (Lp = Re(
        ne(
          z({
            slot: C(),
            transaction: F2,
            meta: ne(Rb),
            blockTime: de(ne(C())),
            version: de(eu),
          })
        )
      )),
      (g6 = kt(
        z({ blockhash: G(), feeCalculator: z({ lamportsPerSignature: C() }) })
      )),
      (m6 = kt(z({ blockhash: G(), lastValidBlockHeight: C() }))),
      (y6 = kt(Ur())),
      (w6 = z({
        slot: C(),
        numTransactions: C(),
        numSlots: C(),
        samplePeriodSecs: C(),
      })),
      (b6 = Re(te(w6))),
      (A6 = kt(ne(z({ feeCalculator: z({ lamportsPerSignature: C() }) })))),
      (E6 = Re(G())),
      (x6 = Re(G())),
      (S6 = z({ err: Xo, logs: te(G()), signature: G() })),
      (v6 = z({ result: Qp(S6), subscription: C() })),
      (I6 = { "solana-client": "js/1.0.0-maintenance" }),
      (Jc = class {
        constructor(e, t) {
          (this._commitment = void 0),
            (this._confirmTransactionInitialTimeout = void 0),
            (this._rpcEndpoint = void 0),
            (this._rpcWsEndpoint = void 0),
            (this._rpcClient = void 0),
            (this._rpcRequest = void 0),
            (this._rpcBatchRequest = void 0),
            (this._rpcWebSocket = void 0),
            (this._rpcWebSocketConnected = !1),
            (this._rpcWebSocketHeartbeat = null),
            (this._rpcWebSocketIdleTimeout = null),
            (this._rpcWebSocketGeneration = 0),
            (this._disableBlockhashCaching = !1),
            (this._pollingBlockhash = !1),
            (this._blockhashInfo = {
              latestBlockhash: null,
              lastFetch: 0,
              transactionSignatures: [],
              simulatedSignatures: [],
            }),
            (this._nextClientSubscriptionId = 0),
            (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
            (this._subscriptionHashByClientSubscriptionId = {}),
            (this._subscriptionStateChangeCallbacksByHash = {}),
            (this._subscriptionCallbacksByServerSubscriptionId = {}),
            (this._subscriptionsByHash = {}),
            (this._subscriptionsAutoDisposedByRpc = new Set()),
            (this.getBlockHeight = (() => {
              let u = {};
              return (l) =>
                d(this, null, function* () {
                  let { commitment: h, config: f } = ht(l),
                    g = this._buildArgs([], h, void 0, f),
                    y = s2(g);
                  return (
                    (u[y] =
                      u[y] ??
                      d(this, null, function* () {
                        try {
                          let w = yield this._rpcRequest("getBlockHeight", g),
                            m = Q(w, Re(C()));
                          if ("error" in m)
                            throw new ce(
                              m.error,
                              "failed to get block height information"
                            );
                          return m.result;
                        } finally {
                          delete u[y];
                        }
                      })),
                    yield u[y]
                  );
                });
            })());
          let r, i, s, o, a, c;
          t && typeof t == "string"
            ? (this._commitment = t)
            : t &&
              ((this._commitment = t.commitment),
              (this._confirmTransactionInitialTimeout =
                t.confirmTransactionInitialTimeout),
              (r = t.wsEndpoint),
              (i = t.httpHeaders),
              (s = t.fetch),
              (o = t.fetchMiddleware),
              (a = t.disableRetryOnRateLimit),
              (c = t.httpAgent)),
            (this._rpcEndpoint = u4(e)),
            (this._rpcWsEndpoint = r || c4(e)),
            (this._rpcClient = v4(e, i, s, o, a, c)),
            (this._rpcRequest = I4(this._rpcClient)),
            (this._rpcBatchRequest = C4(this._rpcClient)),
            (this._rpcWebSocket = new mb(this._rpcWsEndpoint, {
              autoconnect: !1,
              max_reconnects: 1 / 0,
            })),
            this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
            this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
            this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
            this._rpcWebSocket.on(
              "accountNotification",
              this._wsOnAccountNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "programNotification",
              this._wsOnProgramAccountNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "slotNotification",
              this._wsOnSlotNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "slotsUpdatesNotification",
              this._wsOnSlotUpdatesNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "signatureNotification",
              this._wsOnSignatureNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "rootNotification",
              this._wsOnRootNotification.bind(this)
            ),
            this._rpcWebSocket.on(
              "logsNotification",
              this._wsOnLogsNotification.bind(this)
            );
        }
        get commitment() {
          return this._commitment;
        }
        get rpcEndpoint() {
          return this._rpcEndpoint;
        }
        getBalanceAndContext(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = this._buildArgs([e.toBase58()], r, void 0, i),
              o = yield this._rpcRequest("getBalance", s),
              a = Q(o, kt(C()));
            if ("error" in a)
              throw new ce(
                a.error,
                `failed to get balance for ${e.toBase58()}`
              );
            return a.result;
          });
        }
        getBalance(e, t) {
          return d(this, null, function* () {
            return yield this.getBalanceAndContext(e, t)
              .then((r) => r.value)
              .catch((r) => {
                throw new Error(
                  "failed to get balance of account " + e.toBase58() + ": " + r
                );
              });
          });
        }
        getBlockTime(e) {
          return d(this, null, function* () {
            let t = yield this._rpcRequest("getBlockTime", [e]),
              r = Q(t, Re(ne(C())));
            if ("error" in r)
              throw new ce(r.error, `failed to get block time for slot ${e}`);
            return r.result;
          });
        }
        getMinimumLedgerSlot() {
          return d(this, null, function* () {
            let e = yield this._rpcRequest("minimumLedgerSlot", []),
              t = Q(e, Re(C()));
            if ("error" in t)
              throw new ce(t.error, "failed to get minimum ledger slot");
            return t.result;
          });
        }
        getFirstAvailableBlock() {
          return d(this, null, function* () {
            let e = yield this._rpcRequest("getFirstAvailableBlock", []),
              t = Q(e, P4);
            if ("error" in t)
              throw new ce(t.error, "failed to get first available block");
            return t.result;
          });
        }
        getSupply(e) {
          return d(this, null, function* () {
            let t = {};
            typeof e == "string"
              ? (t = { commitment: e })
              : e
              ? (t = $(v({}, e), {
                  commitment: (e && e.commitment) || this.commitment,
                }))
              : (t = { commitment: this.commitment });
            let r = yield this._rpcRequest("getSupply", [t]),
              i = Q(r, L4);
            if ("error" in i) throw new ce(i.error, "failed to get supply");
            return i.result;
          });
        }
        getTokenSupply(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgs([e.toBase58()], t),
              i = yield this._rpcRequest("getTokenSupply", r),
              s = Q(i, kt(yb));
            if ("error" in s)
              throw new ce(s.error, "failed to get token supply");
            return s.result;
          });
        }
        getTokenAccountBalance(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgs([e.toBase58()], t),
              i = yield this._rpcRequest("getTokenAccountBalance", r),
              s = Q(i, kt(yb));
            if ("error" in s)
              throw new ce(s.error, "failed to get token account balance");
            return s.result;
          });
        }
        getTokenAccountsByOwner(e, t, r) {
          return d(this, null, function* () {
            let { commitment: i, config: s } = ht(r),
              o = [e.toBase58()];
            "mint" in t
              ? o.push({ mint: t.mint.toBase58() })
              : o.push({ programId: t.programId.toBase58() });
            let a = this._buildArgs(o, i, "base64", s),
              c = yield this._rpcRequest("getTokenAccountsByOwner", a),
              u = Q(c, N4);
            if ("error" in u)
              throw new ce(
                u.error,
                `failed to get token accounts owned by account ${e.toBase58()}`
              );
            return u.result;
          });
        }
        getParsedTokenAccountsByOwner(e, t, r) {
          return d(this, null, function* () {
            let i = [e.toBase58()];
            "mint" in t
              ? i.push({ mint: t.mint.toBase58() })
              : i.push({ programId: t.programId.toBase58() });
            let s = this._buildArgs(i, r, "jsonParsed"),
              o = yield this._rpcRequest("getTokenAccountsByOwner", s),
              a = Q(o, F4);
            if ("error" in a)
              throw new ce(
                a.error,
                `failed to get token accounts owned by account ${e.toBase58()}`
              );
            return a.result;
          });
        }
        getLargestAccounts(e) {
          return d(this, null, function* () {
            let t = $(v({}, e), {
                commitment: (e && e.commitment) || this.commitment,
              }),
              r = t.filter || t.commitment ? [t] : [],
              i = yield this._rpcRequest("getLargestAccounts", r),
              s = Q(i, M4);
            if ("error" in s)
              throw new ce(s.error, "failed to get largest accounts");
            return s.result;
          });
        }
        getTokenLargestAccounts(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgs([e.toBase58()], t),
              i = yield this._rpcRequest("getTokenLargestAccounts", r),
              s = Q(i, O4);
            if ("error" in s)
              throw new ce(s.error, "failed to get token largest accounts");
            return s.result;
          });
        }
        getAccountInfoAndContext(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = this._buildArgs([e.toBase58()], r, "base64", i),
              o = yield this._rpcRequest("getAccountInfo", s),
              a = Q(o, kt(ne(th)));
            if ("error" in a)
              throw new ce(
                a.error,
                `failed to get info about account ${e.toBase58()}`
              );
            return a.result;
          });
        }
        getParsedAccountInfo(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = this._buildArgs([e.toBase58()], r, "jsonParsed", i),
              o = yield this._rpcRequest("getAccountInfo", s),
              a = Q(o, kt(ne(bb)));
            if ("error" in a)
              throw new ce(
                a.error,
                `failed to get info about account ${e.toBase58()}`
              );
            return a.result;
          });
        }
        getAccountInfo(e, t) {
          return d(this, null, function* () {
            try {
              return (yield this.getAccountInfoAndContext(e, t)).value;
            } catch (r) {
              throw new Error(
                "failed to get info about account " + e.toBase58() + ": " + r
              );
            }
          });
        }
        getMultipleParsedAccounts(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = e.map((u) => u.toBase58()),
              o = this._buildArgs([s], r, "jsonParsed", i),
              a = yield this._rpcRequest("getMultipleAccounts", o),
              c = Q(a, kt(te(ne(bb))));
            if ("error" in c)
              throw new ce(c.error, `failed to get info for accounts ${s}`);
            return c.result;
          });
        }
        getMultipleAccountsInfoAndContext(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = e.map((u) => u.toBase58()),
              o = this._buildArgs([s], r, "base64", i),
              a = yield this._rpcRequest("getMultipleAccounts", o),
              c = Q(a, kt(te(ne(th))));
            if ("error" in c)
              throw new ce(c.error, `failed to get info for accounts ${s}`);
            return c.result;
          });
        }
        getMultipleAccountsInfo(e, t) {
          return d(this, null, function* () {
            return (yield this.getMultipleAccountsInfoAndContext(e, t)).value;
          });
        }
        getStakeActivation(e, t, r) {
          return d(this, null, function* () {
            let { commitment: i, config: s } = ht(t),
              o = this._buildArgs(
                [e.toBase58()],
                i,
                void 0,
                $(v({}, s), { epoch: r ?? s?.epoch })
              ),
              a = yield this._rpcRequest("getStakeActivation", o),
              c = Q(a, Re(W4));
            if ("error" in c)
              throw new ce(
                c.error,
                `failed to get Stake Activation ${e.toBase58()}`
              );
            return c.result;
          });
        }
        getProgramAccounts(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              h = i || {},
              { encoding: s } = h,
              o = ln(h, ["encoding"]),
              a = this._buildArgs(
                [e.toBase58()],
                r,
                s || "base64",
                v(v({}, o), o.filters ? { filters: a2(o.filters) } : null)
              ),
              c = yield this._rpcRequest("getProgramAccounts", a),
              u = te(U4),
              l = o.withContext === !0 ? Q(c, kt(u)) : Q(c, Re(u));
            if ("error" in l)
              throw new ce(
                l.error,
                `failed to get accounts owned by program ${e.toBase58()}`
              );
            return l.result;
          });
        }
        getParsedProgramAccounts(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = this._buildArgs([e.toBase58()], r, "jsonParsed", i),
              o = yield this._rpcRequest("getProgramAccounts", s),
              a = Q(o, Re(te(j4)));
            if ("error" in a)
              throw new ce(
                a.error,
                `failed to get accounts owned by program ${e.toBase58()}`
              );
            return a.result;
          });
        }
        confirmTransaction(e, t) {
          return d(this, null, function* () {
            let r;
            if (typeof e == "string") r = e;
            else {
              let s = e;
              if (s.abortSignal?.aborted)
                return Promise.reject(s.abortSignal.reason);
              r = s.signature;
            }
            let i;
            try {
              i = Xt.default.decode(r);
            } catch {
              throw new Error("signature must be base58 encoded: " + r);
            }
            return (
              Ve(i.length === 64, "signature has invalid length"),
              typeof e == "string"
                ? yield this.confirmTransactionUsingLegacyTimeoutStrategy({
                    commitment: t || this.commitment,
                    signature: r,
                  })
                : "lastValidBlockHeight" in e
                ? yield this.confirmTransactionUsingBlockHeightExceedanceStrategy(
                    { commitment: t || this.commitment, strategy: e }
                  )
                : yield this.confirmTransactionUsingDurableNonceStrategy({
                    commitment: t || this.commitment,
                    strategy: e,
                  })
            );
          });
        }
        getCancellationPromise(e) {
          return new Promise((t, r) => {
            e != null &&
              (e.aborted
                ? r(e.reason)
                : e.addEventListener("abort", () => {
                    r(e.reason);
                  }));
          });
        }
        getTransactionConfirmationPromise({ commitment: e, signature: t }) {
          let r,
            i,
            s = !1,
            o = new Promise((c, u) => {
              try {
                r = this.onSignature(
                  t,
                  (h, f) => {
                    r = void 0;
                    let g = { context: f, value: h };
                    c({ __type: Hi.PROCESSED, response: g });
                  },
                  e
                );
                let l = new Promise((h) => {
                  r == null
                    ? h()
                    : (i = this._onSubscriptionStateChange(r, (f) => {
                        f === "subscribed" && h();
                      }));
                });
                d(this, null, function* () {
                  if ((yield l, s)) return;
                  let h = yield this.getSignatureStatus(t);
                  if (s || h == null) return;
                  let { context: f, value: g } = h;
                  if (g != null)
                    if (g?.err) u(g.err);
                    else {
                      switch (e) {
                        case "confirmed":
                        case "single":
                        case "singleGossip": {
                          if (g.confirmationStatus === "processed") return;
                          break;
                        }
                        case "finalized":
                        case "max":
                        case "root": {
                          if (
                            g.confirmationStatus === "processed" ||
                            g.confirmationStatus === "confirmed"
                          )
                            return;
                          break;
                        }
                        case "processed":
                        case "recent":
                      }
                      (s = !0),
                        c({
                          __type: Hi.PROCESSED,
                          response: { context: f, value: g },
                        });
                    }
                });
              } catch (l) {
                u(l);
              }
            });
          return {
            abortConfirmation: () => {
              i && (i(), (i = void 0)),
                r != null && (this.removeSignatureListener(r), (r = void 0));
            },
            confirmationPromise: o,
          };
        }
        confirmTransactionUsingBlockHeightExceedanceStrategy(s) {
          return d(
            this,
            arguments,
            function* ({
              commitment: e,
              strategy: {
                abortSignal: t,
                lastValidBlockHeight: r,
                signature: i,
              },
            }) {
              let o = !1,
                a = new Promise((f) => {
                  let g = () =>
                    d(this, null, function* () {
                      try {
                        return yield this.getBlockHeight(e);
                      } catch {
                        return -1;
                      }
                    });
                  d(this, null, function* () {
                    let y = yield g();
                    if (!o) {
                      for (; y <= r; )
                        if ((yield Ko(1e3), o || ((y = yield g()), o))) return;
                      f({ __type: Hi.BLOCKHEIGHT_EXCEEDED });
                    }
                  });
                }),
                { abortConfirmation: c, confirmationPromise: u } =
                  this.getTransactionConfirmationPromise({
                    commitment: e,
                    signature: i,
                  }),
                l = this.getCancellationPromise(t),
                h;
              try {
                let f = yield Promise.race([l, u, a]);
                if (f.__type === Hi.PROCESSED) h = f.response;
                else throw new Zl(i);
              } finally {
                (o = !0), c();
              }
              return h;
            }
          );
        }
        confirmTransactionUsingDurableNonceStrategy(a) {
          return d(
            this,
            arguments,
            function* ({
              commitment: e,
              strategy: {
                abortSignal: t,
                minContextSlot: r,
                nonceAccountPubkey: i,
                nonceValue: s,
                signature: o,
              },
            }) {
              let c = !1,
                u = new Promise((y) => {
                  let w = s,
                    m = null,
                    b = () =>
                      d(this, null, function* () {
                        try {
                          let { context: I, value: E } =
                            yield this.getNonceAndContext(i, {
                              commitment: e,
                              minContextSlot: r,
                            });
                          return (m = I.slot), E?.nonce;
                        } catch {
                          return w;
                        }
                      });
                  d(this, null, function* () {
                    if (((w = yield b()), !c))
                      for (;;) {
                        if (s !== w) {
                          y({
                            __type: Hi.NONCE_INVALID,
                            slotInWhichNonceDidAdvance: m,
                          });
                          return;
                        }
                        if ((yield Ko(2e3), c || ((w = yield b()), c))) return;
                      }
                  });
                }),
                { abortConfirmation: l, confirmationPromise: h } =
                  this.getTransactionConfirmationPromise({
                    commitment: e,
                    signature: o,
                  }),
                f = this.getCancellationPromise(t),
                g;
              try {
                let y = yield Promise.race([f, h, u]);
                if (y.__type === Hi.PROCESSED) g = y.response;
                else {
                  let w;
                  for (;;) {
                    let m = yield this.getSignatureStatus(o);
                    if (m == null) break;
                    if (m.context.slot < (y.slotInWhichNonceDidAdvance ?? r)) {
                      yield Ko(400);
                      continue;
                    }
                    w = m;
                    break;
                  }
                  if (w?.value) {
                    let m = e || "finalized",
                      { confirmationStatus: b } = w.value;
                    switch (m) {
                      case "processed":
                      case "recent":
                        if (
                          b !== "processed" &&
                          b !== "confirmed" &&
                          b !== "finalized"
                        )
                          throw new zs(o);
                        break;
                      case "confirmed":
                      case "single":
                      case "singleGossip":
                        if (b !== "confirmed" && b !== "finalized")
                          throw new zs(o);
                        break;
                      case "finalized":
                      case "max":
                      case "root":
                        if (b !== "finalized") throw new zs(o);
                        break;
                      default:
                    }
                    g = { context: w.context, value: { err: w.value.err } };
                  } else throw new zs(o);
                }
              } finally {
                (c = !0), l();
              }
              return g;
            }
          );
        }
        confirmTransactionUsingLegacyTimeoutStrategy(r) {
          return d(
            this,
            arguments,
            function* ({ commitment: e, signature: t }) {
              let i,
                s = new Promise((u) => {
                  let l = this._confirmTransactionInitialTimeout || 6e4;
                  switch (e) {
                    case "processed":
                    case "recent":
                    case "single":
                    case "confirmed":
                    case "singleGossip": {
                      l = this._confirmTransactionInitialTimeout || 3e4;
                      break;
                    }
                  }
                  i = setTimeout(
                    () => u({ __type: Hi.TIMED_OUT, timeoutMs: l }),
                    l
                  );
                }),
                { abortConfirmation: o, confirmationPromise: a } =
                  this.getTransactionConfirmationPromise({
                    commitment: e,
                    signature: t,
                  }),
                c;
              try {
                let u = yield Promise.race([a, s]);
                if (u.__type === Hi.PROCESSED) c = u.response;
                else throw new Xl(t, u.timeoutMs / 1e3);
              } finally {
                clearTimeout(i), o();
              }
              return c;
            }
          );
        }
        getClusterNodes() {
          return d(this, null, function* () {
            let e = yield this._rpcRequest("getClusterNodes", []),
              t = Q(e, Re(te(e6)));
            if ("error" in t)
              throw new ce(t.error, "failed to get cluster nodes");
            return t.result;
          });
        }
        getVoteAccounts(e) {
          return d(this, null, function* () {
            let t = this._buildArgs([], e),
              r = yield this._rpcRequest("getVoteAccounts", t),
              i = Q(r, t6);
            if ("error" in i)
              throw new ce(i.error, "failed to get vote accounts");
            return i.result;
          });
        }
        getSlot(e) {
          return d(this, null, function* () {
            let { commitment: t, config: r } = ht(e),
              i = this._buildArgs([], t, void 0, r),
              s = yield this._rpcRequest("getSlot", i),
              o = Q(s, Re(C()));
            if ("error" in o) throw new ce(o.error, "failed to get slot");
            return o.result;
          });
        }
        getSlotLeader(e) {
          return d(this, null, function* () {
            let { commitment: t, config: r } = ht(e),
              i = this._buildArgs([], t, void 0, r),
              s = yield this._rpcRequest("getSlotLeader", i),
              o = Q(s, Re(G()));
            if ("error" in o)
              throw new ce(o.error, "failed to get slot leader");
            return o.result;
          });
        }
        getSlotLeaders(e, t) {
          return d(this, null, function* () {
            let r = [e, t],
              i = yield this._rpcRequest("getSlotLeaders", r),
              s = Q(i, Re(te(vt)));
            if ("error" in s)
              throw new ce(s.error, "failed to get slot leaders");
            return s.result;
          });
        }
        getSignatureStatus(e, t) {
          return d(this, null, function* () {
            let { context: r, value: i } = yield this.getSignatureStatuses(
              [e],
              t
            );
            Ve(i.length === 1);
            let s = i[0];
            return { context: r, value: s };
          });
        }
        getSignatureStatuses(e, t) {
          return d(this, null, function* () {
            let r = [e];
            t && r.push(t);
            let i = yield this._rpcRequest("getSignatureStatuses", r),
              s = Q(i, i6);
            if ("error" in s)
              throw new ce(s.error, "failed to get signature status");
            return s.result;
          });
        }
        getTransactionCount(e) {
          return d(this, null, function* () {
            let { commitment: t, config: r } = ht(e),
              i = this._buildArgs([], t, void 0, r),
              s = yield this._rpcRequest("getTransactionCount", i),
              o = Q(s, Re(C()));
            if ("error" in o)
              throw new ce(o.error, "failed to get transaction count");
            return o.result;
          });
        }
        getTotalSupply(e) {
          return d(this, null, function* () {
            return (yield this.getSupply({
              commitment: e,
              excludeNonCirculatingAccountsList: !0,
            })).value.total;
          });
        }
        getInflationGovernor(e) {
          return d(this, null, function* () {
            let t = this._buildArgs([], e),
              r = yield this._rpcRequest("getInflationGovernor", t),
              i = Q(r, k4);
            if ("error" in i) throw new ce(i.error, "failed to get inflation");
            return i.result;
          });
        }
        getInflationReward(e, t, r) {
          return d(this, null, function* () {
            let { commitment: i, config: s } = ht(r),
              o = this._buildArgs(
                [e.map((u) => u.toBase58())],
                i,
                void 0,
                $(v({}, s), { epoch: t ?? s?.epoch })
              ),
              a = yield this._rpcRequest("getInflationReward", o),
              c = Q(a, f4);
            if ("error" in c)
              throw new ce(c.error, "failed to get inflation reward");
            return c.result;
          });
        }
        getInflationRate() {
          return d(this, null, function* () {
            let e = yield this._rpcRequest("getInflationRate", []),
              t = Q(e, T4);
            if ("error" in t)
              throw new ce(t.error, "failed to get inflation rate");
            return t.result;
          });
        }
        getEpochInfo(e) {
          return d(this, null, function* () {
            let { commitment: t, config: r } = ht(e),
              i = this._buildArgs([], t, void 0, r),
              s = yield this._rpcRequest("getEpochInfo", i),
              o = Q(s, B4);
            if ("error" in o) throw new ce(o.error, "failed to get epoch info");
            return o.result;
          });
        }
        getEpochSchedule() {
          return d(this, null, function* () {
            let e = yield this._rpcRequest("getEpochSchedule", []),
              t = Q(e, D4);
            if ("error" in t)
              throw new ce(t.error, "failed to get epoch schedule");
            let r = t.result;
            return new jp(
              r.slotsPerEpoch,
              r.leaderScheduleSlotOffset,
              r.warmup,
              r.firstNormalEpoch,
              r.firstNormalSlot
            );
          });
        }
        getLeaderSchedule() {
          return d(this, null, function* () {
            let e = yield this._rpcRequest("getLeaderSchedule", []),
              t = Q(e, _4);
            if ("error" in t)
              throw new ce(t.error, "failed to get leader schedule");
            return t.result;
          });
        }
        getMinimumBalanceForRentExemption(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgs([e], t),
              i = yield this._rpcRequest(
                "getMinimumBalanceForRentExemption",
                r
              ),
              s = Q(i, s6);
            return "error" in s
              ? (console.warn(
                  "Unable to fetch minimum balance for rent exemption"
                ),
                0)
              : s.result;
          });
        }
        getRecentBlockhashAndContext(e) {
          return d(this, null, function* () {
            let t = this._buildArgs([], e),
              r = yield this._rpcRequest("getRecentBlockhash", t),
              i = Q(r, g6);
            if ("error" in i)
              throw new ce(i.error, "failed to get recent blockhash");
            return i.result;
          });
        }
        getRecentPerformanceSamples(e) {
          return d(this, null, function* () {
            let t = yield this._rpcRequest(
                "getRecentPerformanceSamples",
                e ? [e] : []
              ),
              r = Q(t, b6);
            if ("error" in r)
              throw new ce(r.error, "failed to get recent performance samples");
            return r.result;
          });
        }
        getFeeCalculatorForBlockhash(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgs([e], t),
              i = yield this._rpcRequest("getFeeCalculatorForBlockhash", r),
              s = Q(i, A6);
            if ("error" in s)
              throw new ce(s.error, "failed to get fee calculator");
            let { context: o, value: a } = s.result;
            return { context: o, value: a !== null ? a.feeCalculator : null };
          });
        }
        getFeeForMessage(e, t) {
          return d(this, null, function* () {
            let r = Be(e.serialize()).toString("base64"),
              i = this._buildArgs([r], t),
              s = yield this._rpcRequest("getFeeForMessage", i),
              o = Q(s, kt(ne(C())));
            if ("error" in o)
              throw new ce(o.error, "failed to get fee for message");
            if (o.result === null) throw new Error("invalid blockhash");
            return o.result;
          });
        }
        getRecentPrioritizationFees(e) {
          return d(this, null, function* () {
            let t = e?.lockedWritableAccounts?.map((o) => o.toBase58()),
              r = t?.length ? [t] : [],
              i = yield this._rpcRequest("getRecentPrioritizationFees", r),
              s = Q(i, R4);
            if ("error" in s)
              throw new ce(s.error, "failed to get recent prioritization fees");
            return s.result;
          });
        }
        getRecentBlockhash(e) {
          return d(this, null, function* () {
            try {
              return (yield this.getRecentBlockhashAndContext(e)).value;
            } catch (t) {
              throw new Error("failed to get recent blockhash: " + t);
            }
          });
        }
        getLatestBlockhash(e) {
          return d(this, null, function* () {
            try {
              return (yield this.getLatestBlockhashAndContext(e)).value;
            } catch (t) {
              throw new Error("failed to get recent blockhash: " + t);
            }
          });
        }
        getLatestBlockhashAndContext(e) {
          return d(this, null, function* () {
            let { commitment: t, config: r } = ht(e),
              i = this._buildArgs([], t, void 0, r),
              s = yield this._rpcRequest("getLatestBlockhash", i),
              o = Q(s, m6);
            if ("error" in o)
              throw new ce(o.error, "failed to get latest blockhash");
            return o.result;
          });
        }
        isBlockhashValid(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = this._buildArgs([e], r, void 0, i),
              o = yield this._rpcRequest("isBlockhashValid", s),
              a = Q(o, y6);
            if ("error" in a)
              throw new ce(
                a.error,
                "failed to determine if the blockhash `" + e + "`is valid"
              );
            return a.result;
          });
        }
        getVersion() {
          return d(this, null, function* () {
            let e = yield this._rpcRequest("getVersion", []),
              t = Q(e, Re(A4));
            if ("error" in t) throw new ce(t.error, "failed to get version");
            return t.result;
          });
        }
        getGenesisHash() {
          return d(this, null, function* () {
            let e = yield this._rpcRequest("getGenesisHash", []),
              t = Q(e, Re(G()));
            if ("error" in t)
              throw new ce(t.error, "failed to get genesis hash");
            return t.result;
          });
        }
        getBlock(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = this._buildArgsAtLeastConfirmed([e], r, void 0, i),
              o = yield this._rpcRequest("getBlock", s);
            try {
              switch (i?.transactionDetails) {
                case "accounts": {
                  let a = Q(o, l6);
                  if ("error" in a) throw a.error;
                  return a.result;
                }
                case "none": {
                  let a = Q(o, u6);
                  if ("error" in a) throw a.error;
                  return a.result;
                }
                default: {
                  let a = Q(o, c6);
                  if ("error" in a) throw a.error;
                  let { result: c } = a;
                  return c
                    ? $(v({}, c), {
                        transactions: c.transactions.map(
                          ({ transaction: u, meta: l, version: h }) => ({
                            meta: l,
                            transaction: $(v({}, u), {
                              message: ib(h, u.message),
                            }),
                            version: h,
                          })
                        ),
                      })
                    : null;
                }
              }
            } catch (a) {
              throw new ce(a, "failed to get confirmed block");
            }
          });
        }
        getParsedBlock(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed", i),
              o = yield this._rpcRequest("getBlock", s);
            try {
              switch (i?.transactionDetails) {
                case "accounts": {
                  let a = Q(o, f6);
                  if ("error" in a) throw a.error;
                  return a.result;
                }
                case "none": {
                  let a = Q(o, d6);
                  if ("error" in a) throw a.error;
                  return a.result;
                }
                default: {
                  let a = Q(o, h6);
                  if ("error" in a) throw a.error;
                  return a.result;
                }
              }
            } catch (a) {
              throw new ce(a, "failed to get block");
            }
          });
        }
        getBlockProduction(e) {
          return d(this, null, function* () {
            let t, r;
            if (typeof e == "string") r = e;
            else if (e) {
              let a = e,
                { commitment: c } = a,
                u = ln(a, ["commitment"]);
              (r = c), (t = u);
            }
            let i = this._buildArgs([], r, "base64", t),
              s = yield this._rpcRequest("getBlockProduction", i),
              o = Q(s, S4);
            if ("error" in o)
              throw new ce(
                o.error,
                "failed to get block production information"
              );
            return o.result;
          });
        }
        getTransaction(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = this._buildArgsAtLeastConfirmed([e], r, void 0, i),
              o = yield this._rpcRequest("getTransaction", s),
              a = Q(o, sb);
            if ("error" in a)
              throw new ce(a.error, "failed to get transaction");
            let c = a.result;
            return (
              c &&
              $(v({}, c), {
                transaction: $(v({}, c.transaction), {
                  message: ib(c.version, c.transaction.message),
                }),
              })
            );
          });
        }
        getParsedTransaction(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed", i),
              o = yield this._rpcRequest("getTransaction", s),
              a = Q(o, Lp);
            if ("error" in a)
              throw new ce(a.error, "failed to get transaction");
            return a.result;
          });
        }
        getParsedTransactions(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = e.map((c) => ({
                methodName: "getTransaction",
                args: this._buildArgsAtLeastConfirmed([c], r, "jsonParsed", i),
              }));
            return (yield this._rpcBatchRequest(s)).map((c) => {
              let u = Q(c, Lp);
              if ("error" in u)
                throw new ce(u.error, "failed to get transactions");
              return u.result;
            });
          });
        }
        getTransactions(e, t) {
          return d(this, null, function* () {
            let { commitment: r, config: i } = ht(t),
              s = e.map((c) => ({
                methodName: "getTransaction",
                args: this._buildArgsAtLeastConfirmed([c], r, void 0, i),
              }));
            return (yield this._rpcBatchRequest(s)).map((c) => {
              let u = Q(c, sb);
              if ("error" in u)
                throw new ce(u.error, "failed to get transactions");
              let l = u.result;
              return (
                l &&
                $(v({}, l), {
                  transaction: $(v({}, l.transaction), {
                    message: ib(l.version, l.transaction.message),
                  }),
                })
              );
            });
          });
        }
        getConfirmedBlock(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgsAtLeastConfirmed([e], t),
              i = yield this._rpcRequest("getConfirmedBlock", r),
              s = Q(i, p6);
            if ("error" in s)
              throw new ce(s.error, "failed to get confirmed block");
            let o = s.result;
            if (!o) throw new Error("Confirmed block " + e + " not found");
            let a = $(v({}, o), {
              transactions: o.transactions.map(
                ({ transaction: c, meta: u }) => {
                  let l = new ui(c.message);
                  return { meta: u, transaction: $(v({}, c), { message: l }) };
                }
              ),
            });
            return $(v({}, a), {
              transactions: a.transactions.map(
                ({ transaction: c, meta: u }) => ({
                  meta: u,
                  transaction: Ne.populate(c.message, c.signatures),
                })
              ),
            });
          });
        }
        getBlocks(e, t, r) {
          return d(this, null, function* () {
            let i = this._buildArgsAtLeastConfirmed(
                t !== void 0 ? [e, t] : [e],
                r
              ),
              s = yield this._rpcRequest("getBlocks", i),
              o = Q(s, Re(te(C())));
            if ("error" in o) throw new ce(o.error, "failed to get blocks");
            return o.result;
          });
        }
        getBlockSignatures(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgsAtLeastConfirmed([e], t, void 0, {
                transactionDetails: "signatures",
                rewards: !1,
              }),
              i = yield this._rpcRequest("getBlock", r),
              s = Q(i, l2);
            if ("error" in s) throw new ce(s.error, "failed to get block");
            let o = s.result;
            if (!o) throw new Error("Block " + e + " not found");
            return o;
          });
        }
        getConfirmedBlockSignatures(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgsAtLeastConfirmed([e], t, void 0, {
                transactionDetails: "signatures",
                rewards: !1,
              }),
              i = yield this._rpcRequest("getConfirmedBlock", r),
              s = Q(i, l2);
            if ("error" in s)
              throw new ce(s.error, "failed to get confirmed block");
            let o = s.result;
            if (!o) throw new Error("Confirmed block " + e + " not found");
            return o;
          });
        }
        getConfirmedTransaction(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgsAtLeastConfirmed([e], t),
              i = yield this._rpcRequest("getConfirmedTransaction", r),
              s = Q(i, sb);
            if ("error" in s)
              throw new ce(s.error, "failed to get transaction");
            let o = s.result;
            if (!o) return o;
            let a = new ui(o.transaction.message),
              c = o.transaction.signatures;
            return $(v({}, o), { transaction: Ne.populate(a, c) });
          });
        }
        getParsedConfirmedTransaction(e, t) {
          return d(this, null, function* () {
            let r = this._buildArgsAtLeastConfirmed([e], t, "jsonParsed"),
              i = yield this._rpcRequest("getConfirmedTransaction", r),
              s = Q(i, Lp);
            if ("error" in s)
              throw new ce(s.error, "failed to get confirmed transaction");
            return s.result;
          });
        }
        getParsedConfirmedTransactions(e, t) {
          return d(this, null, function* () {
            let r = e.map((o) => ({
              methodName: "getConfirmedTransaction",
              args: this._buildArgsAtLeastConfirmed([o], t, "jsonParsed"),
            }));
            return (yield this._rpcBatchRequest(r)).map((o) => {
              let a = Q(o, Lp);
              if ("error" in a)
                throw new ce(a.error, "failed to get confirmed transactions");
              return a.result;
            });
          });
        }
        getConfirmedSignaturesForAddress(e, t, r) {
          return d(this, null, function* () {
            let i = {},
              s = yield this.getFirstAvailableBlock();
            for (; !("until" in i) && (t--, !(t <= 0 || t < s)); )
              try {
                let c = yield this.getConfirmedBlockSignatures(t, "finalized");
                c.signatures.length > 0 &&
                  (i.until = c.signatures[c.signatures.length - 1].toString());
              } catch (c) {
                if (c instanceof Error && c.message.includes("skipped"))
                  continue;
                throw c;
              }
            let o = yield this.getSlot("finalized");
            for (; !("before" in i) && (r++, !(r > o)); )
              try {
                let c = yield this.getConfirmedBlockSignatures(r);
                c.signatures.length > 0 &&
                  (i.before = c.signatures[c.signatures.length - 1].toString());
              } catch (c) {
                if (c instanceof Error && c.message.includes("skipped"))
                  continue;
                throw c;
              }
            return (yield this.getConfirmedSignaturesForAddress2(e, i)).map(
              (c) => c.signature
            );
          });
        }
        getConfirmedSignaturesForAddress2(e, t, r) {
          return d(this, null, function* () {
            let i = this._buildArgsAtLeastConfirmed(
                [e.toBase58()],
                r,
                void 0,
                t
              ),
              s = yield this._rpcRequest(
                "getConfirmedSignaturesForAddress2",
                i
              ),
              o = Q(s, H4);
            if ("error" in o)
              throw new ce(
                o.error,
                "failed to get confirmed signatures for address"
              );
            return o.result;
          });
        }
        getSignaturesForAddress(e, t, r) {
          return d(this, null, function* () {
            let i = this._buildArgsAtLeastConfirmed(
                [e.toBase58()],
                r,
                void 0,
                t
              ),
              s = yield this._rpcRequest("getSignaturesForAddress", i),
              o = Q(s, V4);
            if ("error" in o)
              throw new ce(o.error, "failed to get signatures for address");
            return o.result;
          });
        }
        getAddressLookupTable(e, t) {
          return d(this, null, function* () {
            let { context: r, value: i } = yield this.getAccountInfoAndContext(
                e,
                t
              ),
              s = null;
            return (
              i !== null &&
                (s = new eh({ key: e, state: eh.deserialize(i.data) })),
              { context: r, value: s }
            );
          });
        }
        getNonceAndContext(e, t) {
          return d(this, null, function* () {
            let { context: r, value: i } = yield this.getAccountInfoAndContext(
                e,
                t
              ),
              s = null;
            return (
              i !== null && (s = zp.fromAccountData(i.data)),
              { context: r, value: s }
            );
          });
        }
        getNonce(e, t) {
          return d(this, null, function* () {
            return yield this.getNonceAndContext(e, t)
              .then((r) => r.value)
              .catch((r) => {
                throw new Error(
                  "failed to get nonce for account " + e.toBase58() + ": " + r
                );
              });
          });
        }
        requestAirdrop(e, t) {
          return d(this, null, function* () {
            let r = yield this._rpcRequest("requestAirdrop", [e.toBase58(), t]),
              i = Q(r, E6);
            if ("error" in i)
              throw new ce(i.error, `airdrop to ${e.toBase58()} failed`);
            return i.result;
          });
        }
        _blockhashWithExpiryBlockHeight(e) {
          return d(this, null, function* () {
            if (!e) {
              for (; this._pollingBlockhash; ) yield Ko(100);
              let r = Date.now() - this._blockhashInfo.lastFetch >= R2;
              if (this._blockhashInfo.latestBlockhash !== null && !r)
                return this._blockhashInfo.latestBlockhash;
            }
            return yield this._pollNewBlockhash();
          });
        }
        _pollNewBlockhash() {
          return d(this, null, function* () {
            this._pollingBlockhash = !0;
            try {
              let e = Date.now(),
                t = this._blockhashInfo.latestBlockhash,
                r = t ? t.blockhash : null;
              for (let i = 0; i < 50; i++) {
                let s = yield this.getLatestBlockhash("finalized");
                if (r !== s.blockhash)
                  return (
                    (this._blockhashInfo = {
                      latestBlockhash: s,
                      lastFetch: Date.now(),
                      transactionSignatures: [],
                      simulatedSignatures: [],
                    }),
                    s
                  );
                yield Ko(I2 / 2);
              }
              throw new Error(
                `Unable to obtain a new blockhash after ${Date.now() - e}ms`
              );
            } finally {
              this._pollingBlockhash = !1;
            }
          });
        }
        getStakeMinimumDelegation(e) {
          return d(this, null, function* () {
            let { commitment: t, config: r } = ht(e),
              i = this._buildArgs([], t, "base64", r),
              s = yield this._rpcRequest("getStakeMinimumDelegation", i),
              o = Q(s, kt(C()));
            if ("error" in o)
              throw new ce(o.error, "failed to get stake minimum delegation");
            return o.result;
          });
        }
        simulateTransaction(e, t, r) {
          return d(this, null, function* () {
            if ("message" in e) {
              let w = e.serialize(),
                m = we.Buffer.from(w).toString("base64");
              if (Array.isArray(t) || r !== void 0)
                throw new Error("Invalid arguments");
              let b = t || {};
              (b.encoding = "base64"),
                "commitment" in b || (b.commitment = this.commitment),
                t &&
                  typeof t == "object" &&
                  "innerInstructions" in t &&
                  (b.innerInstructions = t.innerInstructions);
              let I = [m, b],
                E = yield this._rpcRequest("simulateTransaction", I),
                T = Q(E, c2);
              if ("error" in T)
                throw new Error(
                  "failed to simulate transaction: " + T.error.message
                );
              return T.result;
            }
            let i;
            if (e instanceof Ne) {
              let y = e;
              (i = new Ne()),
                (i.feePayer = y.feePayer),
                (i.instructions = e.instructions),
                (i.nonceInfo = y.nonceInfo),
                (i.signatures = y.signatures);
            } else (i = Ne.populate(e)), (i._message = i._json = void 0);
            if (t !== void 0 && !Array.isArray(t))
              throw new Error("Invalid arguments");
            let s = t;
            if (i.nonceInfo && s) i.sign(...s);
            else {
              let y = this._disableBlockhashCaching;
              for (;;) {
                let w = yield this._blockhashWithExpiryBlockHeight(y);
                if (
                  ((i.lastValidBlockHeight = w.lastValidBlockHeight),
                  (i.recentBlockhash = w.blockhash),
                  !s)
                )
                  break;
                if ((i.sign(...s), !i.signature)) throw new Error("!signature");
                let m = i.signature.toString("base64");
                if (
                  !this._blockhashInfo.simulatedSignatures.includes(m) &&
                  !this._blockhashInfo.transactionSignatures.includes(m)
                ) {
                  this._blockhashInfo.simulatedSignatures.push(m);
                  break;
                } else y = !0;
              }
            }
            let o = i._compile(),
              a = o.serialize(),
              u = i._serialize(a).toString("base64"),
              l = { encoding: "base64", commitment: this.commitment };
            if (r) {
              let y = (Array.isArray(r) ? r : o.nonProgramIds()).map((w) =>
                w.toBase58()
              );
              l.accounts = { encoding: "base64", addresses: y };
            }
            s && (l.sigVerify = !0),
              t &&
                typeof t == "object" &&
                "innerInstructions" in t &&
                (l.innerInstructions = t.innerInstructions);
            let h = [u, l],
              f = yield this._rpcRequest("simulateTransaction", h),
              g = Q(f, c2);
            if ("error" in g) {
              let y;
              if (
                "data" in g.error &&
                ((y = g.error.data.logs), y && Array.isArray(y))
              ) {
                let w = `
    `,
                  m = w + y.join(w);
                console.error(g.error.message, m);
              }
              throw new Yo({
                action: "simulate",
                signature: "",
                transactionMessage: g.error.message,
                logs: y,
              });
            }
            return g.result;
          });
        }
        sendTransaction(e, t, r) {
          return d(this, null, function* () {
            if ("version" in e) {
              if (t && Array.isArray(t)) throw new Error("Invalid arguments");
              let o = e.serialize();
              return yield this.sendRawTransaction(o, t);
            }
            if (t === void 0 || !Array.isArray(t))
              throw new Error("Invalid arguments");
            let i = t;
            if (e.nonceInfo) e.sign(...i);
            else {
              let o = this._disableBlockhashCaching;
              for (;;) {
                let a = yield this._blockhashWithExpiryBlockHeight(o);
                if (
                  ((e.lastValidBlockHeight = a.lastValidBlockHeight),
                  (e.recentBlockhash = a.blockhash),
                  e.sign(...i),
                  !e.signature)
                )
                  throw new Error("!signature");
                let c = e.signature.toString("base64");
                if (this._blockhashInfo.transactionSignatures.includes(c))
                  o = !0;
                else {
                  this._blockhashInfo.transactionSignatures.push(c);
                  break;
                }
              }
            }
            let s = e.serialize();
            return yield this.sendRawTransaction(s, r);
          });
        }
        sendRawTransaction(e, t) {
          return d(this, null, function* () {
            let r = Be(e).toString("base64");
            return yield this.sendEncodedTransaction(r, t);
          });
        }
        sendEncodedTransaction(e, t) {
          return d(this, null, function* () {
            let r = { encoding: "base64" },
              i = t && t.skipPreflight,
              s =
                i === !0
                  ? "processed"
                  : (t && t.preflightCommitment) || this.commitment;
            t && t.maxRetries != null && (r.maxRetries = t.maxRetries),
              t &&
                t.minContextSlot != null &&
                (r.minContextSlot = t.minContextSlot),
              i && (r.skipPreflight = i),
              s && (r.preflightCommitment = s);
            let o = [e, r],
              a = yield this._rpcRequest("sendTransaction", o),
              c = Q(a, x6);
            if ("error" in c) {
              let u;
              throw (
                ("data" in c.error && (u = c.error.data.logs),
                new Yo({
                  action: i ? "send" : "simulate",
                  signature: "",
                  transactionMessage: c.error.message,
                  logs: u,
                }))
              );
            }
            return c.result;
          });
        }
        _wsOnOpen() {
          (this._rpcWebSocketConnected = !0),
            (this._rpcWebSocketHeartbeat = setInterval(() => {
              d(this, null, function* () {
                try {
                  yield this._rpcWebSocket.notify("ping");
                } catch {}
              });
            }, 5e3)),
            this._updateSubscriptions();
        }
        _wsOnError(e) {
          (this._rpcWebSocketConnected = !1),
            console.error("ws error:", e.message);
        }
        _wsOnClose(e) {
          if (
            ((this._rpcWebSocketConnected = !1),
            (this._rpcWebSocketGeneration =
              (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
            this._rpcWebSocketIdleTimeout &&
              (clearTimeout(this._rpcWebSocketIdleTimeout),
              (this._rpcWebSocketIdleTimeout = null)),
            this._rpcWebSocketHeartbeat &&
              (clearInterval(this._rpcWebSocketHeartbeat),
              (this._rpcWebSocketHeartbeat = null)),
            e === 1e3)
          ) {
            this._updateSubscriptions();
            return;
          }
          (this._subscriptionCallbacksByServerSubscriptionId = {}),
            Object.entries(this._subscriptionsByHash).forEach(([t, r]) => {
              this._setSubscription(t, $(v({}, r), { state: "pending" }));
            });
        }
        _setSubscription(e, t) {
          let r = this._subscriptionsByHash[e]?.state;
          if (((this._subscriptionsByHash[e] = t), r !== t.state)) {
            let i = this._subscriptionStateChangeCallbacksByHash[e];
            i &&
              i.forEach((s) => {
                try {
                  s(t.state);
                } catch {}
              });
          }
        }
        _onSubscriptionStateChange(e, t) {
          let r = this._subscriptionHashByClientSubscriptionId[e];
          if (r == null) return () => {};
          let i = (this._subscriptionStateChangeCallbacksByHash[r] ||=
            new Set());
          return (
            i.add(t),
            () => {
              i.delete(t),
                i.size === 0 &&
                  delete this._subscriptionStateChangeCallbacksByHash[r];
            }
          );
        }
        _updateSubscriptions() {
          return d(this, null, function* () {
            if (Object.keys(this._subscriptionsByHash).length === 0) {
              this._rpcWebSocketConnected &&
                ((this._rpcWebSocketConnected = !1),
                (this._rpcWebSocketIdleTimeout = setTimeout(() => {
                  this._rpcWebSocketIdleTimeout = null;
                  try {
                    this._rpcWebSocket.close();
                  } catch (r) {
                    r instanceof Error &&
                      console.log(
                        `Error when closing socket connection: ${r.message}`
                      );
                  }
                }, 500)));
              return;
            }
            if (
              (this._rpcWebSocketIdleTimeout !== null &&
                (clearTimeout(this._rpcWebSocketIdleTimeout),
                (this._rpcWebSocketIdleTimeout = null),
                (this._rpcWebSocketConnected = !0)),
              !this._rpcWebSocketConnected)
            ) {
              this._rpcWebSocket.connect();
              return;
            }
            let e = this._rpcWebSocketGeneration,
              t = () => e === this._rpcWebSocketGeneration;
            yield Promise.all(
              Object.keys(this._subscriptionsByHash).map((r) =>
                d(this, null, function* () {
                  let i = this._subscriptionsByHash[r];
                  if (i !== void 0)
                    switch (i.state) {
                      case "pending":
                      case "unsubscribed":
                        if (i.callbacks.size === 0) {
                          delete this._subscriptionsByHash[r],
                            i.state === "unsubscribed" &&
                              delete this
                                ._subscriptionCallbacksByServerSubscriptionId[
                                i.serverSubscriptionId
                              ],
                            yield this._updateSubscriptions();
                          return;
                        }
                        yield d(this, null, function* () {
                          let { args: s, method: o } = i;
                          try {
                            this._setSubscription(
                              r,
                              $(v({}, i), { state: "subscribing" })
                            );
                            let a = yield this._rpcWebSocket.call(o, s);
                            this._setSubscription(
                              r,
                              $(v({}, i), {
                                serverSubscriptionId: a,
                                state: "subscribed",
                              })
                            ),
                              (this._subscriptionCallbacksByServerSubscriptionId[
                                a
                              ] = i.callbacks),
                              yield this._updateSubscriptions();
                          } catch (a) {
                            if (
                              (console.error(
                                `Received ${
                                  a instanceof Error ? "" : "JSON-RPC "
                                }error calling \`${o}\``,
                                { args: s, error: a }
                              ),
                              !t())
                            )
                              return;
                            this._setSubscription(
                              r,
                              $(v({}, i), { state: "pending" })
                            ),
                              yield this._updateSubscriptions();
                          }
                        });
                        break;
                      case "subscribed":
                        i.callbacks.size === 0 &&
                          (yield d(this, null, function* () {
                            let {
                              serverSubscriptionId: s,
                              unsubscribeMethod: o,
                            } = i;
                            if (this._subscriptionsAutoDisposedByRpc.has(s))
                              this._subscriptionsAutoDisposedByRpc.delete(s);
                            else {
                              this._setSubscription(
                                r,
                                $(v({}, i), { state: "unsubscribing" })
                              ),
                                this._setSubscription(
                                  r,
                                  $(v({}, i), { state: "unsubscribing" })
                                );
                              try {
                                yield this._rpcWebSocket.call(o, [s]);
                              } catch (a) {
                                if (
                                  (a instanceof Error &&
                                    console.error(`${o} error:`, a.message),
                                  !t())
                                )
                                  return;
                                this._setSubscription(
                                  r,
                                  $(v({}, i), { state: "subscribed" })
                                ),
                                  yield this._updateSubscriptions();
                                return;
                              }
                            }
                            this._setSubscription(
                              r,
                              $(v({}, i), { state: "unsubscribed" })
                            ),
                              yield this._updateSubscriptions();
                          }));
                        break;
                    }
                })
              )
            );
          });
        }
        _handleServerNotification(e, t) {
          let r = this._subscriptionCallbacksByServerSubscriptionId[e];
          r !== void 0 &&
            r.forEach((i) => {
              try {
                i(...t);
              } catch (s) {
                console.error(s);
              }
            });
        }
        _wsOnAccountNotification(e) {
          let { result: t, subscription: r } = Q(e, $4);
          this._handleServerNotification(r, [t.value, t.context]);
        }
        _makeSubscription(e, t) {
          let r = this._nextClientSubscriptionId++,
            i = s2([e.method, t]),
            s = this._subscriptionsByHash[i];
          return (
            s === void 0
              ? (this._subscriptionsByHash[i] = $(v({}, e), {
                  args: t,
                  callbacks: new Set([e.callback]),
                  state: "pending",
                }))
              : s.callbacks.add(e.callback),
            (this._subscriptionHashByClientSubscriptionId[r] = i),
            (this._subscriptionDisposeFunctionsByClientSubscriptionId[r] = () =>
              d(this, null, function* () {
                delete this._subscriptionDisposeFunctionsByClientSubscriptionId[
                  r
                ],
                  delete this._subscriptionHashByClientSubscriptionId[r];
                let o = this._subscriptionsByHash[i];
                Ve(
                  o !== void 0,
                  `Could not find a \`Subscription\` when tearing down client subscription #${r}`
                ),
                  o.callbacks.delete(e.callback),
                  yield this._updateSubscriptions();
              })),
            this._updateSubscriptions(),
            r
          );
        }
        onAccountChange(e, t, r) {
          let { commitment: i, config: s } = ht(r),
            o = this._buildArgs(
              [e.toBase58()],
              i || this._commitment || "finalized",
              "base64",
              s
            );
          return this._makeSubscription(
            {
              callback: t,
              method: "accountSubscribe",
              unsubscribeMethod: "accountUnsubscribe",
            },
            o
          );
        }
        removeAccountChangeListener(e) {
          return d(this, null, function* () {
            yield this._unsubscribeClientSubscription(e, "account change");
          });
        }
        _wsOnProgramAccountNotification(e) {
          let { result: t, subscription: r } = Q(e, K4);
          this._handleServerNotification(r, [
            { accountId: t.value.pubkey, accountInfo: t.value.account },
            t.context,
          ]);
        }
        onProgramAccountChange(e, t, r, i) {
          let { commitment: s, config: o } = ht(r),
            a = this._buildArgs(
              [e.toBase58()],
              s || this._commitment || "finalized",
              "base64",
              o || (i ? { filters: a2(i) } : void 0)
            );
          return this._makeSubscription(
            {
              callback: t,
              method: "programSubscribe",
              unsubscribeMethod: "programUnsubscribe",
            },
            a
          );
        }
        removeProgramAccountChangeListener(e) {
          return d(this, null, function* () {
            yield this._unsubscribeClientSubscription(
              e,
              "program account change"
            );
          });
        }
        onLogs(e, t, r) {
          let i = this._buildArgs(
            [typeof e == "object" ? { mentions: [e.toString()] } : e],
            r || this._commitment || "finalized"
          );
          return this._makeSubscription(
            {
              callback: t,
              method: "logsSubscribe",
              unsubscribeMethod: "logsUnsubscribe",
            },
            i
          );
        }
        removeOnLogsListener(e) {
          return d(this, null, function* () {
            yield this._unsubscribeClientSubscription(e, "logs");
          });
        }
        _wsOnLogsNotification(e) {
          let { result: t, subscription: r } = Q(e, v6);
          this._handleServerNotification(r, [t.value, t.context]);
        }
        _wsOnSlotNotification(e) {
          let { result: t, subscription: r } = Q(e, Q4);
          this._handleServerNotification(r, [t]);
        }
        onSlotChange(e) {
          return this._makeSubscription(
            {
              callback: e,
              method: "slotSubscribe",
              unsubscribeMethod: "slotUnsubscribe",
            },
            []
          );
        }
        removeSlotChangeListener(e) {
          return d(this, null, function* () {
            yield this._unsubscribeClientSubscription(e, "slot change");
          });
        }
        _wsOnSlotUpdatesNotification(e) {
          let { result: t, subscription: r } = Q(e, Y4);
          this._handleServerNotification(r, [t]);
        }
        onSlotUpdate(e) {
          return this._makeSubscription(
            {
              callback: e,
              method: "slotsUpdatesSubscribe",
              unsubscribeMethod: "slotsUpdatesUnsubscribe",
            },
            []
          );
        }
        removeSlotUpdateListener(e) {
          return d(this, null, function* () {
            yield this._unsubscribeClientSubscription(e, "slot update");
          });
        }
        _unsubscribeClientSubscription(e, t) {
          return d(this, null, function* () {
            let r = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
            r
              ? yield r()
              : console.warn(
                  `Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`
                );
          });
        }
        _buildArgs(e, t, r, i) {
          let s = t || this._commitment;
          if (s || r || i) {
            let o = {};
            r && (o.encoding = r),
              s && (o.commitment = s),
              i && (o = Object.assign(o, i)),
              e.push(o);
          }
          return e;
        }
        _buildArgsAtLeastConfirmed(e, t, r, i) {
          let s = t || this._commitment;
          if (s && !["confirmed", "finalized"].includes(s))
            throw new Error(
              "Using Connection with default commitment: `" +
                this._commitment +
                "`, but method requires at least `confirmed`"
            );
          return this._buildArgs(e, t, r, i);
        }
        _wsOnSignatureNotification(e) {
          let { result: t, subscription: r } = Q(e, Z4);
          t.value !== "receivedSignature" &&
            this._subscriptionsAutoDisposedByRpc.add(r),
            this._handleServerNotification(
              r,
              t.value === "receivedSignature"
                ? [{ type: "received" }, t.context]
                : [{ type: "status", result: t.value }, t.context]
            );
        }
        onSignature(e, t, r) {
          let i = this._buildArgs([e], r || this._commitment || "finalized"),
            s = this._makeSubscription(
              {
                callback: (o, a) => {
                  if (o.type === "status") {
                    t(o.result, a);
                    try {
                      this.removeSignatureListener(s);
                    } catch {}
                  }
                },
                method: "signatureSubscribe",
                unsubscribeMethod: "signatureUnsubscribe",
              },
              i
            );
          return s;
        }
        onSignatureWithOptions(e, t, r) {
          let c = $(v({}, r), {
              commitment:
                (r && r.commitment) || this._commitment || "finalized",
            }),
            { commitment: i } = c,
            s = ln(c, ["commitment"]),
            o = this._buildArgs([e], i, void 0, s),
            a = this._makeSubscription(
              {
                callback: (u, l) => {
                  t(u, l);
                  try {
                    this.removeSignatureListener(a);
                  } catch {}
                },
                method: "signatureSubscribe",
                unsubscribeMethod: "signatureUnsubscribe",
              },
              o
            );
          return a;
        }
        removeSignatureListener(e) {
          return d(this, null, function* () {
            yield this._unsubscribeClientSubscription(e, "signature result");
          });
        }
        _wsOnRootNotification(e) {
          let { result: t, subscription: r } = Q(e, X4);
          this._handleServerNotification(r, [t]);
        }
        onRootChange(e) {
          return this._makeSubscription(
            {
              callback: e,
              method: "rootSubscribe",
              unsubscribeMethod: "rootUnsubscribe",
            },
            []
          );
        }
        removeRootChangeListener(e) {
          return d(this, null, function* () {
            yield this._unsubscribeClientSubscription(e, "root change");
          });
        }
      }),
      (Hp = class n {
        constructor(e) {
          (this._keypair = void 0), (this._keypair = e ?? t2());
        }
        static generate() {
          return new n(t2());
        }
        static fromSecretKey(e, t) {
          if (e.byteLength !== 64) throw new Error("bad secret key size");
          let r = e.slice(32, 64);
          if (!t || !t.skipValidation) {
            let i = e.slice(0, 32),
              s = Fp(i);
            for (let o = 0; o < 32; o++)
              if (r[o] !== s[o])
                throw new Error("provided secretKey is invalid");
          }
          return new n({ publicKey: r, secretKey: e });
        }
        static fromSeed(e) {
          let t = Fp(e),
            r = new Uint8Array(64);
          return r.set(e), r.set(t, 32), new n({ publicKey: t, secretKey: r });
        }
        get publicKey() {
          return new J(this._keypair.publicKey);
        }
        get secretKey() {
          return new Uint8Array(this._keypair.secretKey);
        }
      }),
      (Vi = Object.freeze({
        CreateLookupTable: {
          index: 0,
          layout: A.struct([
            A.u32("instruction"),
            Qc("recentSlot"),
            A.u8("bumpSeed"),
          ]),
        },
        FreezeLookupTable: {
          index: 1,
          layout: A.struct([A.u32("instruction")]),
        },
        ExtendLookupTable: {
          index: 2,
          layout: A.struct([
            A.u32("instruction"),
            Qc(),
            A.seq(Le(), A.offset(A.u32(), -8), "addresses"),
          ]),
        },
        DeactivateLookupTable: {
          index: 3,
          layout: A.struct([A.u32("instruction")]),
        },
        CloseLookupTable: {
          index: 4,
          layout: A.struct([A.u32("instruction")]),
        },
      })),
      (Ab = class {
        constructor() {}
        static decodeInstructionType(e) {
          this.checkProgramId(e.programId);
          let r = A.u32("instruction").decode(e.data),
            i;
          for (let [s, o] of Object.entries(Vi))
            if (o.index == r) {
              i = s;
              break;
            }
          if (!i)
            throw new Error(
              "Invalid Instruction. Should be a LookupTable Instruction"
            );
          return i;
        }
        static decodeCreateLookupTable(e) {
          this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 4);
          let { recentSlot: t } = Ze(Vi.CreateLookupTable, e.data);
          return {
            authority: e.keys[1].pubkey,
            payer: e.keys[2].pubkey,
            recentSlot: Number(t),
          };
        }
        static decodeExtendLookupTable(e) {
          if ((this.checkProgramId(e.programId), e.keys.length < 2))
            throw new Error(
              `invalid instruction; found ${e.keys.length} keys, expected at least 2`
            );
          let { addresses: t } = Ze(Vi.ExtendLookupTable, e.data);
          return {
            lookupTable: e.keys[0].pubkey,
            authority: e.keys[1].pubkey,
            payer: e.keys.length > 2 ? e.keys[2].pubkey : void 0,
            addresses: t.map((r) => new J(r)),
          };
        }
        static decodeCloseLookupTable(e) {
          return (
            this.checkProgramId(e.programId),
            this.checkKeysLength(e.keys, 3),
            {
              lookupTable: e.keys[0].pubkey,
              authority: e.keys[1].pubkey,
              recipient: e.keys[2].pubkey,
            }
          );
        }
        static decodeFreezeLookupTable(e) {
          return (
            this.checkProgramId(e.programId),
            this.checkKeysLength(e.keys, 2),
            { lookupTable: e.keys[0].pubkey, authority: e.keys[1].pubkey }
          );
        }
        static decodeDeactivateLookupTable(e) {
          return (
            this.checkProgramId(e.programId),
            this.checkKeysLength(e.keys, 2),
            { lookupTable: e.keys[0].pubkey, authority: e.keys[1].pubkey }
          );
        }
        static checkProgramId(e) {
          if (!e.equals(nh.programId))
            throw new Error(
              "invalid instruction; programId is not AddressLookupTable Program"
            );
        }
        static checkKeysLength(e, t) {
          if (e.length < t)
            throw new Error(
              `invalid instruction; found ${e.length} keys, expected at least ${t}`
            );
        }
      }),
      (nh = class {
        constructor() {}
        static createLookupTable(e) {
          let [t, r] = J.findProgramAddressSync(
              [
                e.authority.toBuffer(),
                (0, ih.toBufferLE)(BigInt(e.recentSlot), 8),
              ],
              this.programId
            ),
            i = Vi.CreateLookupTable,
            s = Ue(i, { recentSlot: BigInt(e.recentSlot), bumpSeed: r }),
            o = [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: e.authority, isSigner: !0, isWritable: !1 },
              { pubkey: e.payer, isSigner: !0, isWritable: !0 },
              { pubkey: an.programId, isSigner: !1, isWritable: !1 },
            ];
          return [new tt({ programId: this.programId, keys: o, data: s }), t];
        }
        static freezeLookupTable(e) {
          let t = Vi.FreezeLookupTable,
            r = Ue(t),
            i = [
              { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
              { pubkey: e.authority, isSigner: !0, isWritable: !1 },
            ];
          return new tt({ programId: this.programId, keys: i, data: r });
        }
        static extendLookupTable(e) {
          let t = Vi.ExtendLookupTable,
            r = Ue(t, { addresses: e.addresses.map((s) => s.toBytes()) }),
            i = [
              { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
              { pubkey: e.authority, isSigner: !0, isWritable: !1 },
            ];
          return (
            e.payer &&
              i.push(
                { pubkey: e.payer, isSigner: !0, isWritable: !0 },
                { pubkey: an.programId, isSigner: !1, isWritable: !1 }
              ),
            new tt({ programId: this.programId, keys: i, data: r })
          );
        }
        static deactivateLookupTable(e) {
          let t = Vi.DeactivateLookupTable,
            r = Ue(t),
            i = [
              { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
              { pubkey: e.authority, isSigner: !0, isWritable: !1 },
            ];
          return new tt({ programId: this.programId, keys: i, data: r });
        }
        static closeLookupTable(e) {
          let t = Vi.CloseLookupTable,
            r = Ue(t),
            i = [
              { pubkey: e.lookupTable, isSigner: !1, isWritable: !0 },
              { pubkey: e.authority, isSigner: !0, isWritable: !1 },
              { pubkey: e.recipient, isSigner: !1, isWritable: !0 },
            ];
          return new tt({ programId: this.programId, keys: i, data: r });
        }
      });
    nh.programId = new J("AddressLookupTab1e1111111111111111111111111");
    (Eb = class {
      constructor() {}
      static decodeInstructionType(e) {
        this.checkProgramId(e.programId);
        let r = A.u8("instruction").decode(e.data),
          i;
        for (let [s, o] of Object.entries(oi))
          if (o.index == r) {
            i = s;
            break;
          }
        if (!i)
          throw new Error(
            "Instruction type incorrect; not a ComputeBudgetInstruction"
          );
        return i;
      }
      static decodeRequestUnits(e) {
        this.checkProgramId(e.programId);
        let { units: t, additionalFee: r } = Ze(oi.RequestUnits, e.data);
        return { units: t, additionalFee: r };
      }
      static decodeRequestHeapFrame(e) {
        this.checkProgramId(e.programId);
        let { bytes: t } = Ze(oi.RequestHeapFrame, e.data);
        return { bytes: t };
      }
      static decodeSetComputeUnitLimit(e) {
        this.checkProgramId(e.programId);
        let { units: t } = Ze(oi.SetComputeUnitLimit, e.data);
        return { units: t };
      }
      static decodeSetComputeUnitPrice(e) {
        this.checkProgramId(e.programId);
        let { microLamports: t } = Ze(oi.SetComputeUnitPrice, e.data);
        return { microLamports: t };
      }
      static checkProgramId(e) {
        if (!e.equals(rh.programId))
          throw new Error(
            "invalid instruction; programId is not ComputeBudgetProgram"
          );
      }
    }),
      (oi = Object.freeze({
        RequestUnits: {
          index: 0,
          layout: A.struct([
            A.u8("instruction"),
            A.u32("units"),
            A.u32("additionalFee"),
          ]),
        },
        RequestHeapFrame: {
          index: 1,
          layout: A.struct([A.u8("instruction"), A.u32("bytes")]),
        },
        SetComputeUnitLimit: {
          index: 2,
          layout: A.struct([A.u8("instruction"), A.u32("units")]),
        },
        SetComputeUnitPrice: {
          index: 3,
          layout: A.struct([A.u8("instruction"), Qc("microLamports")]),
        },
      })),
      (rh = class {
        constructor() {}
        static requestUnits(e) {
          let t = oi.RequestUnits,
            r = Ue(t, e);
          return new tt({ keys: [], programId: this.programId, data: r });
        }
        static requestHeapFrame(e) {
          let t = oi.RequestHeapFrame,
            r = Ue(t, e);
          return new tt({ keys: [], programId: this.programId, data: r });
        }
        static setComputeUnitLimit(e) {
          let t = oi.SetComputeUnitLimit,
            r = Ue(t, e);
          return new tt({ keys: [], programId: this.programId, data: r });
        }
        static setComputeUnitPrice(e) {
          let t = oi.SetComputeUnitPrice,
            r = Ue(t, { microLamports: BigInt(e.microLamports) });
          return new tt({ keys: [], programId: this.programId, data: r });
        }
      });
    rh.programId = new J("ComputeBudget111111111111111111111111111111");
    (h2 = 64),
      (f2 = 32),
      (d2 = 64),
      (p2 = A.struct([
        A.u8("numSignatures"),
        A.u8("padding"),
        A.u16("signatureOffset"),
        A.u16("signatureInstructionIndex"),
        A.u16("publicKeyOffset"),
        A.u16("publicKeyInstructionIndex"),
        A.u16("messageDataOffset"),
        A.u16("messageDataSize"),
        A.u16("messageInstructionIndex"),
      ])),
      (Vp = class n {
        constructor() {}
        static createInstructionWithPublicKey(e) {
          let {
            publicKey: t,
            message: r,
            signature: i,
            instructionIndex: s,
          } = e;
          Ve(
            t.length === f2,
            `Public Key must be ${f2} bytes but received ${t.length} bytes`
          ),
            Ve(
              i.length === d2,
              `Signature must be ${d2} bytes but received ${i.length} bytes`
            );
          let o = p2.span,
            a = o + t.length,
            c = a + i.length,
            u = 1,
            l = we.Buffer.alloc(c + r.length),
            h = s ?? 65535;
          return (
            p2.encode(
              {
                numSignatures: u,
                padding: 0,
                signatureOffset: a,
                signatureInstructionIndex: h,
                publicKeyOffset: o,
                publicKeyInstructionIndex: h,
                messageDataOffset: c,
                messageDataSize: r.length,
                messageInstructionIndex: h,
              },
              l
            ),
            l.fill(t, o),
            l.fill(i, a),
            l.fill(r, c),
            new tt({ keys: [], programId: n.programId, data: l })
          );
        }
        static createInstructionWithPrivateKey(e) {
          let { privateKey: t, message: r, instructionIndex: i } = e;
          Ve(
            t.length === h2,
            `Private key must be ${h2} bytes but received ${t.length} bytes`
          );
          try {
            let s = Hp.fromSecretKey(t),
              o = s.publicKey.toBytes(),
              a = Cb(r, s.secretKey);
            return this.createInstructionWithPublicKey({
              publicKey: o,
              message: r,
              signature: a,
              instructionIndex: i,
            });
          } catch (s) {
            throw new Error(`Error creating instruction; ${s}`);
          }
        }
      });
    Vp.programId = new J("Ed25519SigVerify111111111111111111111111111");
    C6 = (n, e) => {
      let t = ql.sign(n, e);
      return [t.toCompactRawBytes(), t.recovery];
    };
    ql.utils.isValidPrivateKey;
    (k6 = ql.getPublicKey),
      (g2 = 32),
      (ob = 20),
      (m2 = 64),
      (T6 = 11),
      (ab = A.struct([
        A.u8("numSignatures"),
        A.u16("signatureOffset"),
        A.u8("signatureInstructionIndex"),
        A.u16("ethAddressOffset"),
        A.u8("ethAddressInstructionIndex"),
        A.u16("messageDataOffset"),
        A.u16("messageDataSize"),
        A.u8("messageInstructionIndex"),
        A.blob(20, "ethAddress"),
        A.blob(64, "signature"),
        A.u8("recoveryId"),
      ])),
      ($p = class n {
        constructor() {}
        static publicKeyToEthAddress(e) {
          Ve(
            e.length === m2,
            `Public key must be ${m2} bytes but received ${e.length} bytes`
          );
          try {
            return we.Buffer.from(Yw(Be(e))).slice(-ob);
          } catch (t) {
            throw new Error(`Error constructing Ethereum address: ${t}`);
          }
        }
        static createInstructionWithPublicKey(e) {
          let {
            publicKey: t,
            message: r,
            signature: i,
            recoveryId: s,
            instructionIndex: o,
          } = e;
          return n.createInstructionWithEthAddress({
            ethAddress: n.publicKeyToEthAddress(t),
            message: r,
            signature: i,
            recoveryId: s,
            instructionIndex: o,
          });
        }
        static createInstructionWithEthAddress(e) {
          let {
              ethAddress: t,
              message: r,
              signature: i,
              recoveryId: s,
              instructionIndex: o = 0,
            } = e,
            a;
          typeof t == "string"
            ? t.startsWith("0x")
              ? (a = we.Buffer.from(t.substr(2), "hex"))
              : (a = we.Buffer.from(t, "hex"))
            : (a = t),
            Ve(
              a.length === ob,
              `Address must be ${ob} bytes but received ${a.length} bytes`
            );
          let c = 1 + T6,
            u = c,
            l = c + a.length,
            h = l + i.length + 1,
            f = 1,
            g = we.Buffer.alloc(ab.span + r.length);
          return (
            ab.encode(
              {
                numSignatures: f,
                signatureOffset: l,
                signatureInstructionIndex: o,
                ethAddressOffset: u,
                ethAddressInstructionIndex: o,
                messageDataOffset: h,
                messageDataSize: r.length,
                messageInstructionIndex: o,
                signature: Be(i),
                ethAddress: Be(a),
                recoveryId: s,
              },
              g
            ),
            g.fill(Be(r), ab.span),
            new tt({ keys: [], programId: n.programId, data: g })
          );
        }
        static createInstructionWithPrivateKey(e) {
          let { privateKey: t, message: r, instructionIndex: i } = e;
          Ve(
            t.length === g2,
            `Private key must be ${g2} bytes but received ${t.length} bytes`
          );
          try {
            let s = Be(t),
              o = k6(s, !1).slice(1),
              a = we.Buffer.from(Yw(Be(r))),
              [c, u] = C6(a, s);
            return this.createInstructionWithPublicKey({
              publicKey: o,
              message: r,
              signature: c,
              recoveryId: u,
              instructionIndex: i,
            });
          } catch (s) {
            throw new Error(`Error creating instruction; ${s}`);
          }
        }
      });
    $p.programId = new J("KeccakSecp256k11111111111111111111111111111");
    (z2 = new J("StakeConfig11111111111111111111111111111111")),
      (Gp = class {
        constructor(e, t) {
          (this.staker = void 0),
            (this.withdrawer = void 0),
            (this.staker = e),
            (this.withdrawer = t);
        }
      }),
      (Zo = class {
        constructor(e, t, r) {
          (this.unixTimestamp = void 0),
            (this.epoch = void 0),
            (this.custodian = void 0),
            (this.unixTimestamp = e),
            (this.epoch = t),
            (this.custodian = r);
        }
      });
    U2 = Zo;
    Zo.default = new U2(0, 0, J.default);
    (xb = class {
      constructor() {}
      static decodeInstructionType(e) {
        this.checkProgramId(e.programId);
        let r = A.u32("instruction").decode(e.data),
          i;
        for (let [s, o] of Object.entries(Zt))
          if (o.index == r) {
            i = s;
            break;
          }
        if (!i)
          throw new Error("Instruction type incorrect; not a StakeInstruction");
        return i;
      }
      static decodeInitialize(e) {
        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
        let { authorized: t, lockup: r } = Ze(Zt.Initialize, e.data);
        return {
          stakePubkey: e.keys[0].pubkey,
          authorized: new Gp(new J(t.staker), new J(t.withdrawer)),
          lockup: new Zo(r.unixTimestamp, r.epoch, new J(r.custodian)),
        };
      }
      static decodeDelegate(e) {
        return (
          this.checkProgramId(e.programId),
          this.checkKeyLength(e.keys, 6),
          Ze(Zt.Delegate, e.data),
          {
            stakePubkey: e.keys[0].pubkey,
            votePubkey: e.keys[1].pubkey,
            authorizedPubkey: e.keys[5].pubkey,
          }
        );
      }
      static decodeAuthorize(e) {
        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
        let { newAuthorized: t, stakeAuthorizationType: r } = Ze(
            Zt.Authorize,
            e.data
          ),
          i = {
            stakePubkey: e.keys[0].pubkey,
            authorizedPubkey: e.keys[2].pubkey,
            newAuthorizedPubkey: new J(t),
            stakeAuthorizationType: { index: r },
          };
        return e.keys.length > 3 && (i.custodianPubkey = e.keys[3].pubkey), i;
      }
      static decodeAuthorizeWithSeed(e) {
        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
        let {
            newAuthorized: t,
            stakeAuthorizationType: r,
            authoritySeed: i,
            authorityOwner: s,
          } = Ze(Zt.AuthorizeWithSeed, e.data),
          o = {
            stakePubkey: e.keys[0].pubkey,
            authorityBase: e.keys[1].pubkey,
            authoritySeed: i,
            authorityOwner: new J(s),
            newAuthorizedPubkey: new J(t),
            stakeAuthorizationType: { index: r },
          };
        return e.keys.length > 3 && (o.custodianPubkey = e.keys[3].pubkey), o;
      }
      static decodeSplit(e) {
        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
        let { lamports: t } = Ze(Zt.Split, e.data);
        return {
          stakePubkey: e.keys[0].pubkey,
          splitStakePubkey: e.keys[1].pubkey,
          authorizedPubkey: e.keys[2].pubkey,
          lamports: t,
        };
      }
      static decodeMerge(e) {
        return (
          this.checkProgramId(e.programId),
          this.checkKeyLength(e.keys, 3),
          Ze(Zt.Merge, e.data),
          {
            stakePubkey: e.keys[0].pubkey,
            sourceStakePubKey: e.keys[1].pubkey,
            authorizedPubkey: e.keys[4].pubkey,
          }
        );
      }
      static decodeWithdraw(e) {
        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
        let { lamports: t } = Ze(Zt.Withdraw, e.data),
          r = {
            stakePubkey: e.keys[0].pubkey,
            toPubkey: e.keys[1].pubkey,
            authorizedPubkey: e.keys[4].pubkey,
            lamports: t,
          };
        return e.keys.length > 5 && (r.custodianPubkey = e.keys[5].pubkey), r;
      }
      static decodeDeactivate(e) {
        return (
          this.checkProgramId(e.programId),
          this.checkKeyLength(e.keys, 3),
          Ze(Zt.Deactivate, e.data),
          { stakePubkey: e.keys[0].pubkey, authorizedPubkey: e.keys[2].pubkey }
        );
      }
      static checkProgramId(e) {
        if (!e.equals(Yc.programId))
          throw new Error("invalid instruction; programId is not StakeProgram");
      }
      static checkKeyLength(e, t) {
        if (e.length < t)
          throw new Error(
            `invalid instruction; found ${e.length} keys, expected at least ${t}`
          );
      }
    }),
      (Zt = Object.freeze({
        Initialize: {
          index: 0,
          layout: A.struct([A.u32("instruction"), NU(), FU()]),
        },
        Authorize: {
          index: 1,
          layout: A.struct([
            A.u32("instruction"),
            Le("newAuthorized"),
            A.u32("stakeAuthorizationType"),
          ]),
        },
        Delegate: { index: 2, layout: A.struct([A.u32("instruction")]) },
        Split: {
          index: 3,
          layout: A.struct([A.u32("instruction"), A.ns64("lamports")]),
        },
        Withdraw: {
          index: 4,
          layout: A.struct([A.u32("instruction"), A.ns64("lamports")]),
        },
        Deactivate: { index: 5, layout: A.struct([A.u32("instruction")]) },
        Merge: { index: 7, layout: A.struct([A.u32("instruction")]) },
        AuthorizeWithSeed: {
          index: 8,
          layout: A.struct([
            A.u32("instruction"),
            Le("newAuthorized"),
            A.u32("stakeAuthorizationType"),
            qo("authoritySeed"),
            Le("authorityOwner"),
          ]),
        },
      })),
      (R6 = Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } })),
      (Yc = class {
        constructor() {}
        static initialize(e) {
          let { stakePubkey: t, authorized: r, lockup: i } = e,
            s = i || Zo.default,
            o = Zt.Initialize,
            a = Ue(o, {
              authorized: {
                staker: Be(r.staker.toBuffer()),
                withdrawer: Be(r.withdrawer.toBuffer()),
              },
              lockup: {
                unixTimestamp: s.unixTimestamp,
                epoch: s.epoch,
                custodian: Be(s.custodian.toBuffer()),
              },
            }),
            c = {
              keys: [
                { pubkey: t, isSigner: !1, isWritable: !0 },
                { pubkey: qc, isSigner: !1, isWritable: !1 },
              ],
              programId: this.programId,
              data: a,
            };
          return new tt(c);
        }
        static createAccountWithSeed(e) {
          let t = new Ne();
          t.add(
            an.createAccountWithSeed({
              fromPubkey: e.fromPubkey,
              newAccountPubkey: e.stakePubkey,
              basePubkey: e.basePubkey,
              seed: e.seed,
              lamports: e.lamports,
              space: this.space,
              programId: this.programId,
            })
          );
          let { stakePubkey: r, authorized: i, lockup: s } = e;
          return t.add(
            this.initialize({ stakePubkey: r, authorized: i, lockup: s })
          );
        }
        static createAccount(e) {
          let t = new Ne();
          t.add(
            an.createAccount({
              fromPubkey: e.fromPubkey,
              newAccountPubkey: e.stakePubkey,
              lamports: e.lamports,
              space: this.space,
              programId: this.programId,
            })
          );
          let { stakePubkey: r, authorized: i, lockup: s } = e;
          return t.add(
            this.initialize({ stakePubkey: r, authorized: i, lockup: s })
          );
        }
        static delegate(e) {
          let { stakePubkey: t, authorizedPubkey: r, votePubkey: i } = e,
            s = Zt.Delegate,
            o = Ue(s);
          return new Ne().add({
            keys: [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: i, isSigner: !1, isWritable: !1 },
              { pubkey: ii, isSigner: !1, isWritable: !1 },
              { pubkey: Np, isSigner: !1, isWritable: !1 },
              { pubkey: z2, isSigner: !1, isWritable: !1 },
              { pubkey: r, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: o,
          });
        }
        static authorize(e) {
          let {
              stakePubkey: t,
              authorizedPubkey: r,
              newAuthorizedPubkey: i,
              stakeAuthorizationType: s,
              custodianPubkey: o,
            } = e,
            a = Zt.Authorize,
            c = Ue(a, {
              newAuthorized: Be(i.toBuffer()),
              stakeAuthorizationType: s.index,
            }),
            u = [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: ii, isSigner: !1, isWritable: !0 },
              { pubkey: r, isSigner: !0, isWritable: !1 },
            ];
          return (
            o && u.push({ pubkey: o, isSigner: !0, isWritable: !1 }),
            new Ne().add({ keys: u, programId: this.programId, data: c })
          );
        }
        static authorizeWithSeed(e) {
          let {
              stakePubkey: t,
              authorityBase: r,
              authoritySeed: i,
              authorityOwner: s,
              newAuthorizedPubkey: o,
              stakeAuthorizationType: a,
              custodianPubkey: c,
            } = e,
            u = Zt.AuthorizeWithSeed,
            l = Ue(u, {
              newAuthorized: Be(o.toBuffer()),
              stakeAuthorizationType: a.index,
              authoritySeed: i,
              authorityOwner: Be(s.toBuffer()),
            }),
            h = [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: r, isSigner: !0, isWritable: !1 },
              { pubkey: ii, isSigner: !1, isWritable: !1 },
            ];
          return (
            c && h.push({ pubkey: c, isSigner: !0, isWritable: !1 }),
            new Ne().add({ keys: h, programId: this.programId, data: l })
          );
        }
        static splitInstruction(e) {
          let {
              stakePubkey: t,
              authorizedPubkey: r,
              splitStakePubkey: i,
              lamports: s,
            } = e,
            o = Zt.Split,
            a = Ue(o, { lamports: s });
          return new tt({
            keys: [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: i, isSigner: !1, isWritable: !0 },
              { pubkey: r, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: a,
          });
        }
        static split(e, t) {
          let r = new Ne();
          return (
            r.add(
              an.createAccount({
                fromPubkey: e.authorizedPubkey,
                newAccountPubkey: e.splitStakePubkey,
                lamports: t,
                space: this.space,
                programId: this.programId,
              })
            ),
            r.add(this.splitInstruction(e))
          );
        }
        static splitWithSeed(e, t) {
          let {
              stakePubkey: r,
              authorizedPubkey: i,
              splitStakePubkey: s,
              basePubkey: o,
              seed: a,
              lamports: c,
            } = e,
            u = new Ne();
          return (
            u.add(
              an.allocate({
                accountPubkey: s,
                basePubkey: o,
                seed: a,
                space: this.space,
                programId: this.programId,
              })
            ),
            t &&
              t > 0 &&
              u.add(
                an.transfer({
                  fromPubkey: e.authorizedPubkey,
                  toPubkey: s,
                  lamports: t,
                })
              ),
            u.add(
              this.splitInstruction({
                stakePubkey: r,
                authorizedPubkey: i,
                splitStakePubkey: s,
                lamports: c,
              })
            )
          );
        }
        static merge(e) {
          let { stakePubkey: t, sourceStakePubKey: r, authorizedPubkey: i } = e,
            s = Zt.Merge,
            o = Ue(s);
          return new Ne().add({
            keys: [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: r, isSigner: !1, isWritable: !0 },
              { pubkey: ii, isSigner: !1, isWritable: !1 },
              { pubkey: Np, isSigner: !1, isWritable: !1 },
              { pubkey: i, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: o,
          });
        }
        static withdraw(e) {
          let {
              stakePubkey: t,
              authorizedPubkey: r,
              toPubkey: i,
              lamports: s,
              custodianPubkey: o,
            } = e,
            a = Zt.Withdraw,
            c = Ue(a, { lamports: s }),
            u = [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: i, isSigner: !1, isWritable: !0 },
              { pubkey: ii, isSigner: !1, isWritable: !1 },
              { pubkey: Np, isSigner: !1, isWritable: !1 },
              { pubkey: r, isSigner: !0, isWritable: !1 },
            ];
          return (
            o && u.push({ pubkey: o, isSigner: !0, isWritable: !1 }),
            new Ne().add({ keys: u, programId: this.programId, data: c })
          );
        }
        static deactivate(e) {
          let { stakePubkey: t, authorizedPubkey: r } = e,
            i = Zt.Deactivate,
            s = Ue(i);
          return new Ne().add({
            keys: [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: ii, isSigner: !1, isWritable: !1 },
              { pubkey: r, isSigner: !0, isWritable: !1 },
            ],
            programId: this.programId,
            data: s,
          });
        }
      });
    Yc.programId = new J("Stake11111111111111111111111111111111111111");
    Yc.space = 200;
    (Kp = class {
      constructor(e, t, r, i) {
        (this.nodePubkey = void 0),
          (this.authorizedVoter = void 0),
          (this.authorizedWithdrawer = void 0),
          (this.commission = void 0),
          (this.nodePubkey = e),
          (this.authorizedVoter = t),
          (this.authorizedWithdrawer = r),
          (this.commission = i);
      }
    }),
      (Sb = class {
        constructor() {}
        static decodeInstructionType(e) {
          this.checkProgramId(e.programId);
          let r = A.u32("instruction").decode(e.data),
            i;
          for (let [s, o] of Object.entries(ai))
            if (o.index == r) {
              i = s;
              break;
            }
          if (!i)
            throw new Error(
              "Instruction type incorrect; not a VoteInstruction"
            );
          return i;
        }
        static decodeInitializeAccount(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 4);
          let { voteInit: t } = Ze(ai.InitializeAccount, e.data);
          return {
            votePubkey: e.keys[0].pubkey,
            nodePubkey: e.keys[3].pubkey,
            voteInit: new Kp(
              new J(t.nodePubkey),
              new J(t.authorizedVoter),
              new J(t.authorizedWithdrawer),
              t.commission
            ),
          };
        }
        static decodeAuthorize(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
          let { newAuthorized: t, voteAuthorizationType: r } = Ze(
            ai.Authorize,
            e.data
          );
          return {
            votePubkey: e.keys[0].pubkey,
            authorizedPubkey: e.keys[2].pubkey,
            newAuthorizedPubkey: new J(t),
            voteAuthorizationType: { index: r },
          };
        }
        static decodeAuthorizeWithSeed(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
          let {
            voteAuthorizeWithSeedArgs: {
              currentAuthorityDerivedKeyOwnerPubkey: t,
              currentAuthorityDerivedKeySeed: r,
              newAuthorized: i,
              voteAuthorizationType: s,
            },
          } = Ze(ai.AuthorizeWithSeed, e.data);
          return {
            currentAuthorityDerivedKeyBasePubkey: e.keys[2].pubkey,
            currentAuthorityDerivedKeyOwnerPubkey: new J(t),
            currentAuthorityDerivedKeySeed: r,
            newAuthorizedPubkey: new J(i),
            voteAuthorizationType: { index: s },
            votePubkey: e.keys[0].pubkey,
          };
        }
        static decodeWithdraw(e) {
          this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
          let { lamports: t } = Ze(ai.Withdraw, e.data);
          return {
            votePubkey: e.keys[0].pubkey,
            authorizedWithdrawerPubkey: e.keys[2].pubkey,
            lamports: t,
            toPubkey: e.keys[1].pubkey,
          };
        }
        static checkProgramId(e) {
          if (!e.equals(Zc.programId))
            throw new Error(
              "invalid instruction; programId is not VoteProgram"
            );
        }
        static checkKeyLength(e, t) {
          if (e.length < t)
            throw new Error(
              `invalid instruction; found ${e.length} keys, expected at least ${t}`
            );
        }
      }),
      (ai = Object.freeze({
        InitializeAccount: {
          index: 0,
          layout: A.struct([A.u32("instruction"), MU()]),
        },
        Authorize: {
          index: 1,
          layout: A.struct([
            A.u32("instruction"),
            Le("newAuthorized"),
            A.u32("voteAuthorizationType"),
          ]),
        },
        Withdraw: {
          index: 3,
          layout: A.struct([A.u32("instruction"), A.ns64("lamports")]),
        },
        UpdateValidatorIdentity: {
          index: 4,
          layout: A.struct([A.u32("instruction")]),
        },
        AuthorizeWithSeed: {
          index: 10,
          layout: A.struct([A.u32("instruction"), UU()]),
        },
      })),
      (B6 = Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } })),
      (Zc = class n {
        constructor() {}
        static initializeAccount(e) {
          let { votePubkey: t, nodePubkey: r, voteInit: i } = e,
            s = ai.InitializeAccount,
            o = Ue(s, {
              voteInit: {
                nodePubkey: Be(i.nodePubkey.toBuffer()),
                authorizedVoter: Be(i.authorizedVoter.toBuffer()),
                authorizedWithdrawer: Be(i.authorizedWithdrawer.toBuffer()),
                commission: i.commission,
              },
            }),
            a = {
              keys: [
                { pubkey: t, isSigner: !1, isWritable: !0 },
                { pubkey: qc, isSigner: !1, isWritable: !1 },
                { pubkey: ii, isSigner: !1, isWritable: !1 },
                { pubkey: r, isSigner: !0, isWritable: !1 },
              ],
              programId: this.programId,
              data: o,
            };
          return new tt(a);
        }
        static createAccount(e) {
          let t = new Ne();
          return (
            t.add(
              an.createAccount({
                fromPubkey: e.fromPubkey,
                newAccountPubkey: e.votePubkey,
                lamports: e.lamports,
                space: this.space,
                programId: this.programId,
              })
            ),
            t.add(
              this.initializeAccount({
                votePubkey: e.votePubkey,
                nodePubkey: e.voteInit.nodePubkey,
                voteInit: e.voteInit,
              })
            )
          );
        }
        static authorize(e) {
          let {
              votePubkey: t,
              authorizedPubkey: r,
              newAuthorizedPubkey: i,
              voteAuthorizationType: s,
            } = e,
            o = ai.Authorize,
            a = Ue(o, {
              newAuthorized: Be(i.toBuffer()),
              voteAuthorizationType: s.index,
            }),
            c = [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: ii, isSigner: !1, isWritable: !1 },
              { pubkey: r, isSigner: !0, isWritable: !1 },
            ];
          return new Ne().add({ keys: c, programId: this.programId, data: a });
        }
        static authorizeWithSeed(e) {
          let {
              currentAuthorityDerivedKeyBasePubkey: t,
              currentAuthorityDerivedKeyOwnerPubkey: r,
              currentAuthorityDerivedKeySeed: i,
              newAuthorizedPubkey: s,
              voteAuthorizationType: o,
              votePubkey: a,
            } = e,
            c = ai.AuthorizeWithSeed,
            u = Ue(c, {
              voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: Be(r.toBuffer()),
                currentAuthorityDerivedKeySeed: i,
                newAuthorized: Be(s.toBuffer()),
                voteAuthorizationType: o.index,
              },
            }),
            l = [
              { pubkey: a, isSigner: !1, isWritable: !0 },
              { pubkey: ii, isSigner: !1, isWritable: !1 },
              { pubkey: t, isSigner: !0, isWritable: !1 },
            ];
          return new Ne().add({ keys: l, programId: this.programId, data: u });
        }
        static withdraw(e) {
          let {
              votePubkey: t,
              authorizedWithdrawerPubkey: r,
              lamports: i,
              toPubkey: s,
            } = e,
            o = ai.Withdraw,
            a = Ue(o, { lamports: i }),
            c = [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: s, isSigner: !1, isWritable: !0 },
              { pubkey: r, isSigner: !0, isWritable: !1 },
            ];
          return new Ne().add({ keys: c, programId: this.programId, data: a });
        }
        static safeWithdraw(e, t, r) {
          if (e.lamports > t - r)
            throw new Error(
              "Withdraw will leave vote account with insufficient funds."
            );
          return n.withdraw(e);
        }
        static updateValidatorIdentity(e) {
          let {
              votePubkey: t,
              authorizedWithdrawerPubkey: r,
              nodePubkey: i,
            } = e,
            s = ai.UpdateValidatorIdentity,
            o = Ue(s),
            a = [
              { pubkey: t, isSigner: !1, isWritable: !0 },
              { pubkey: i, isSigner: !0, isWritable: !1 },
              { pubkey: r, isSigner: !0, isWritable: !1 },
            ];
          return new Ne().add({ keys: a, programId: this.programId, data: o });
        }
      });
    Zc.programId = new J("Vote111111111111111111111111111111111111111");
    Zc.space = 3762;
    (j2 = new J("Va1idator1nfo111111111111111111111111111111")),
      (D6 = z({
        name: G(),
        website: de(G()),
        details: de(G()),
        iconUrl: de(G()),
        keybaseUsername: de(G()),
      })),
      (vb = class n {
        constructor(e, t) {
          (this.key = void 0),
            (this.info = void 0),
            (this.key = e),
            (this.info = t);
        }
        static fromConfigData(e) {
          let t = [...e];
          if (Hn(t) !== 2) return null;
          let i = [];
          for (let s = 0; s < 2; s++) {
            let o = new J(Vn(t, 0, ci)),
              a = si(t) === 1;
            i.push({ publicKey: o, isSigner: a });
          }
          if (i[0].publicKey.equals(j2) && i[1].isSigner) {
            let s = qo().decode(we.Buffer.from(t)),
              o = JSON.parse(s);
            return zw(o, D6), new n(i[1].publicKey, o);
          }
          return null;
        }
      }),
      (_6 = new J("Vote111111111111111111111111111111111111111")),
      (P6 = A.struct([
        Le("nodePubkey"),
        Le("authorizedWithdrawer"),
        A.u8("commission"),
        A.nu64(),
        A.seq(
          A.struct([A.nu64("slot"), A.u32("confirmationCount")]),
          A.offset(A.u32(), -8),
          "votes"
        ),
        A.u8("rootSlotValid"),
        A.nu64("rootSlot"),
        A.nu64(),
        A.seq(
          A.struct([A.nu64("epoch"), Le("authorizedVoter")]),
          A.offset(A.u32(), -8),
          "authorizedVoters"
        ),
        A.struct(
          [
            A.seq(
              A.struct([
                Le("authorizedPubkey"),
                A.nu64("epochOfLastAuthorizedSwitch"),
                A.nu64("targetEpoch"),
              ]),
              32,
              "buf"
            ),
            A.nu64("idx"),
            A.u8("isEmpty"),
          ],
          "priorVoters"
        ),
        A.nu64(),
        A.seq(
          A.struct([A.nu64("epoch"), A.nu64("credits"), A.nu64("prevCredits")]),
          A.offset(A.u32(), -8),
          "epochCredits"
        ),
        A.struct([A.nu64("slot"), A.nu64("timestamp")], "lastTimestamp"),
      ])),
      (Ib = class n {
        constructor(e) {
          (this.nodePubkey = void 0),
            (this.authorizedWithdrawer = void 0),
            (this.commission = void 0),
            (this.rootSlot = void 0),
            (this.votes = void 0),
            (this.authorizedVoters = void 0),
            (this.priorVoters = void 0),
            (this.epochCredits = void 0),
            (this.lastTimestamp = void 0),
            (this.nodePubkey = e.nodePubkey),
            (this.authorizedWithdrawer = e.authorizedWithdrawer),
            (this.commission = e.commission),
            (this.rootSlot = e.rootSlot),
            (this.votes = e.votes),
            (this.authorizedVoters = e.authorizedVoters),
            (this.priorVoters = e.priorVoters),
            (this.epochCredits = e.epochCredits),
            (this.lastTimestamp = e.lastTimestamp);
        }
        static fromAccountData(e) {
          let r = P6.decode(Be(e), 4),
            i = r.rootSlot;
          return (
            r.rootSlotValid || (i = null),
            new n({
              nodePubkey: new J(r.nodePubkey),
              authorizedWithdrawer: new J(r.authorizedWithdrawer),
              commission: r.commission,
              votes: r.votes,
              rootSlot: i,
              authorizedVoters: r.authorizedVoters.map(L6),
              priorVoters: O6(r.priorVoters),
              epochCredits: r.epochCredits,
              lastTimestamp: r.lastTimestamp,
            })
          );
        }
      });
    w2 = {
      http: {
        devnet: "http://api.devnet.solana.com",
        testnet: "http://api.testnet.solana.com",
        "mainnet-beta": "http://api.mainnet-beta.solana.com/",
      },
      https: {
        devnet: "https://api.devnet.solana.com",
        testnet: "https://api.testnet.solana.com",
        "mainnet-beta": "https://api.mainnet-beta.solana.com/",
      },
    };
    M6 = 1e9;
  });
var sT = ve((wne, iT) => {
  "use strict";
  p();
  function B5(n) {
    if (n.length >= 255) throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), t = 0; t < e.length; t++) e[t] = 255;
    for (var r = 0; r < n.length; r++) {
      var i = n.charAt(r),
        s = i.charCodeAt(0);
      if (e[s] !== 255) throw new TypeError(i + " is ambiguous");
      e[s] = r;
    }
    var o = n.length,
      a = n.charAt(0),
      c = Math.log(o) / Math.log(256),
      u = Math.log(256) / Math.log(o);
    function l(g) {
      if (
        (g instanceof Uint8Array ||
          (ArrayBuffer.isView(g)
            ? (g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength))
            : Array.isArray(g) && (g = Uint8Array.from(g))),
        !(g instanceof Uint8Array))
      )
        throw new TypeError("Expected Uint8Array");
      if (g.length === 0) return "";
      for (var y = 0, w = 0, m = 0, b = g.length; m !== b && g[m] === 0; )
        m++, y++;
      for (var I = ((b - m) * u + 1) >>> 0, E = new Uint8Array(I); m !== b; ) {
        for (
          var T = g[m], B = 0, L = I - 1;
          (T !== 0 || B < w) && L !== -1;
          L--, B++
        )
          (T += (256 * E[L]) >>> 0), (E[L] = T % o >>> 0), (T = (T / o) >>> 0);
        if (T !== 0) throw new Error("Non-zero carry");
        (w = B), m++;
      }
      for (var U = I - w; U !== I && E[U] === 0; ) U++;
      for (var j = a.repeat(y); U < I; ++U) j += n.charAt(E[U]);
      return j;
    }
    function h(g) {
      if (typeof g != "string") throw new TypeError("Expected String");
      if (g.length === 0) return new Uint8Array();
      for (var y = 0, w = 0, m = 0; g[y] === a; ) w++, y++;
      for (
        var b = ((g.length - y) * c + 1) >>> 0, I = new Uint8Array(b);
        g[y];

      ) {
        var E = e[g.charCodeAt(y)];
        if (E === 255) return;
        for (var T = 0, B = b - 1; (E !== 0 || T < m) && B !== -1; B--, T++)
          (E += (o * I[B]) >>> 0),
            (I[B] = E % 256 >>> 0),
            (E = (E / 256) >>> 0);
        if (E !== 0) throw new Error("Non-zero carry");
        (m = T), y++;
      }
      for (var L = b - m; L !== b && I[L] === 0; ) L++;
      for (var U = new Uint8Array(w + (b - L)), j = w; L !== b; )
        U[j++] = I[L++];
      return U;
    }
    function f(g) {
      var y = h(g);
      if (y) return y;
      throw new Error("Non-base" + o + " character");
    }
    return { encode: l, decodeUnsafe: h, decode: f };
  }
  iT.exports = B5;
});
var aT = ve((Ane, oT) => {
  "use strict";
  p();
  var D5 = sT(),
    _5 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  oT.exports = D5(_5);
});
var dT = ve((kne, fT) => {
  "use strict";
  p();
  fT.exports = function () {
    return (
      typeof Promise == "function" &&
      Promise.prototype &&
      Promise.prototype.then
    );
  };
});
var Hs = ve((na) => {
  "use strict";
  p();
  var zb,
    L5 = [
      0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655,
      733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921,
      2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,
    ];
  na.getSymbolSize = function (e) {
    if (!e) throw new Error('"version" cannot be null or undefined');
    if (e < 1 || e > 40)
      throw new Error('"version" should be in range from 1 to 40');
    return e * 4 + 17;
  };
  na.getSymbolTotalCodewords = function (e) {
    return L5[e];
  };
  na.getBCHDigit = function (n) {
    let e = 0;
    for (; n !== 0; ) e++, (n >>>= 1);
    return e;
  };
  na.setToSJISFunction = function (e) {
    if (typeof e != "function")
      throw new Error('"toSJISFunc" is not a valid function.');
    zb = e;
  };
  na.isKanjiModeEnabled = function () {
    return typeof zb < "u";
  };
  na.toSJIS = function (e) {
    return zb(e);
  };
});
var og = ve((yr) => {
  "use strict";
  p();
  yr.L = { bit: 1 };
  yr.M = { bit: 0 };
  yr.Q = { bit: 3 };
  yr.H = { bit: 2 };
  function O5(n) {
    if (typeof n != "string") throw new Error("Param is not a string");
    switch (n.toLowerCase()) {
      case "l":
      case "low":
        return yr.L;
      case "m":
      case "medium":
        return yr.M;
      case "q":
      case "quartile":
        return yr.Q;
      case "h":
      case "high":
        return yr.H;
      default:
        throw new Error("Unknown EC Level: " + n);
    }
  }
  yr.isValid = function (e) {
    return e && typeof e.bit < "u" && e.bit >= 0 && e.bit < 4;
  };
  yr.from = function (e, t) {
    if (yr.isValid(e)) return e;
    try {
      return O5(e);
    } catch {
      return t;
    }
  };
});
var mT = ve((Pne, gT) => {
  "use strict";
  p();
  function pT() {
    (this.buffer = []), (this.length = 0);
  }
  pT.prototype = {
    get: function (n) {
      let e = Math.floor(n / 8);
      return ((this.buffer[e] >>> (7 - (n % 8))) & 1) === 1;
    },
    put: function (n, e) {
      for (let t = 0; t < e; t++) this.putBit(((n >>> (e - t - 1)) & 1) === 1);
    },
    getLengthInBits: function () {
      return this.length;
    },
    putBit: function (n) {
      let e = Math.floor(this.length / 8);
      this.buffer.length <= e && this.buffer.push(0),
        n && (this.buffer[e] |= 128 >>> this.length % 8),
        this.length++;
    },
  };
  gT.exports = pT;
});
var wT = ve((One, yT) => {
  "use strict";
  p();
  function lh(n) {
    if (!n || n < 1)
      throw new Error("BitMatrix size must be defined and greater than 0");
    (this.size = n),
      (this.data = new Uint8Array(n * n)),
      (this.reservedBit = new Uint8Array(n * n));
  }
  lh.prototype.set = function (n, e, t, r) {
    let i = n * this.size + e;
    (this.data[i] = t), r && (this.reservedBit[i] = !0);
  };
  lh.prototype.get = function (n, e) {
    return this.data[n * this.size + e];
  };
  lh.prototype.xor = function (n, e, t) {
    this.data[n * this.size + e] ^= t;
  };
  lh.prototype.isReserved = function (n, e) {
    return this.reservedBit[n * this.size + e];
  };
  yT.exports = lh;
});
var bT = ve((ag) => {
  "use strict";
  p();
  var N5 = Hs().getSymbolSize;
  ag.getRowColCoords = function (e) {
    if (e === 1) return [];
    let t = Math.floor(e / 7) + 2,
      r = N5(e),
      i = r === 145 ? 26 : Math.ceil((r - 13) / (2 * t - 2)) * 2,
      s = [r - 7];
    for (let o = 1; o < t - 1; o++) s[o] = s[o - 1] - i;
    return s.push(6), s.reverse();
  };
  ag.getPositions = function (e) {
    let t = [],
      r = ag.getRowColCoords(e),
      i = r.length;
    for (let s = 0; s < i; s++)
      for (let o = 0; o < i; o++)
        (s === 0 && o === 0) ||
          (s === 0 && o === i - 1) ||
          (s === i - 1 && o === 0) ||
          t.push([r[s], r[o]]);
    return t;
  };
});
var xT = ve((ET) => {
  "use strict";
  p();
  var F5 = Hs().getSymbolSize,
    AT = 7;
  ET.getPositions = function (e) {
    let t = F5(e);
    return [
      [0, 0],
      [t - AT, 0],
      [0, t - AT],
    ];
  };
});
var ST = ve((dt) => {
  "use strict";
  p();
  dt.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7,
  };
  var ra = { N1: 3, N2: 3, N3: 40, N4: 10 };
  dt.isValid = function (e) {
    return e != null && e !== "" && !isNaN(e) && e >= 0 && e <= 7;
  };
  dt.from = function (e) {
    return dt.isValid(e) ? parseInt(e, 10) : void 0;
  };
  dt.getPenaltyN1 = function (e) {
    let t = e.size,
      r = 0,
      i = 0,
      s = 0,
      o = null,
      a = null;
    for (let c = 0; c < t; c++) {
      (i = s = 0), (o = a = null);
      for (let u = 0; u < t; u++) {
        let l = e.get(c, u);
        l === o ? i++ : (i >= 5 && (r += ra.N1 + (i - 5)), (o = l), (i = 1)),
          (l = e.get(u, c)),
          l === a ? s++ : (s >= 5 && (r += ra.N1 + (s - 5)), (a = l), (s = 1));
      }
      i >= 5 && (r += ra.N1 + (i - 5)), s >= 5 && (r += ra.N1 + (s - 5));
    }
    return r;
  };
  dt.getPenaltyN2 = function (e) {
    let t = e.size,
      r = 0;
    for (let i = 0; i < t - 1; i++)
      for (let s = 0; s < t - 1; s++) {
        let o =
          e.get(i, s) + e.get(i, s + 1) + e.get(i + 1, s) + e.get(i + 1, s + 1);
        (o === 4 || o === 0) && r++;
      }
    return r * ra.N2;
  };
  dt.getPenaltyN3 = function (e) {
    let t = e.size,
      r = 0,
      i = 0,
      s = 0;
    for (let o = 0; o < t; o++) {
      i = s = 0;
      for (let a = 0; a < t; a++)
        (i = ((i << 1) & 2047) | e.get(o, a)),
          a >= 10 && (i === 1488 || i === 93) && r++,
          (s = ((s << 1) & 2047) | e.get(a, o)),
          a >= 10 && (s === 1488 || s === 93) && r++;
    }
    return r * ra.N3;
  };
  dt.getPenaltyN4 = function (e) {
    let t = 0,
      r = e.data.length;
    for (let s = 0; s < r; s++) t += e.data[s];
    return Math.abs(Math.ceil((t * 100) / r / 5) - 10) * ra.N4;
  };
  function M5(n, e, t) {
    switch (n) {
      case dt.Patterns.PATTERN000:
        return (e + t) % 2 === 0;
      case dt.Patterns.PATTERN001:
        return e % 2 === 0;
      case dt.Patterns.PATTERN010:
        return t % 3 === 0;
      case dt.Patterns.PATTERN011:
        return (e + t) % 3 === 0;
      case dt.Patterns.PATTERN100:
        return (Math.floor(e / 2) + Math.floor(t / 3)) % 2 === 0;
      case dt.Patterns.PATTERN101:
        return ((e * t) % 2) + ((e * t) % 3) === 0;
      case dt.Patterns.PATTERN110:
        return (((e * t) % 2) + ((e * t) % 3)) % 2 === 0;
      case dt.Patterns.PATTERN111:
        return (((e * t) % 3) + ((e + t) % 2)) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + n);
    }
  }
  dt.applyMask = function (e, t) {
    let r = t.size;
    for (let i = 0; i < r; i++)
      for (let s = 0; s < r; s++)
        t.isReserved(s, i) || t.xor(s, i, M5(e, s, i));
  };
  dt.getBestMask = function (e, t) {
    let r = Object.keys(dt.Patterns).length,
      i = 0,
      s = 1 / 0;
    for (let o = 0; o < r; o++) {
      t(o), dt.applyMask(o, e);
      let a =
        dt.getPenaltyN1(e) +
        dt.getPenaltyN2(e) +
        dt.getPenaltyN3(e) +
        dt.getPenaltyN4(e);
      dt.applyMask(o, e), a < s && ((s = a), (i = o));
    }
    return i;
  };
});
var Wb = ve((jb) => {
  "use strict";
  p();
  var Vs = og(),
    cg = [
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2,
      4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4,
      9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6,
      13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9,
      18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34,
      40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17,
      33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56,
      66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81,
    ],
    ug = [
      7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72,
      88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160,
      192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198,
      288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168,
      308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700,
      224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810,
      960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390,
      728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868,
      1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530,
      1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100,
      660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430,
    ];
  jb.getBlocksCount = function (e, t) {
    switch (t) {
      case Vs.L:
        return cg[(e - 1) * 4 + 0];
      case Vs.M:
        return cg[(e - 1) * 4 + 1];
      case Vs.Q:
        return cg[(e - 1) * 4 + 2];
      case Vs.H:
        return cg[(e - 1) * 4 + 3];
      default:
        return;
    }
  };
  jb.getTotalCodewordsCount = function (e, t) {
    switch (t) {
      case Vs.L:
        return ug[(e - 1) * 4 + 0];
      case Vs.M:
        return ug[(e - 1) * 4 + 1];
      case Vs.Q:
        return ug[(e - 1) * 4 + 2];
      case Vs.H:
        return ug[(e - 1) * 4 + 3];
      default:
        return;
    }
  };
});
var vT = ve((hg) => {
  "use strict";
  p();
  var hh = new Uint8Array(512),
    lg = new Uint8Array(256);
  (function () {
    let e = 1;
    for (let t = 0; t < 255; t++)
      (hh[t] = e), (lg[e] = t), (e <<= 1), e & 256 && (e ^= 285);
    for (let t = 255; t < 512; t++) hh[t] = hh[t - 255];
  })();
  hg.log = function (e) {
    if (e < 1) throw new Error("log(" + e + ")");
    return lg[e];
  };
  hg.exp = function (e) {
    return hh[e];
  };
  hg.mul = function (e, t) {
    return e === 0 || t === 0 ? 0 : hh[lg[e] + lg[t]];
  };
});
var IT = ve((fh) => {
  "use strict";
  p();
  var Hb = vT();
  fh.mul = function (e, t) {
    let r = new Uint8Array(e.length + t.length - 1);
    for (let i = 0; i < e.length; i++)
      for (let s = 0; s < t.length; s++) r[i + s] ^= Hb.mul(e[i], t[s]);
    return r;
  };
  fh.mod = function (e, t) {
    let r = new Uint8Array(e);
    for (; r.length - t.length >= 0; ) {
      let i = r[0];
      for (let o = 0; o < t.length; o++) r[o] ^= Hb.mul(t[o], i);
      let s = 0;
      for (; s < r.length && r[s] === 0; ) s++;
      r = r.slice(s);
    }
    return r;
  };
  fh.generateECPolynomial = function (e) {
    let t = new Uint8Array([1]);
    for (let r = 0; r < e; r++) t = fh.mul(t, new Uint8Array([1, Hb.exp(r)]));
    return t;
  };
});
var TT = ve((Qne, kT) => {
  "use strict";
  p();
  var CT = IT();
  function Vb(n) {
    (this.genPoly = void 0),
      (this.degree = n),
      this.degree && this.initialize(this.degree);
  }
  Vb.prototype.initialize = function (e) {
    (this.degree = e), (this.genPoly = CT.generateECPolynomial(this.degree));
  };
  Vb.prototype.encode = function (e) {
    if (!this.genPoly) throw new Error("Encoder not initialized");
    let t = new Uint8Array(e.length + this.degree);
    t.set(e);
    let r = CT.mod(t, this.genPoly),
      i = this.degree - r.length;
    if (i > 0) {
      let s = new Uint8Array(this.degree);
      return s.set(r, i), s;
    }
    return r;
  };
  kT.exports = Vb;
});
var $b = ve((RT) => {
  "use strict";
  p();
  RT.isValid = function (e) {
    return !isNaN(e) && e >= 1 && e <= 40;
  };
});
var Gb = ve((Qi) => {
  "use strict";
  p();
  var BT = "[0-9]+",
    U5 = "[A-Z $%*+\\-./:]+",
    dh =
      "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
  dh = dh.replace(/u/g, "\\u");
  var z5 =
    "(?:(?![A-Z0-9 $%*+\\-./:]|" +
    dh +
    `)(?:.|[\r
]))+`;
  Qi.KANJI = new RegExp(dh, "g");
  Qi.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
  Qi.BYTE = new RegExp(z5, "g");
  Qi.NUMERIC = new RegExp(BT, "g");
  Qi.ALPHANUMERIC = new RegExp(U5, "g");
  var j5 = new RegExp("^" + dh + "$"),
    W5 = new RegExp("^" + BT + "$"),
    H5 = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
  Qi.testKanji = function (e) {
    return j5.test(e);
  };
  Qi.testNumeric = function (e) {
    return W5.test(e);
  };
  Qi.testAlphanumeric = function (e) {
    return H5.test(e);
  };
});
var $s = ve((Ot) => {
  "use strict";
  p();
  var V5 = $b(),
    Kb = Gb();
  Ot.NUMERIC = { id: "Numeric", bit: 1, ccBits: [10, 12, 14] };
  Ot.ALPHANUMERIC = { id: "Alphanumeric", bit: 2, ccBits: [9, 11, 13] };
  Ot.BYTE = { id: "Byte", bit: 4, ccBits: [8, 16, 16] };
  Ot.KANJI = { id: "Kanji", bit: 8, ccBits: [8, 10, 12] };
  Ot.MIXED = { bit: -1 };
  Ot.getCharCountIndicator = function (e, t) {
    if (!e.ccBits) throw new Error("Invalid mode: " + e);
    if (!V5.isValid(t)) throw new Error("Invalid version: " + t);
    return t >= 1 && t < 10 ? e.ccBits[0] : t < 27 ? e.ccBits[1] : e.ccBits[2];
  };
  Ot.getBestModeForData = function (e) {
    return Kb.testNumeric(e)
      ? Ot.NUMERIC
      : Kb.testAlphanumeric(e)
      ? Ot.ALPHANUMERIC
      : Kb.testKanji(e)
      ? Ot.KANJI
      : Ot.BYTE;
  };
  Ot.toString = function (e) {
    if (e && e.id) return e.id;
    throw new Error("Invalid mode");
  };
  Ot.isValid = function (e) {
    return e && e.bit && e.ccBits;
  };
  function $5(n) {
    if (typeof n != "string") throw new Error("Param is not a string");
    switch (n.toLowerCase()) {
      case "numeric":
        return Ot.NUMERIC;
      case "alphanumeric":
        return Ot.ALPHANUMERIC;
      case "kanji":
        return Ot.KANJI;
      case "byte":
        return Ot.BYTE;
      default:
        throw new Error("Unknown mode: " + n);
    }
  }
  Ot.from = function (e, t) {
    if (Ot.isValid(e)) return e;
    try {
      return $5(e);
    } catch {
      return t;
    }
  };
});
var OT = ve((ia) => {
  "use strict";
  p();
  var fg = Hs(),
    G5 = Wb(),
    DT = og(),
    Gs = $s(),
    qb = $b(),
    PT = 7973,
    _T = fg.getBCHDigit(PT);
  function K5(n, e, t) {
    for (let r = 1; r <= 40; r++) if (e <= ia.getCapacity(r, t, n)) return r;
  }
  function LT(n, e) {
    return Gs.getCharCountIndicator(n, e) + 4;
  }
  function q5(n, e) {
    let t = 0;
    return (
      n.forEach(function (r) {
        let i = LT(r.mode, e);
        t += i + r.getBitsLength();
      }),
      t
    );
  }
  function Q5(n, e) {
    for (let t = 1; t <= 40; t++)
      if (q5(n, t) <= ia.getCapacity(t, e, Gs.MIXED)) return t;
  }
  ia.from = function (e, t) {
    return qb.isValid(e) ? parseInt(e, 10) : t;
  };
  ia.getCapacity = function (e, t, r) {
    if (!qb.isValid(e)) throw new Error("Invalid QR Code version");
    typeof r > "u" && (r = Gs.BYTE);
    let i = fg.getSymbolTotalCodewords(e),
      s = G5.getTotalCodewordsCount(e, t),
      o = (i - s) * 8;
    if (r === Gs.MIXED) return o;
    let a = o - LT(r, e);
    switch (r) {
      case Gs.NUMERIC:
        return Math.floor((a / 10) * 3);
      case Gs.ALPHANUMERIC:
        return Math.floor((a / 11) * 2);
      case Gs.KANJI:
        return Math.floor(a / 13);
      case Gs.BYTE:
      default:
        return Math.floor(a / 8);
    }
  };
  ia.getBestVersionForData = function (e, t) {
    let r,
      i = DT.from(t, DT.M);
    if (Array.isArray(e)) {
      if (e.length > 1) return Q5(e, i);
      if (e.length === 0) return 1;
      r = e[0];
    } else r = e;
    return K5(r.mode, r.getLength(), i);
  };
  ia.getEncodedBits = function (e) {
    if (!qb.isValid(e) || e < 7) throw new Error("Invalid QR Code version");
    let t = e << 12;
    for (; fg.getBCHDigit(t) - _T >= 0; ) t ^= PT << (fg.getBCHDigit(t) - _T);
    return (e << 12) | t;
  };
});
var UT = ve((MT) => {
  "use strict";
  p();
  var Qb = Hs(),
    FT = 1335,
    J5 = 21522,
    NT = Qb.getBCHDigit(FT);
  MT.getEncodedBits = function (e, t) {
    let r = (e.bit << 3) | t,
      i = r << 10;
    for (; Qb.getBCHDigit(i) - NT >= 0; ) i ^= FT << (Qb.getBCHDigit(i) - NT);
    return ((r << 10) | i) ^ J5;
  };
});
var jT = ve((are, zT) => {
  "use strict";
  p();
  var Y5 = $s();
  function au(n) {
    (this.mode = Y5.NUMERIC), (this.data = n.toString());
  }
  au.getBitsLength = function (e) {
    return 10 * Math.floor(e / 3) + (e % 3 ? (e % 3) * 3 + 1 : 0);
  };
  au.prototype.getLength = function () {
    return this.data.length;
  };
  au.prototype.getBitsLength = function () {
    return au.getBitsLength(this.data.length);
  };
  au.prototype.write = function (e) {
    let t, r, i;
    for (t = 0; t + 3 <= this.data.length; t += 3)
      (r = this.data.substr(t, 3)), (i = parseInt(r, 10)), e.put(i, 10);
    let s = this.data.length - t;
    s > 0 &&
      ((r = this.data.substr(t)), (i = parseInt(r, 10)), e.put(i, s * 3 + 1));
  };
  zT.exports = au;
});
var HT = ve((ure, WT) => {
  "use strict";
  p();
  var Z5 = $s(),
    Jb = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":",
    ];
  function cu(n) {
    (this.mode = Z5.ALPHANUMERIC), (this.data = n);
  }
  cu.getBitsLength = function (e) {
    return 11 * Math.floor(e / 2) + 6 * (e % 2);
  };
  cu.prototype.getLength = function () {
    return this.data.length;
  };
  cu.prototype.getBitsLength = function () {
    return cu.getBitsLength(this.data.length);
  };
  cu.prototype.write = function (e) {
    let t;
    for (t = 0; t + 2 <= this.data.length; t += 2) {
      let r = Jb.indexOf(this.data[t]) * 45;
      (r += Jb.indexOf(this.data[t + 1])), e.put(r, 11);
    }
    this.data.length % 2 && e.put(Jb.indexOf(this.data[t]), 6);
  };
  WT.exports = cu;
});
var $T = ve((hre, VT) => {
  "use strict";
  p();
  var X5 = $s();
  function uu(n) {
    (this.mode = X5.BYTE),
      typeof n == "string"
        ? (this.data = new TextEncoder().encode(n))
        : (this.data = new Uint8Array(n));
  }
  uu.getBitsLength = function (e) {
    return e * 8;
  };
  uu.prototype.getLength = function () {
    return this.data.length;
  };
  uu.prototype.getBitsLength = function () {
    return uu.getBitsLength(this.data.length);
  };
  uu.prototype.write = function (n) {
    for (let e = 0, t = this.data.length; e < t; e++) n.put(this.data[e], 8);
  };
  VT.exports = uu;
});
var KT = ve((dre, GT) => {
  "use strict";
  p();
  var ez = $s(),
    tz = Hs();
  function lu(n) {
    (this.mode = ez.KANJI), (this.data = n);
  }
  lu.getBitsLength = function (e) {
    return e * 13;
  };
  lu.prototype.getLength = function () {
    return this.data.length;
  };
  lu.prototype.getBitsLength = function () {
    return lu.getBitsLength(this.data.length);
  };
  lu.prototype.write = function (n) {
    let e;
    for (e = 0; e < this.data.length; e++) {
      let t = tz.toSJIS(this.data[e]);
      if (t >= 33088 && t <= 40956) t -= 33088;
      else if (t >= 57408 && t <= 60351) t -= 49472;
      else
        throw new Error(
          "Invalid SJIS character: " +
            this.data[e] +
            `
Make sure your charset is UTF-8`
        );
      (t = ((t >>> 8) & 255) * 192 + (t & 255)), n.put(t, 13);
    }
  };
  GT.exports = lu;
});
var tR = ve((hu) => {
  "use strict";
  p();
  var Xe = $s(),
    JT = jT(),
    YT = HT(),
    ZT = $T(),
    XT = KT(),
    ph = Gb(),
    dg = Hs(),
    nz = GB();
  function qT(n) {
    return unescape(encodeURIComponent(n)).length;
  }
  function gh(n, e, t) {
    let r = [],
      i;
    for (; (i = n.exec(t)) !== null; )
      r.push({ data: i[0], index: i.index, mode: e, length: i[0].length });
    return r;
  }
  function eR(n) {
    let e = gh(ph.NUMERIC, Xe.NUMERIC, n),
      t = gh(ph.ALPHANUMERIC, Xe.ALPHANUMERIC, n),
      r,
      i;
    return (
      dg.isKanjiModeEnabled()
        ? ((r = gh(ph.BYTE, Xe.BYTE, n)), (i = gh(ph.KANJI, Xe.KANJI, n)))
        : ((r = gh(ph.BYTE_KANJI, Xe.BYTE, n)), (i = [])),
      e
        .concat(t, r, i)
        .sort(function (o, a) {
          return o.index - a.index;
        })
        .map(function (o) {
          return { data: o.data, mode: o.mode, length: o.length };
        })
    );
  }
  function Yb(n, e) {
    switch (e) {
      case Xe.NUMERIC:
        return JT.getBitsLength(n);
      case Xe.ALPHANUMERIC:
        return YT.getBitsLength(n);
      case Xe.KANJI:
        return XT.getBitsLength(n);
      case Xe.BYTE:
        return ZT.getBitsLength(n);
    }
  }
  function rz(n) {
    return n.reduce(function (e, t) {
      let r = e.length - 1 >= 0 ? e[e.length - 1] : null;
      return r && r.mode === t.mode
        ? ((e[e.length - 1].data += t.data), e)
        : (e.push(t), e);
    }, []);
  }
  function iz(n) {
    let e = [];
    for (let t = 0; t < n.length; t++) {
      let r = n[t];
      switch (r.mode) {
        case Xe.NUMERIC:
          e.push([
            r,
            { data: r.data, mode: Xe.ALPHANUMERIC, length: r.length },
            { data: r.data, mode: Xe.BYTE, length: r.length },
          ]);
          break;
        case Xe.ALPHANUMERIC:
          e.push([r, { data: r.data, mode: Xe.BYTE, length: r.length }]);
          break;
        case Xe.KANJI:
          e.push([r, { data: r.data, mode: Xe.BYTE, length: qT(r.data) }]);
          break;
        case Xe.BYTE:
          e.push([{ data: r.data, mode: Xe.BYTE, length: qT(r.data) }]);
      }
    }
    return e;
  }
  function sz(n, e) {
    let t = {},
      r = { start: {} },
      i = ["start"];
    for (let s = 0; s < n.length; s++) {
      let o = n[s],
        a = [];
      for (let c = 0; c < o.length; c++) {
        let u = o[c],
          l = "" + s + c;
        a.push(l), (t[l] = { node: u, lastCount: 0 }), (r[l] = {});
        for (let h = 0; h < i.length; h++) {
          let f = i[h];
          t[f] && t[f].node.mode === u.mode
            ? ((r[f][l] =
                Yb(t[f].lastCount + u.length, u.mode) -
                Yb(t[f].lastCount, u.mode)),
              (t[f].lastCount += u.length))
            : (t[f] && (t[f].lastCount = u.length),
              (r[f][l] =
                Yb(u.length, u.mode) +
                4 +
                Xe.getCharCountIndicator(u.mode, e)));
        }
      }
      i = a;
    }
    for (let s = 0; s < i.length; s++) r[i[s]].end = 0;
    return { map: r, table: t };
  }
  function QT(n, e) {
    let t,
      r = Xe.getBestModeForData(n);
    if (((t = Xe.from(e, r)), t !== Xe.BYTE && t.bit < r.bit))
      throw new Error(
        '"' +
          n +
          '" cannot be encoded with mode ' +
          Xe.toString(t) +
          `.
 Suggested mode is: ` +
          Xe.toString(r)
      );
    switch ((t === Xe.KANJI && !dg.isKanjiModeEnabled() && (t = Xe.BYTE), t)) {
      case Xe.NUMERIC:
        return new JT(n);
      case Xe.ALPHANUMERIC:
        return new YT(n);
      case Xe.KANJI:
        return new XT(n);
      case Xe.BYTE:
        return new ZT(n);
    }
  }
  hu.fromArray = function (e) {
    return e.reduce(function (t, r) {
      return (
        typeof r == "string"
          ? t.push(QT(r, null))
          : r.data && t.push(QT(r.data, r.mode)),
        t
      );
    }, []);
  };
  hu.fromString = function (e, t) {
    let r = eR(e, dg.isKanjiModeEnabled()),
      i = iz(r),
      s = sz(i, t),
      o = nz.find_path(s.map, "start", "end"),
      a = [];
    for (let c = 1; c < o.length - 1; c++) a.push(s.table[o[c]].node);
    return hu.fromArray(rz(a));
  };
  hu.rawSplit = function (e) {
    return hu.fromArray(eR(e, dg.isKanjiModeEnabled()));
  };
});
var rR = ve((nR) => {
  "use strict";
  p();
  var gg = Hs(),
    Zb = og(),
    oz = mT(),
    az = wT(),
    cz = bT(),
    uz = xT(),
    tA = ST(),
    nA = Wb(),
    lz = TT(),
    pg = OT(),
    hz = UT(),
    fz = $s(),
    Xb = tR();
  function dz(n, e) {
    let t = n.size,
      r = uz.getPositions(e);
    for (let i = 0; i < r.length; i++) {
      let s = r[i][0],
        o = r[i][1];
      for (let a = -1; a <= 7; a++)
        if (!(s + a <= -1 || t <= s + a))
          for (let c = -1; c <= 7; c++)
            o + c <= -1 ||
              t <= o + c ||
              ((a >= 0 && a <= 6 && (c === 0 || c === 6)) ||
              (c >= 0 && c <= 6 && (a === 0 || a === 6)) ||
              (a >= 2 && a <= 4 && c >= 2 && c <= 4)
                ? n.set(s + a, o + c, !0, !0)
                : n.set(s + a, o + c, !1, !0));
    }
  }
  function pz(n) {
    let e = n.size;
    for (let t = 8; t < e - 8; t++) {
      let r = t % 2 === 0;
      n.set(t, 6, r, !0), n.set(6, t, r, !0);
    }
  }
  function gz(n, e) {
    let t = cz.getPositions(e);
    for (let r = 0; r < t.length; r++) {
      let i = t[r][0],
        s = t[r][1];
      for (let o = -2; o <= 2; o++)
        for (let a = -2; a <= 2; a++)
          o === -2 || o === 2 || a === -2 || a === 2 || (o === 0 && a === 0)
            ? n.set(i + o, s + a, !0, !0)
            : n.set(i + o, s + a, !1, !0);
    }
  }
  function mz(n, e) {
    let t = n.size,
      r = pg.getEncodedBits(e),
      i,
      s,
      o;
    for (let a = 0; a < 18; a++)
      (i = Math.floor(a / 3)),
        (s = (a % 3) + t - 8 - 3),
        (o = ((r >> a) & 1) === 1),
        n.set(i, s, o, !0),
        n.set(s, i, o, !0);
  }
  function eA(n, e, t) {
    let r = n.size,
      i = hz.getEncodedBits(e, t),
      s,
      o;
    for (s = 0; s < 15; s++)
      (o = ((i >> s) & 1) === 1),
        s < 6
          ? n.set(s, 8, o, !0)
          : s < 8
          ? n.set(s + 1, 8, o, !0)
          : n.set(r - 15 + s, 8, o, !0),
        s < 8
          ? n.set(8, r - s - 1, o, !0)
          : s < 9
          ? n.set(8, 15 - s - 1 + 1, o, !0)
          : n.set(8, 15 - s - 1, o, !0);
    n.set(r - 8, 8, 1, !0);
  }
  function yz(n, e) {
    let t = n.size,
      r = -1,
      i = t - 1,
      s = 7,
      o = 0;
    for (let a = t - 1; a > 0; a -= 2)
      for (a === 6 && a--; ; ) {
        for (let c = 0; c < 2; c++)
          if (!n.isReserved(i, a - c)) {
            let u = !1;
            o < e.length && (u = ((e[o] >>> s) & 1) === 1),
              n.set(i, a - c, u),
              s--,
              s === -1 && (o++, (s = 7));
          }
        if (((i += r), i < 0 || t <= i)) {
          (i -= r), (r = -r);
          break;
        }
      }
  }
  function wz(n, e, t) {
    let r = new oz();
    t.forEach(function (c) {
      r.put(c.mode.bit, 4),
        r.put(c.getLength(), fz.getCharCountIndicator(c.mode, n)),
        c.write(r);
    });
    let i = gg.getSymbolTotalCodewords(n),
      s = nA.getTotalCodewordsCount(n, e),
      o = (i - s) * 8;
    for (
      r.getLengthInBits() + 4 <= o && r.put(0, 4);
      r.getLengthInBits() % 8 !== 0;

    )
      r.putBit(0);
    let a = (o - r.getLengthInBits()) / 8;
    for (let c = 0; c < a; c++) r.put(c % 2 ? 17 : 236, 8);
    return bz(r, n, e);
  }
  function bz(n, e, t) {
    let r = gg.getSymbolTotalCodewords(e),
      i = nA.getTotalCodewordsCount(e, t),
      s = r - i,
      o = nA.getBlocksCount(e, t),
      a = r % o,
      c = o - a,
      u = Math.floor(r / o),
      l = Math.floor(s / o),
      h = l + 1,
      f = u - l,
      g = new lz(f),
      y = 0,
      w = new Array(o),
      m = new Array(o),
      b = 0,
      I = new Uint8Array(n.buffer);
    for (let U = 0; U < o; U++) {
      let j = U < c ? l : h;
      (w[U] = I.slice(y, y + j)),
        (m[U] = g.encode(w[U])),
        (y += j),
        (b = Math.max(b, j));
    }
    let E = new Uint8Array(r),
      T = 0,
      B,
      L;
    for (B = 0; B < b; B++)
      for (L = 0; L < o; L++) B < w[L].length && (E[T++] = w[L][B]);
    for (B = 0; B < f; B++) for (L = 0; L < o; L++) E[T++] = m[L][B];
    return E;
  }
  function Az(n, e, t, r) {
    let i;
    if (Array.isArray(n)) i = Xb.fromArray(n);
    else if (typeof n == "string") {
      let u = e;
      if (!u) {
        let l = Xb.rawSplit(n);
        u = pg.getBestVersionForData(l, t);
      }
      i = Xb.fromString(n, u || 40);
    } else throw new Error("Invalid data");
    let s = pg.getBestVersionForData(i, t);
    if (!s)
      throw new Error(
        "The amount of data is too big to be stored in a QR Code"
      );
    if (!e) e = s;
    else if (e < s)
      throw new Error(
        `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` +
          s +
          `.
`
      );
    let o = wz(e, t, i),
      a = gg.getSymbolSize(e),
      c = new az(a);
    return (
      dz(c, e),
      pz(c),
      gz(c, e),
      eA(c, t, 0),
      e >= 7 && mz(c, e),
      yz(c, o),
      isNaN(r) && (r = tA.getBestMask(c, eA.bind(null, c, t))),
      tA.applyMask(r, c),
      eA(c, t, r),
      {
        modules: c,
        version: e,
        errorCorrectionLevel: t,
        maskPattern: r,
        segments: i,
      }
    );
  }
  nR.create = function (e, t) {
    if (typeof e > "u" || e === "") throw new Error("No input text");
    let r = Zb.M,
      i,
      s;
    return (
      typeof t < "u" &&
        ((r = Zb.from(t.errorCorrectionLevel, Zb.M)),
        (i = pg.from(t.version)),
        (s = tA.from(t.maskPattern)),
        t.toSJISFunc && gg.setToSJISFunction(t.toSJISFunc)),
      Az(e, i, r, s)
    );
  };
});
var rA = ve((sa) => {
  "use strict";
  p();
  function iR(n) {
    if ((typeof n == "number" && (n = n.toString()), typeof n != "string"))
      throw new Error("Color should be defined as hex string");
    let e = n.slice().replace("#", "").split("");
    if (e.length < 3 || e.length === 5 || e.length > 8)
      throw new Error("Invalid hex color: " + n);
    (e.length === 3 || e.length === 4) &&
      (e = Array.prototype.concat.apply(
        [],
        e.map(function (r) {
          return [r, r];
        })
      )),
      e.length === 6 && e.push("F", "F");
    let t = parseInt(e.join(""), 16);
    return {
      r: (t >> 24) & 255,
      g: (t >> 16) & 255,
      b: (t >> 8) & 255,
      a: t & 255,
      hex: "#" + e.slice(0, 6).join(""),
    };
  }
  sa.getOptions = function (e) {
    e || (e = {}), e.color || (e.color = {});
    let t =
        typeof e.margin > "u" || e.margin === null || e.margin < 0
          ? 4
          : e.margin,
      r = e.width && e.width >= 21 ? e.width : void 0,
      i = e.scale || 4;
    return {
      width: r,
      scale: r ? 4 : i,
      margin: t,
      color: {
        dark: iR(e.color.dark || "#000000ff"),
        light: iR(e.color.light || "#ffffffff"),
      },
      type: e.type,
      rendererOpts: e.rendererOpts || {},
    };
  };
  sa.getScale = function (e, t) {
    return t.width && t.width >= e + t.margin * 2
      ? t.width / (e + t.margin * 2)
      : t.scale;
  };
  sa.getImageWidth = function (e, t) {
    let r = sa.getScale(e, t);
    return Math.floor((e + t.margin * 2) * r);
  };
  sa.qrToImageData = function (e, t, r) {
    let i = t.modules.size,
      s = t.modules.data,
      o = sa.getScale(i, r),
      a = Math.floor((i + r.margin * 2) * o),
      c = r.margin * o,
      u = [r.color.light, r.color.dark];
    for (let l = 0; l < a; l++)
      for (let h = 0; h < a; h++) {
        let f = (l * a + h) * 4,
          g = r.color.light;
        if (l >= c && h >= c && l < a - c && h < a - c) {
          let y = Math.floor((l - c) / o),
            w = Math.floor((h - c) / o);
          g = u[s[y * i + w] ? 1 : 0];
        }
        (e[f++] = g.r), (e[f++] = g.g), (e[f++] = g.b), (e[f] = g.a);
      }
  };
});
var sR = ve((mg) => {
  "use strict";
  p();
  var iA = rA();
  function Ez(n, e, t) {
    n.clearRect(0, 0, e.width, e.height),
      e.style || (e.style = {}),
      (e.height = t),
      (e.width = t),
      (e.style.height = t + "px"),
      (e.style.width = t + "px");
  }
  function xz() {
    try {
      return document.createElement("canvas");
    } catch {
      throw new Error("You need to specify a canvas element");
    }
  }
  mg.render = function (e, t, r) {
    let i = r,
      s = t;
    typeof i > "u" && (!t || !t.getContext) && ((i = t), (t = void 0)),
      t || (s = xz()),
      (i = iA.getOptions(i));
    let o = iA.getImageWidth(e.modules.size, i),
      a = s.getContext("2d"),
      c = a.createImageData(o, o);
    return (
      iA.qrToImageData(c.data, e, i), Ez(a, s, o), a.putImageData(c, 0, 0), s
    );
  };
  mg.renderToDataURL = function (e, t, r) {
    let i = r;
    typeof i > "u" && (!t || !t.getContext) && ((i = t), (t = void 0)),
      i || (i = {});
    let s = mg.render(e, t, i),
      o = i.type || "image/png",
      a = i.rendererOpts || {};
    return s.toDataURL(o, a.quality);
  };
});
var cR = ve((aR) => {
  "use strict";
  p();
  var Sz = rA();
  function oR(n, e) {
    let t = n.a / 255,
      r = e + '="' + n.hex + '"';
    return t < 1 ? r + " " + e + '-opacity="' + t.toFixed(2).slice(1) + '"' : r;
  }
  function sA(n, e, t) {
    let r = n + e;
    return typeof t < "u" && (r += " " + t), r;
  }
  function vz(n, e, t) {
    let r = "",
      i = 0,
      s = !1,
      o = 0;
    for (let a = 0; a < n.length; a++) {
      let c = Math.floor(a % e),
        u = Math.floor(a / e);
      !c && !s && (s = !0),
        n[a]
          ? (o++,
            (a > 0 && c > 0 && n[a - 1]) ||
              ((r += s ? sA("M", c + t, 0.5 + u + t) : sA("m", i, 0)),
              (i = 0),
              (s = !1)),
            (c + 1 < e && n[a + 1]) || ((r += sA("h", o)), (o = 0)))
          : i++;
    }
    return r;
  }
  aR.render = function (e, t, r) {
    let i = Sz.getOptions(t),
      s = e.modules.size,
      o = e.modules.data,
      a = s + i.margin * 2,
      c = i.color.light.a
        ? "<path " +
          oR(i.color.light, "fill") +
          ' d="M0 0h' +
          a +
          "v" +
          a +
          'H0z"/>'
        : "",
      u =
        "<path " +
        oR(i.color.dark, "stroke") +
        ' d="' +
        vz(o, s, i.margin) +
        '"/>',
      l = 'viewBox="0 0 ' + a + " " + a + '"',
      f =
        '<svg xmlns="http://www.w3.org/2000/svg" ' +
        (i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "") +
        l +
        ' shape-rendering="crispEdges">' +
        c +
        u +
        `</svg>
`;
    return typeof r == "function" && r(null, f), f;
  };
});
var lR = ve((mh) => {
  "use strict";
  p();
  var Iz = dT(),
    oA = rR(),
    uR = sR(),
    Cz = cR();
  function aA(n, e, t, r, i) {
    let s = [].slice.call(arguments, 1),
      o = s.length,
      a = typeof s[o - 1] == "function";
    if (!a && !Iz()) throw new Error("Callback required as last argument");
    if (a) {
      if (o < 2) throw new Error("Too few arguments provided");
      o === 2
        ? ((i = t), (t = e), (e = r = void 0))
        : o === 3 &&
          (e.getContext && typeof i > "u"
            ? ((i = r), (r = void 0))
            : ((i = r), (r = t), (t = e), (e = void 0)));
    } else {
      if (o < 1) throw new Error("Too few arguments provided");
      return (
        o === 1
          ? ((t = e), (e = r = void 0))
          : o === 2 && !e.getContext && ((r = t), (t = e), (e = void 0)),
        new Promise(function (c, u) {
          try {
            let l = oA.create(t, r);
            c(n(l, e, r));
          } catch (l) {
            u(l);
          }
        })
      );
    }
    try {
      let c = oA.create(t, r);
      i(null, n(c, e, r));
    } catch (c) {
      i(c);
    }
  }
  mh.create = oA.create;
  mh.toCanvas = aA.bind(null, uR.render);
  mh.toDataURL = aA.bind(null, uR.renderToDataURL);
  mh.toString = aA.bind(null, function (n, e, t) {
    return Cz.render(n, t);
  });
});
var mB = ve((Eh, gu) => {
  "use strict";
  p();
  var GR = 200,
    Jz = "Expected a function",
    CA = "__lodash_hash_undefined__",
    Pg = 1,
    yu = 2,
    kA = 1 / 0,
    KR = 9007199254740991,
    Tg = "[object Arguments]",
    bA = "[object Array]",
    qR = "[object Boolean]",
    QR = "[object Date]",
    JR = "[object Error]",
    YR = "[object Function]",
    Yz = "[object GeneratorFunction]",
    Rg = "[object Map]",
    ZR = "[object Number]",
    pu = "[object Object]",
    FR = "[object Promise]",
    XR = "[object RegExp]",
    Bg = "[object Set]",
    eB = "[object String]",
    tB = "[object Symbol]",
    AA = "[object WeakMap]",
    nB = "[object ArrayBuffer]",
    Dg = "[object DataView]",
    Zz = "[object Float32Array]",
    Xz = "[object Float64Array]",
    e9 = "[object Int8Array]",
    t9 = "[object Int16Array]",
    n9 = "[object Int32Array]",
    r9 = "[object Uint8Array]",
    i9 = "[object Uint8ClampedArray]",
    s9 = "[object Uint16Array]",
    o9 = "[object Uint32Array]",
    a9 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    c9 = /^\w*$/,
    u9 = /^\./,
    l9 =
      /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    h9 = /[\\^$.*+?()[\]{}|]/g,
    f9 = /\\(\\)?/g,
    d9 = /^\[object .+?Constructor\]$/,
    p9 = /^(?:0|[1-9]\d*)$/,
    gt = {};
  gt[Zz] =
    gt[Xz] =
    gt[e9] =
    gt[t9] =
    gt[n9] =
    gt[r9] =
    gt[i9] =
    gt[s9] =
    gt[o9] =
      !0;
  gt[Tg] =
    gt[bA] =
    gt[nB] =
    gt[qR] =
    gt[Dg] =
    gt[QR] =
    gt[JR] =
    gt[YR] =
    gt[Rg] =
    gt[ZR] =
    gt[pu] =
    gt[XR] =
    gt[Bg] =
    gt[eB] =
    gt[AA] =
      !1;
  var rB =
      typeof global == "object" && global && global.Object === Object && global,
    g9 = typeof self == "object" && self && self.Object === Object && self,
    Qs = rB || g9 || Function("return this")(),
    iB = typeof Eh == "object" && Eh && !Eh.nodeType && Eh,
    MR = iB && typeof gu == "object" && gu && !gu.nodeType && gu,
    m9 = MR && MR.exports === iB,
    UR = m9 && rB.process,
    zR = (function () {
      try {
        return UR && UR.binding("util");
      } catch {}
    })(),
    jR = zR && zR.isTypedArray;
  function y9(n, e) {
    var t = n ? n.length : 0;
    return !!t && E9(n, e, 0) > -1;
  }
  function w9(n, e, t) {
    for (var r = -1, i = n ? n.length : 0; ++r < i; ) if (t(e, n[r])) return !0;
    return !1;
  }
  function b9(n, e) {
    for (var t = -1, r = n ? n.length : 0; ++t < r; )
      if (e(n[t], t, n)) return !0;
    return !1;
  }
  function A9(n, e, t, r) {
    for (var i = n.length, s = t + (r ? 1 : -1); r ? s-- : ++s < i; )
      if (e(n[s], s, n)) return s;
    return -1;
  }
  function E9(n, e, t) {
    if (e !== e) return A9(n, x9, t);
    for (var r = t - 1, i = n.length; ++r < i; ) if (n[r] === e) return r;
    return -1;
  }
  function x9(n) {
    return n !== n;
  }
  function S9(n) {
    return function (e) {
      return e?.[n];
    };
  }
  function v9(n, e) {
    for (var t = -1, r = Array(n); ++t < n; ) r[t] = e(t);
    return r;
  }
  function I9(n) {
    return function (e) {
      return n(e);
    };
  }
  function C9(n, e) {
    return n.has(e);
  }
  function k9(n, e) {
    return n?.[e];
  }
  function EA(n) {
    var e = !1;
    if (n != null && typeof n.toString != "function")
      try {
        e = !!(n + "");
      } catch {}
    return e;
  }
  function T9(n) {
    var e = -1,
      t = Array(n.size);
    return (
      n.forEach(function (r, i) {
        t[++e] = [i, r];
      }),
      t
    );
  }
  function R9(n, e) {
    return function (t) {
      return n(e(t));
    };
  }
  function TA(n) {
    var e = -1,
      t = Array(n.size);
    return (
      n.forEach(function (r) {
        t[++e] = r;
      }),
      t
    );
  }
  var B9 = Array.prototype,
    D9 = Function.prototype,
    Lg = Object.prototype,
    yA = Qs["__core-js_shared__"],
    WR = (function () {
      var n = /[^.]+$/.exec((yA && yA.keys && yA.keys.IE_PROTO) || "");
      return n ? "Symbol(src)_1." + n : "";
    })(),
    sB = D9.toString,
    Yi = Lg.hasOwnProperty,
    wu = Lg.toString,
    _9 = RegExp(
      "^" +
        sB
          .call(Yi)
          .replace(h9, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?"
          ) +
        "$"
    ),
    HR = Qs.Symbol,
    VR = Qs.Uint8Array,
    P9 = Lg.propertyIsEnumerable,
    L9 = B9.splice,
    O9 = R9(Object.keys, Object),
    xA = bu(Qs, "DataView"),
    xh = bu(Qs, "Map"),
    SA = bu(Qs, "Promise"),
    mu = bu(Qs, "Set"),
    vA = bu(Qs, "WeakMap"),
    Sh = bu(Object, "create"),
    N9 = ha(xA),
    F9 = ha(xh),
    M9 = ha(SA),
    U9 = ha(mu),
    z9 = ha(vA),
    _g = HR ? HR.prototype : void 0,
    wA = _g ? _g.valueOf : void 0,
    $R = _g ? _g.toString : void 0;
  function ua(n) {
    var e = -1,
      t = n ? n.length : 0;
    for (this.clear(); ++e < t; ) {
      var r = n[e];
      this.set(r[0], r[1]);
    }
  }
  function j9() {
    this.__data__ = Sh ? Sh(null) : {};
  }
  function W9(n) {
    return this.has(n) && delete this.__data__[n];
  }
  function H9(n) {
    var e = this.__data__;
    if (Sh) {
      var t = e[n];
      return t === CA ? void 0 : t;
    }
    return Yi.call(e, n) ? e[n] : void 0;
  }
  function V9(n) {
    var e = this.__data__;
    return Sh ? e[n] !== void 0 : Yi.call(e, n);
  }
  function $9(n, e) {
    var t = this.__data__;
    return (t[n] = Sh && e === void 0 ? CA : e), this;
  }
  ua.prototype.clear = j9;
  ua.prototype.delete = W9;
  ua.prototype.get = H9;
  ua.prototype.has = V9;
  ua.prototype.set = $9;
  function Zi(n) {
    var e = -1,
      t = n ? n.length : 0;
    for (this.clear(); ++e < t; ) {
      var r = n[e];
      this.set(r[0], r[1]);
    }
  }
  function G9() {
    this.__data__ = [];
  }
  function K9(n) {
    var e = this.__data__,
      t = Og(e, n);
    if (t < 0) return !1;
    var r = e.length - 1;
    return t == r ? e.pop() : L9.call(e, t, 1), !0;
  }
  function q9(n) {
    var e = this.__data__,
      t = Og(e, n);
    return t < 0 ? void 0 : e[t][1];
  }
  function Q9(n) {
    return Og(this.__data__, n) > -1;
  }
  function J9(n, e) {
    var t = this.__data__,
      r = Og(t, n);
    return r < 0 ? t.push([n, e]) : (t[r][1] = e), this;
  }
  Zi.prototype.clear = G9;
  Zi.prototype.delete = K9;
  Zi.prototype.get = q9;
  Zi.prototype.has = Q9;
  Zi.prototype.set = J9;
  function Xi(n) {
    var e = -1,
      t = n ? n.length : 0;
    for (this.clear(); ++e < t; ) {
      var r = n[e];
      this.set(r[0], r[1]);
    }
  }
  function Y9() {
    this.__data__ = { hash: new ua(), map: new (xh || Zi)(), string: new ua() };
  }
  function Z9(n) {
    return Ng(this, n).delete(n);
  }
  function X9(n) {
    return Ng(this, n).get(n);
  }
  function ej(n) {
    return Ng(this, n).has(n);
  }
  function tj(n, e) {
    return Ng(this, n).set(n, e), this;
  }
  Xi.prototype.clear = Y9;
  Xi.prototype.delete = Z9;
  Xi.prototype.get = X9;
  Xi.prototype.has = ej;
  Xi.prototype.set = tj;
  function vh(n) {
    var e = -1,
      t = n ? n.length : 0;
    for (this.__data__ = new Xi(); ++e < t; ) this.add(n[e]);
  }
  function nj(n) {
    return this.__data__.set(n, CA), this;
  }
  function rj(n) {
    return this.__data__.has(n);
  }
  vh.prototype.add = vh.prototype.push = nj;
  vh.prototype.has = rj;
  function Ji(n) {
    this.__data__ = new Zi(n);
  }
  function ij() {
    this.__data__ = new Zi();
  }
  function sj(n) {
    return this.__data__.delete(n);
  }
  function oj(n) {
    return this.__data__.get(n);
  }
  function aj(n) {
    return this.__data__.has(n);
  }
  function cj(n, e) {
    var t = this.__data__;
    if (t instanceof Zi) {
      var r = t.__data__;
      if (!xh || r.length < GR - 1) return r.push([n, e]), this;
      t = this.__data__ = new Xi(r);
    }
    return t.set(n, e), this;
  }
  Ji.prototype.clear = ij;
  Ji.prototype.delete = sj;
  Ji.prototype.get = oj;
  Ji.prototype.has = aj;
  Ji.prototype.set = cj;
  function uj(n, e) {
    var t = la(n) || dB(n) ? v9(n.length, String) : [],
      r = t.length,
      i = !!r;
    for (var s in n)
      (e || Yi.call(n, s)) && !(i && (s == "length" || uB(s, r))) && t.push(s);
    return t;
  }
  function Og(n, e) {
    for (var t = n.length; t--; ) if (fB(n[t][0], e)) return t;
    return -1;
  }
  function oB(n, e) {
    e = Fg(e, n) ? [e] : aB(e);
    for (var t = 0, r = e.length; n != null && t < r; ) n = n[Mg(e[t++])];
    return t && t == r ? n : void 0;
  }
  function lj(n) {
    return wu.call(n);
  }
  function hj(n, e) {
    return n != null && e in Object(n);
  }
  function RA(n, e, t, r, i) {
    return n === e
      ? !0
      : n == null || e == null || (!Ug(n) && !zg(e))
      ? n !== n && e !== e
      : fj(n, e, RA, t, r, i);
  }
  function fj(n, e, t, r, i, s) {
    var o = la(n),
      a = la(e),
      c = bA,
      u = bA;
    o || ((c = qs(n)), (c = c == Tg ? pu : c)),
      a || ((u = qs(e)), (u = u == Tg ? pu : u));
    var l = c == pu && !EA(n),
      h = u == pu && !EA(e),
      f = c == u;
    if (f && !l)
      return (
        s || (s = new Ji()),
        o || Lj(n) ? cB(n, e, t, r, i, s) : vj(n, e, c, t, r, i, s)
      );
    if (!(i & yu)) {
      var g = l && Yi.call(n, "__wrapped__"),
        y = h && Yi.call(e, "__wrapped__");
      if (g || y) {
        var w = g ? n.value() : n,
          m = y ? e.value() : e;
        return s || (s = new Ji()), t(w, m, r, i, s);
      }
    }
    return f ? (s || (s = new Ji()), Ij(n, e, t, r, i, s)) : !1;
  }
  function dj(n, e, t, r) {
    var i = t.length,
      s = i,
      o = !r;
    if (n == null) return !s;
    for (n = Object(n); i--; ) {
      var a = t[i];
      if (o && a[2] ? a[1] !== n[a[0]] : !(a[0] in n)) return !1;
    }
    for (; ++i < s; ) {
      a = t[i];
      var c = a[0],
        u = n[c],
        l = a[1];
      if (o && a[2]) {
        if (u === void 0 && !(c in n)) return !1;
      } else {
        var h = new Ji();
        if (r) var f = r(u, l, c, n, e, h);
        if (!(f === void 0 ? RA(l, u, r, Pg | yu, h) : f)) return !1;
      }
    }
    return !0;
  }
  function pj(n) {
    if (!Ug(n) || Rj(n)) return !1;
    var e = gB(n) || EA(n) ? _9 : d9;
    return e.test(ha(n));
  }
  function gj(n) {
    return zg(n) && DA(n.length) && !!gt[wu.call(n)];
  }
  function mj(n) {
    return typeof n == "function"
      ? n
      : n == null
      ? Mj
      : typeof n == "object"
      ? la(n)
        ? bj(n[0], n[1])
        : wj(n)
      : zj(n);
  }
  function yj(n) {
    if (!Bj(n)) return O9(n);
    var e = [];
    for (var t in Object(n)) Yi.call(n, t) && t != "constructor" && e.push(t);
    return e;
  }
  function wj(n) {
    var e = Cj(n);
    return e.length == 1 && e[0][2]
      ? hB(e[0][0], e[0][1])
      : function (t) {
          return t === n || dj(t, n, e);
        };
  }
  function bj(n, e) {
    return Fg(n) && lB(e)
      ? hB(Mg(n), e)
      : function (t) {
          var r = Nj(t, n);
          return r === void 0 && r === e ? Fj(t, n) : RA(e, r, void 0, Pg | yu);
        };
  }
  function Aj(n) {
    return function (e) {
      return oB(e, n);
    };
  }
  function Ej(n) {
    if (typeof n == "string") return n;
    if (_A(n)) return $R ? $R.call(n) : "";
    var e = n + "";
    return e == "0" && 1 / n == -kA ? "-0" : e;
  }
  function xj(n, e, t) {
    var r = -1,
      i = y9,
      s = n.length,
      o = !0,
      a = [],
      c = a;
    if (t) (o = !1), (i = w9);
    else if (s >= GR) {
      var u = e ? null : Sj(n);
      if (u) return TA(u);
      (o = !1), (i = C9), (c = new vh());
    } else c = e ? [] : a;
    e: for (; ++r < s; ) {
      var l = n[r],
        h = e ? e(l) : l;
      if (((l = t || l !== 0 ? l : 0), o && h === h)) {
        for (var f = c.length; f--; ) if (c[f] === h) continue e;
        e && c.push(h), a.push(l);
      } else i(c, h, t) || (c !== a && c.push(h), a.push(l));
    }
    return a;
  }
  function aB(n) {
    return la(n) ? n : Dj(n);
  }
  var Sj =
    mu && 1 / TA(new mu([, -0]))[1] == kA
      ? function (n) {
          return new mu(n);
        }
      : Uj;
  function cB(n, e, t, r, i, s) {
    var o = i & yu,
      a = n.length,
      c = e.length;
    if (a != c && !(o && c > a)) return !1;
    var u = s.get(n);
    if (u && s.get(e)) return u == e;
    var l = -1,
      h = !0,
      f = i & Pg ? new vh() : void 0;
    for (s.set(n, e), s.set(e, n); ++l < a; ) {
      var g = n[l],
        y = e[l];
      if (r) var w = o ? r(y, g, l, e, n, s) : r(g, y, l, n, e, s);
      if (w !== void 0) {
        if (w) continue;
        h = !1;
        break;
      }
      if (f) {
        if (
          !b9(e, function (m, b) {
            if (!f.has(b) && (g === m || t(g, m, r, i, s))) return f.add(b);
          })
        ) {
          h = !1;
          break;
        }
      } else if (!(g === y || t(g, y, r, i, s))) {
        h = !1;
        break;
      }
    }
    return s.delete(n), s.delete(e), h;
  }
  function vj(n, e, t, r, i, s, o) {
    switch (t) {
      case Dg:
        if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset)
          return !1;
        (n = n.buffer), (e = e.buffer);
      case nB:
        return !(n.byteLength != e.byteLength || !r(new VR(n), new VR(e)));
      case qR:
      case QR:
      case ZR:
        return fB(+n, +e);
      case JR:
        return n.name == e.name && n.message == e.message;
      case XR:
      case eB:
        return n == e + "";
      case Rg:
        var a = T9;
      case Bg:
        var c = s & yu;
        if ((a || (a = TA), n.size != e.size && !c)) return !1;
        var u = o.get(n);
        if (u) return u == e;
        (s |= Pg), o.set(n, e);
        var l = cB(a(n), a(e), r, i, s, o);
        return o.delete(n), l;
      case tB:
        if (wA) return wA.call(n) == wA.call(e);
    }
    return !1;
  }
  function Ij(n, e, t, r, i, s) {
    var o = i & yu,
      a = IA(n),
      c = a.length,
      u = IA(e),
      l = u.length;
    if (c != l && !o) return !1;
    for (var h = c; h--; ) {
      var f = a[h];
      if (!(o ? f in e : Yi.call(e, f))) return !1;
    }
    var g = s.get(n);
    if (g && s.get(e)) return g == e;
    var y = !0;
    s.set(n, e), s.set(e, n);
    for (var w = o; ++h < c; ) {
      f = a[h];
      var m = n[f],
        b = e[f];
      if (r) var I = o ? r(b, m, f, e, n, s) : r(m, b, f, n, e, s);
      if (!(I === void 0 ? m === b || t(m, b, r, i, s) : I)) {
        y = !1;
        break;
      }
      w || (w = f == "constructor");
    }
    if (y && !w) {
      var E = n.constructor,
        T = e.constructor;
      E != T &&
        "constructor" in n &&
        "constructor" in e &&
        !(
          typeof E == "function" &&
          E instanceof E &&
          typeof T == "function" &&
          T instanceof T
        ) &&
        (y = !1);
    }
    return s.delete(n), s.delete(e), y;
  }
  function Ng(n, e) {
    var t = n.__data__;
    return Tj(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
  }
  function Cj(n) {
    for (var e = IA(n), t = e.length; t--; ) {
      var r = e[t],
        i = n[r];
      e[t] = [r, i, lB(i)];
    }
    return e;
  }
  function bu(n, e) {
    var t = k9(n, e);
    return pj(t) ? t : void 0;
  }
  var qs = lj;
  ((xA && qs(new xA(new ArrayBuffer(1))) != Dg) ||
    (xh && qs(new xh()) != Rg) ||
    (SA && qs(SA.resolve()) != FR) ||
    (mu && qs(new mu()) != Bg) ||
    (vA && qs(new vA()) != AA)) &&
    (qs = function (n) {
      var e = wu.call(n),
        t = e == pu ? n.constructor : void 0,
        r = t ? ha(t) : void 0;
      if (r)
        switch (r) {
          case N9:
            return Dg;
          case F9:
            return Rg;
          case M9:
            return FR;
          case U9:
            return Bg;
          case z9:
            return AA;
        }
      return e;
    });
  function kj(n, e, t) {
    e = Fg(e, n) ? [e] : aB(e);
    for (var r, i = -1, o = e.length; ++i < o; ) {
      var s = Mg(e[i]);
      if (!(r = n != null && t(n, s))) break;
      n = n[s];
    }
    if (r) return r;
    var o = n ? n.length : 0;
    return !!o && DA(o) && uB(s, o) && (la(n) || dB(n));
  }
  function uB(n, e) {
    return (
      (e = e ?? KR),
      !!e &&
        (typeof n == "number" || p9.test(n)) &&
        n > -1 &&
        n % 1 == 0 &&
        n < e
    );
  }
  function Fg(n, e) {
    if (la(n)) return !1;
    var t = typeof n;
    return t == "number" ||
      t == "symbol" ||
      t == "boolean" ||
      n == null ||
      _A(n)
      ? !0
      : c9.test(n) || !a9.test(n) || (e != null && n in Object(e));
  }
  function Tj(n) {
    var e = typeof n;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean"
      ? n !== "__proto__"
      : n === null;
  }
  function Rj(n) {
    return !!WR && WR in n;
  }
  function Bj(n) {
    var e = n && n.constructor,
      t = (typeof e == "function" && e.prototype) || Lg;
    return n === t;
  }
  function lB(n) {
    return n === n && !Ug(n);
  }
  function hB(n, e) {
    return function (t) {
      return t == null ? !1 : t[n] === e && (e !== void 0 || n in Object(t));
    };
  }
  var Dj = BA(function (n) {
    n = Oj(n);
    var e = [];
    return (
      u9.test(n) && e.push(""),
      n.replace(l9, function (t, r, i, s) {
        e.push(i ? s.replace(f9, "$1") : r || t);
      }),
      e
    );
  });
  function Mg(n) {
    if (typeof n == "string" || _A(n)) return n;
    var e = n + "";
    return e == "0" && 1 / n == -kA ? "-0" : e;
  }
  function ha(n) {
    if (n != null) {
      try {
        return sB.call(n);
      } catch {}
      try {
        return n + "";
      } catch {}
    }
    return "";
  }
  function _j(n, e) {
    return n && n.length ? xj(n, mj(e, 2)) : [];
  }
  function BA(n, e) {
    if (typeof n != "function" || (e && typeof e != "function"))
      throw new TypeError(Jz);
    var t = function () {
      var r = arguments,
        i = e ? e.apply(this, r) : r[0],
        s = t.cache;
      if (s.has(i)) return s.get(i);
      var o = n.apply(this, r);
      return (t.cache = s.set(i, o)), o;
    };
    return (t.cache = new (BA.Cache || Xi)()), t;
  }
  BA.Cache = Xi;
  function fB(n, e) {
    return n === e || (n !== n && e !== e);
  }
  function dB(n) {
    return (
      Pj(n) &&
      Yi.call(n, "callee") &&
      (!P9.call(n, "callee") || wu.call(n) == Tg)
    );
  }
  var la = Array.isArray;
  function pB(n) {
    return n != null && DA(n.length) && !gB(n);
  }
  function Pj(n) {
    return zg(n) && pB(n);
  }
  function gB(n) {
    var e = Ug(n) ? wu.call(n) : "";
    return e == YR || e == Yz;
  }
  function DA(n) {
    return typeof n == "number" && n > -1 && n % 1 == 0 && n <= KR;
  }
  function Ug(n) {
    var e = typeof n;
    return !!n && (e == "object" || e == "function");
  }
  function zg(n) {
    return !!n && typeof n == "object";
  }
  function _A(n) {
    return typeof n == "symbol" || (zg(n) && wu.call(n) == tB);
  }
  var Lj = jR ? I9(jR) : gj;
  function Oj(n) {
    return n == null ? "" : Ej(n);
  }
  function Nj(n, e, t) {
    var r = n == null ? void 0 : oB(n, e);
    return r === void 0 ? t : r;
  }
  function Fj(n, e) {
    return n != null && kj(n, e, hj);
  }
  function IA(n) {
    return pB(n) ? uj(n) : yj(n);
  }
  function Mj(n) {
    return n;
  }
  function Uj() {}
  function zj(n) {
    return Fg(n) ? S9(Mg(n)) : Aj(n);
  }
  gu.exports = _j;
});
p();
var e1 = null;
function Aa() {
  return e1;
}
function t1(n) {
  e1 ??= n;
}
var Vh = class {};
var Vt = new Ae(""),
  Em = (() => {
    class n {
      historyGo(t) {
        throw new Error("");
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({
          token: n,
          factory: () => M(qB),
          providedIn: "platform",
        });
      }
    }
    return n;
  })(),
  n1 = new Ae(""),
  qB = (() => {
    class n extends Em {
      constructor() {
        super(),
          (this._doc = M(Vt)),
          (this._location = window.location),
          (this._history = window.history);
      }
      getBaseHrefFromDOM() {
        return Aa().getBaseHref(this._doc);
      }
      onPopState(t) {
        let r = Aa().getGlobalEventTarget(this._doc, "window");
        return (
          r.addEventListener("popstate", t, !1),
          () => r.removeEventListener("popstate", t)
        );
      }
      onHashChange(t) {
        let r = Aa().getGlobalEventTarget(this._doc, "window");
        return (
          r.addEventListener("hashchange", t, !1),
          () => r.removeEventListener("hashchange", t)
        );
      }
      get href() {
        return this._location.href;
      }
      get protocol() {
        return this._location.protocol;
      }
      get hostname() {
        return this._location.hostname;
      }
      get port() {
        return this._location.port;
      }
      get pathname() {
        return this._location.pathname;
      }
      get search() {
        return this._location.search;
      }
      get hash() {
        return this._location.hash;
      }
      set pathname(t) {
        this._location.pathname = t;
      }
      pushState(t, r, i) {
        this._history.pushState(t, r, i);
      }
      replaceState(t, r, i) {
        this._history.replaceState(t, r, i);
      }
      forward() {
        this._history.forward();
      }
      back() {
        this._history.back();
      }
      historyGo(t = 0) {
        this._history.go(t);
      }
      getState() {
        return this._history.state;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({
          token: n,
          factory: () => new n(),
          providedIn: "platform",
        });
      }
    }
    return n;
  })();
function xm(n, e) {
  if (n.length == 0) return e;
  if (e.length == 0) return n;
  let t = 0;
  return (
    n.endsWith("/") && t++,
    e.startsWith("/") && t++,
    t == 2 ? n + e.substring(1) : t == 1 ? n + e : n + "/" + e
  );
}
function $E(n) {
  let e = n.match(/#|\?|$/),
    t = (e && e.index) || n.length,
    r = t - (n[t - 1] === "/" ? 1 : 0);
  return n.slice(0, r) + n.slice(t);
}
function Ai(n) {
  return n && n[0] !== "?" ? "?" + n : n;
}
var Ei = (() => {
    class n {
      historyGo(t) {
        throw new Error("");
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: () => M(Sm), providedIn: "root" });
      }
    }
    return n;
  })(),
  r1 = new Ae(""),
  Sm = (() => {
    class n extends Ei {
      constructor(t, r) {
        super(),
          (this._platformLocation = t),
          (this._removeListenerFns = []),
          (this._baseHref =
            r ??
            this._platformLocation.getBaseHrefFromDOM() ??
            M(Vt).location?.origin ??
            "");
      }
      ngOnDestroy() {
        for (; this._removeListenerFns.length; )
          this._removeListenerFns.pop()();
      }
      onPopState(t) {
        this._removeListenerFns.push(
          this._platformLocation.onPopState(t),
          this._platformLocation.onHashChange(t)
        );
      }
      getBaseHref() {
        return this._baseHref;
      }
      prepareExternalUrl(t) {
        return xm(this._baseHref, t);
      }
      path(t = !1) {
        let r =
            this._platformLocation.pathname + Ai(this._platformLocation.search),
          i = this._platformLocation.hash;
        return i && t ? `${r}${i}` : r;
      }
      pushState(t, r, i, s) {
        let o = this.prepareExternalUrl(i + Ai(s));
        this._platformLocation.pushState(t, r, o);
      }
      replaceState(t, r, i, s) {
        let o = this.prepareExternalUrl(i + Ai(s));
        this._platformLocation.replaceState(t, r, o);
      }
      forward() {
        this._platformLocation.forward();
      }
      back() {
        this._platformLocation.back();
      }
      getState() {
        return this._platformLocation.getState();
      }
      historyGo(t = 0) {
        this._platformLocation.historyGo?.(t);
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Em), le(r1, 8));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })(),
  i1 = (() => {
    class n extends Ei {
      constructor(t, r) {
        super(),
          (this._platformLocation = t),
          (this._baseHref = ""),
          (this._removeListenerFns = []),
          r != null && (this._baseHref = r);
      }
      ngOnDestroy() {
        for (; this._removeListenerFns.length; )
          this._removeListenerFns.pop()();
      }
      onPopState(t) {
        this._removeListenerFns.push(
          this._platformLocation.onPopState(t),
          this._platformLocation.onHashChange(t)
        );
      }
      getBaseHref() {
        return this._baseHref;
      }
      path(t = !1) {
        let r = this._platformLocation.hash ?? "#";
        return r.length > 0 ? r.substring(1) : r;
      }
      prepareExternalUrl(t) {
        let r = xm(this._baseHref, t);
        return r.length > 0 ? "#" + r : r;
      }
      pushState(t, r, i, s) {
        let o = this.prepareExternalUrl(i + Ai(s));
        o.length == 0 && (o = this._platformLocation.pathname),
          this._platformLocation.pushState(t, r, o);
      }
      replaceState(t, r, i, s) {
        let o = this.prepareExternalUrl(i + Ai(s));
        o.length == 0 && (o = this._platformLocation.pathname),
          this._platformLocation.replaceState(t, r, o);
      }
      forward() {
        this._platformLocation.forward();
      }
      back() {
        this._platformLocation.back();
      }
      getState() {
        return this._platformLocation.getState();
      }
      historyGo(t = 0) {
        this._platformLocation.historyGo?.(t);
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Em), le(r1, 8));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })(),
  xa = (() => {
    class n {
      constructor(t) {
        (this._subject = new to()),
          (this._urlChangeListeners = []),
          (this._urlChangeSubscription = null),
          (this._locationStrategy = t);
        let r = this._locationStrategy.getBaseHref();
        (this._basePath = YB($E(GE(r)))),
          this._locationStrategy.onPopState((i) => {
            this._subject.emit({
              url: this.path(!0),
              pop: !0,
              state: i.state,
              type: i.type,
            });
          });
      }
      ngOnDestroy() {
        this._urlChangeSubscription?.unsubscribe(),
          (this._urlChangeListeners = []);
      }
      path(t = !1) {
        return this.normalize(this._locationStrategy.path(t));
      }
      getState() {
        return this._locationStrategy.getState();
      }
      isCurrentPathEqualTo(t, r = "") {
        return this.path() == this.normalize(t + Ai(r));
      }
      normalize(t) {
        return n.stripTrailingSlash(JB(this._basePath, GE(t)));
      }
      prepareExternalUrl(t) {
        return (
          t && t[0] !== "/" && (t = "/" + t),
          this._locationStrategy.prepareExternalUrl(t)
        );
      }
      go(t, r = "", i = null) {
        this._locationStrategy.pushState(i, "", t, r),
          this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Ai(r)), i);
      }
      replaceState(t, r = "", i = null) {
        this._locationStrategy.replaceState(i, "", t, r),
          this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Ai(r)), i);
      }
      forward() {
        this._locationStrategy.forward();
      }
      back() {
        this._locationStrategy.back();
      }
      historyGo(t = 0) {
        this._locationStrategy.historyGo?.(t);
      }
      onUrlChange(t) {
        return (
          this._urlChangeListeners.push(t),
          (this._urlChangeSubscription ??= this.subscribe((r) => {
            this._notifyUrlChangeListeners(r.url, r.state);
          })),
          () => {
            let r = this._urlChangeListeners.indexOf(t);
            this._urlChangeListeners.splice(r, 1),
              this._urlChangeListeners.length === 0 &&
                (this._urlChangeSubscription?.unsubscribe(),
                (this._urlChangeSubscription = null));
          }
        );
      }
      _notifyUrlChangeListeners(t = "", r) {
        this._urlChangeListeners.forEach((i) => i(t, r));
      }
      subscribe(t, r, i) {
        return this._subject.subscribe({ next: t, error: r, complete: i });
      }
      static {
        this.normalizeQueryParams = Ai;
      }
      static {
        this.joinWithSlash = xm;
      }
      static {
        this.stripTrailingSlash = $E;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Ei));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: () => QB(), providedIn: "root" });
      }
    }
    return n;
  })();
function QB() {
  return new xa(le(Ei));
}
function JB(n, e) {
  if (!n || !e.startsWith(n)) return e;
  let t = e.substring(n.length);
  return t === "" || ["/", ";", "?", "#"].includes(t[0]) ? t : e;
}
function GE(n) {
  return n.replace(/\/index.html$/, "");
}
function YB(n) {
  if (new RegExp("^(https?:)?//").test(n)) {
    let [, t] = n.split(/\/\/[^\/]+/);
    return t;
  }
  return n;
}
var s1 = {
    ADP: [void 0, void 0, 0],
    AFN: [void 0, "\u060B", 0],
    ALL: [void 0, void 0, 0],
    AMD: [void 0, "\u058F", 2],
    AOA: [void 0, "Kz"],
    ARS: [void 0, "$"],
    AUD: ["A$", "$"],
    AZN: [void 0, "\u20BC"],
    BAM: [void 0, "KM"],
    BBD: [void 0, "$"],
    BDT: [void 0, "\u09F3"],
    BHD: [void 0, void 0, 3],
    BIF: [void 0, void 0, 0],
    BMD: [void 0, "$"],
    BND: [void 0, "$"],
    BOB: [void 0, "Bs"],
    BRL: ["R$"],
    BSD: [void 0, "$"],
    BWP: [void 0, "P"],
    BYN: [void 0, void 0, 2],
    BYR: [void 0, void 0, 0],
    BZD: [void 0, "$"],
    CAD: ["CA$", "$", 2],
    CHF: [void 0, void 0, 2],
    CLF: [void 0, void 0, 4],
    CLP: [void 0, "$", 0],
    CNY: ["CN\xA5", "\xA5"],
    COP: [void 0, "$", 2],
    CRC: [void 0, "\u20A1", 2],
    CUC: [void 0, "$"],
    CUP: [void 0, "$"],
    CZK: [void 0, "K\u010D", 2],
    DJF: [void 0, void 0, 0],
    DKK: [void 0, "kr", 2],
    DOP: [void 0, "$"],
    EGP: [void 0, "E\xA3"],
    ESP: [void 0, "\u20A7", 0],
    EUR: ["\u20AC"],
    FJD: [void 0, "$"],
    FKP: [void 0, "\xA3"],
    GBP: ["\xA3"],
    GEL: [void 0, "\u20BE"],
    GHS: [void 0, "GH\u20B5"],
    GIP: [void 0, "\xA3"],
    GNF: [void 0, "FG", 0],
    GTQ: [void 0, "Q"],
    GYD: [void 0, "$", 2],
    HKD: ["HK$", "$"],
    HNL: [void 0, "L"],
    HRK: [void 0, "kn"],
    HUF: [void 0, "Ft", 2],
    IDR: [void 0, "Rp", 2],
    ILS: ["\u20AA"],
    INR: ["\u20B9"],
    IQD: [void 0, void 0, 0],
    IRR: [void 0, void 0, 0],
    ISK: [void 0, "kr", 0],
    ITL: [void 0, void 0, 0],
    JMD: [void 0, "$"],
    JOD: [void 0, void 0, 3],
    JPY: ["\xA5", void 0, 0],
    KHR: [void 0, "\u17DB"],
    KMF: [void 0, "CF", 0],
    KPW: [void 0, "\u20A9", 0],
    KRW: ["\u20A9", void 0, 0],
    KWD: [void 0, void 0, 3],
    KYD: [void 0, "$"],
    KZT: [void 0, "\u20B8"],
    LAK: [void 0, "\u20AD", 0],
    LBP: [void 0, "L\xA3", 0],
    LKR: [void 0, "Rs"],
    LRD: [void 0, "$"],
    LTL: [void 0, "Lt"],
    LUF: [void 0, void 0, 0],
    LVL: [void 0, "Ls"],
    LYD: [void 0, void 0, 3],
    MGA: [void 0, "Ar", 0],
    MGF: [void 0, void 0, 0],
    MMK: [void 0, "K", 0],
    MNT: [void 0, "\u20AE", 2],
    MRO: [void 0, void 0, 0],
    MUR: [void 0, "Rs", 2],
    MXN: ["MX$", "$"],
    MYR: [void 0, "RM"],
    NAD: [void 0, "$"],
    NGN: [void 0, "\u20A6"],
    NIO: [void 0, "C$"],
    NOK: [void 0, "kr", 2],
    NPR: [void 0, "Rs"],
    NZD: ["NZ$", "$"],
    OMR: [void 0, void 0, 3],
    PHP: ["\u20B1"],
    PKR: [void 0, "Rs", 2],
    PLN: [void 0, "z\u0142"],
    PYG: [void 0, "\u20B2", 0],
    RON: [void 0, "lei"],
    RSD: [void 0, void 0, 0],
    RUB: [void 0, "\u20BD"],
    RWF: [void 0, "RF", 0],
    SBD: [void 0, "$"],
    SEK: [void 0, "kr", 2],
    SGD: [void 0, "$"],
    SHP: [void 0, "\xA3"],
    SLE: [void 0, void 0, 2],
    SLL: [void 0, void 0, 0],
    SOS: [void 0, void 0, 0],
    SRD: [void 0, "$"],
    SSP: [void 0, "\xA3"],
    STD: [void 0, void 0, 0],
    STN: [void 0, "Db"],
    SYP: [void 0, "\xA3", 0],
    THB: [void 0, "\u0E3F"],
    TMM: [void 0, void 0, 0],
    TND: [void 0, void 0, 3],
    TOP: [void 0, "T$"],
    TRL: [void 0, void 0, 0],
    TRY: [void 0, "\u20BA"],
    TTD: [void 0, "$"],
    TWD: ["NT$", "$", 2],
    TZS: [void 0, void 0, 2],
    UAH: [void 0, "\u20B4"],
    UGX: [void 0, void 0, 0],
    USD: ["$"],
    UYI: [void 0, void 0, 0],
    UYU: [void 0, "$"],
    UYW: [void 0, void 0, 4],
    UZS: [void 0, void 0, 2],
    VEF: [void 0, "Bs", 2],
    VND: ["\u20AB", void 0, 0],
    VUV: [void 0, void 0, 0],
    XAF: ["FCFA", void 0, 0],
    XCD: ["EC$", "$"],
    XOF: ["F\u202FCFA", void 0, 0],
    XPF: ["CFPF", void 0, 0],
    XXX: ["\xA4"],
    YER: [void 0, void 0, 0],
    ZAR: [void 0, "R"],
    ZMK: [void 0, void 0, 0],
    ZMW: [void 0, "ZK"],
    ZWD: [void 0, void 0, 0],
  },
  Gh = (function (n) {
    return (
      (n[(n.Decimal = 0)] = "Decimal"),
      (n[(n.Percent = 1)] = "Percent"),
      (n[(n.Currency = 2)] = "Currency"),
      (n[(n.Scientific = 3)] = "Scientific"),
      n
    );
  })(Gh || {});
var gn = {
  Decimal: 0,
  Group: 1,
  List: 2,
  PercentSign: 3,
  PlusSign: 4,
  MinusSign: 5,
  Exponential: 6,
  SuperscriptingExponent: 7,
  PerMille: 8,
  Infinity: 9,
  NaN: 10,
  TimeSeparator: 11,
  CurrencyDecimal: 12,
  CurrencyGroup: 13,
};
function is(n, e) {
  let t = Lh(n),
    r = t[wa.NumberSymbols][e];
  if (typeof r > "u") {
    if (e === gn.CurrencyDecimal) return t[wa.NumberSymbols][gn.Decimal];
    if (e === gn.CurrencyGroup) return t[wa.NumberSymbols][gn.Group];
  }
  return r;
}
function vm(n, e) {
  return Lh(n)[wa.NumberFormats][e];
}
function ZB(n) {
  return Lh(n)[wa.Currencies];
}
function XB(n, e, t = "en") {
  let r = ZB(t)[n] || s1[n] || [],
    i = r[1];
  return e === "narrow" && typeof i == "string" ? i : r[0] || n;
}
var eD = 2;
function tD(n) {
  let e,
    t = s1[n];
  return t && (e = t[2]), typeof e == "number" ? e : eD;
}
var nD = /^(\d+)?\.((\d+)(-(\d+))?)?$/,
  KE = 22,
  $h = ".",
  Ru = "0",
  rD = ";",
  iD = ",",
  fm = "#",
  qE = "\xA4",
  sD = "%";
function Im(n, e, t, r, i, s, o = !1) {
  let a = "",
    c = !1;
  if (!isFinite(n)) a = is(t, gn.Infinity);
  else {
    let u = lD(n);
    o && (u = uD(u));
    let l = e.minInt,
      h = e.minFrac,
      f = e.maxFrac;
    if (s) {
      let I = s.match(nD);
      if (I === null) throw new Error(`${s} is not a valid digit info`);
      let E = I[1],
        T = I[3],
        B = I[5];
      E != null && (l = dm(E)),
        T != null && (h = dm(T)),
        B != null ? (f = dm(B)) : T != null && h > f && (f = h);
    }
    hD(u, h, f);
    let g = u.digits,
      y = u.integerLen,
      w = u.exponent,
      m = [];
    for (c = g.every((I) => !I); y < l; y++) g.unshift(0);
    for (; y < 0; y++) g.unshift(0);
    y > 0 ? (m = g.splice(y, g.length)) : ((m = g), (g = [0]));
    let b = [];
    for (
      g.length >= e.lgSize && b.unshift(g.splice(-e.lgSize, g.length).join(""));
      g.length > e.gSize;

    )
      b.unshift(g.splice(-e.gSize, g.length).join(""));
    g.length && b.unshift(g.join("")),
      (a = b.join(is(t, r))),
      m.length && (a += is(t, i) + m.join("")),
      w && (a += is(t, gn.Exponential) + "+" + w);
  }
  return (
    n < 0 && !c ? (a = e.negPre + a + e.negSuf) : (a = e.posPre + a + e.posSuf),
    a
  );
}
function oD(n, e, t, r, i) {
  let s = vm(e, Gh.Currency),
    o = Cm(s, is(e, gn.MinusSign));
  return (
    (o.minFrac = tD(r)),
    (o.maxFrac = o.minFrac),
    Im(n, o, e, gn.CurrencyGroup, gn.CurrencyDecimal, i)
      .replace(qE, t)
      .replace(qE, "")
      .trim()
  );
}
function aD(n, e, t) {
  let r = vm(e, Gh.Percent),
    i = Cm(r, is(e, gn.MinusSign));
  return Im(n, i, e, gn.Group, gn.Decimal, t, !0).replace(
    new RegExp(sD, "g"),
    is(e, gn.PercentSign)
  );
}
function cD(n, e, t) {
  let r = vm(e, Gh.Decimal),
    i = Cm(r, is(e, gn.MinusSign));
  return Im(n, i, e, gn.Group, gn.Decimal, t);
}
function Cm(n, e = "-") {
  let t = {
      minInt: 1,
      minFrac: 0,
      maxFrac: 0,
      posPre: "",
      posSuf: "",
      negPre: "",
      negSuf: "",
      gSize: 0,
      lgSize: 0,
    },
    r = n.split(rD),
    i = r[0],
    s = r[1],
    o =
      i.indexOf($h) !== -1
        ? i.split($h)
        : [
            i.substring(0, i.lastIndexOf(Ru) + 1),
            i.substring(i.lastIndexOf(Ru) + 1),
          ],
    a = o[0],
    c = o[1] || "";
  t.posPre = a.substring(0, a.indexOf(fm));
  for (let l = 0; l < c.length; l++) {
    let h = c.charAt(l);
    h === Ru
      ? (t.minFrac = t.maxFrac = l + 1)
      : h === fm
      ? (t.maxFrac = l + 1)
      : (t.posSuf += h);
  }
  let u = a.split(iD);
  if (
    ((t.gSize = u[1] ? u[1].length : 0),
    (t.lgSize = u[2] || u[1] ? (u[2] || u[1]).length : 0),
    s)
  ) {
    let l = i.length - t.posPre.length - t.posSuf.length,
      h = s.indexOf(fm);
    (t.negPre = s.substring(0, h).replace(/'/g, "")),
      (t.negSuf = s.slice(h + l).replace(/'/g, ""));
  } else (t.negPre = e + t.posPre), (t.negSuf = t.posSuf);
  return t;
}
function uD(n) {
  if (n.digits[0] === 0) return n;
  let e = n.digits.length - n.integerLen;
  return (
    n.exponent
      ? (n.exponent += 2)
      : (e === 0 ? n.digits.push(0, 0) : e === 1 && n.digits.push(0),
        (n.integerLen += 2)),
    n
  );
}
function lD(n) {
  let e = Math.abs(n) + "",
    t = 0,
    r,
    i,
    s,
    o,
    a;
  for (
    (i = e.indexOf($h)) > -1 && (e = e.replace($h, "")),
      (s = e.search(/e/i)) > 0
        ? (i < 0 && (i = s), (i += +e.slice(s + 1)), (e = e.substring(0, s)))
        : i < 0 && (i = e.length),
      s = 0;
    e.charAt(s) === Ru;
    s++
  );
  if (s === (a = e.length)) (r = [0]), (i = 1);
  else {
    for (a--; e.charAt(a) === Ru; ) a--;
    for (i -= s, r = [], o = 0; s <= a; s++, o++) r[o] = Number(e.charAt(s));
  }
  return (
    i > KE && ((r = r.splice(0, KE - 1)), (t = i - 1), (i = 1)),
    { digits: r, exponent: t, integerLen: i }
  );
}
function hD(n, e, t) {
  if (e > t)
    throw new Error(
      `The minimum number of digits after fraction (${e}) is higher than the maximum (${t}).`
    );
  let r = n.digits,
    i = r.length - n.integerLen,
    s = Math.min(Math.max(e, i), t),
    o = s + n.integerLen,
    a = r[o];
  if (o > 0) {
    r.splice(Math.max(n.integerLen, o));
    for (let h = o; h < r.length; h++) r[h] = 0;
  } else {
    (i = Math.max(0, i)),
      (n.integerLen = 1),
      (r.length = Math.max(1, (o = s + 1))),
      (r[0] = 0);
    for (let h = 1; h < o; h++) r[h] = 0;
  }
  if (a >= 5)
    if (o - 1 < 0) {
      for (let h = 0; h > o; h--) r.unshift(0), n.integerLen++;
      r.unshift(1), n.integerLen++;
    } else r[o - 1]++;
  for (; i < Math.max(0, s); i++) r.push(0);
  let c = s !== 0,
    u = e + n.integerLen,
    l = r.reduceRight(function (h, f, g, y) {
      return (
        (f = f + h),
        (y[g] = f < 10 ? f : f - 10),
        c && (y[g] === 0 && g >= u ? y.pop() : (c = !1)),
        f >= 10 ? 1 : 0
      );
    }, 0);
  l && (r.unshift(l), n.integerLen++);
}
function dm(n) {
  let e = parseInt(n);
  if (isNaN(e)) throw new Error("Invalid integer literal when parsing " + n);
  return e;
}
function Kh(n, e) {
  e = encodeURIComponent(e);
  for (let t of n.split(";")) {
    let r = t.indexOf("="),
      [i, s] = r == -1 ? [t, ""] : [t.slice(0, r), t.slice(r + 1)];
    if (i.trim() === e) return decodeURIComponent(s);
  }
  return null;
}
var pm = /\s+/,
  QE = [],
  IW = (() => {
    class n {
      constructor(t, r) {
        (this._ngEl = t),
          (this._renderer = r),
          (this.initialClasses = QE),
          (this.stateMap = new Map());
      }
      set klass(t) {
        this.initialClasses = t != null ? t.trim().split(pm) : QE;
      }
      set ngClass(t) {
        this.rawClass = typeof t == "string" ? t.trim().split(pm) : t;
      }
      ngDoCheck() {
        for (let r of this.initialClasses) this._updateState(r, !0);
        let t = this.rawClass;
        if (Array.isArray(t) || t instanceof Set)
          for (let r of t) this._updateState(r, !0);
        else if (t != null)
          for (let r of Object.keys(t)) this._updateState(r, !!t[r]);
        this._applyStateDiff();
      }
      _updateState(t, r) {
        let i = this.stateMap.get(t);
        i !== void 0
          ? (i.enabled !== r && ((i.changed = !0), (i.enabled = r)),
            (i.touched = !0))
          : this.stateMap.set(t, { enabled: r, changed: !0, touched: !0 });
      }
      _applyStateDiff() {
        for (let t of this.stateMap) {
          let r = t[0],
            i = t[1];
          i.changed
            ? (this._toggleClass(r, i.enabled), (i.changed = !1))
            : i.touched ||
              (i.enabled && this._toggleClass(r, !1), this.stateMap.delete(r)),
            (i.touched = !1);
        }
      }
      _toggleClass(t, r) {
        (t = t.trim()),
          t.length > 0 &&
            t.split(pm).forEach((i) => {
              r
                ? this._renderer.addClass(this._ngEl.nativeElement, i)
                : this._renderer.removeClass(this._ngEl.nativeElement, i);
            });
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(mt(mi), mt(yi));
        };
      }
      static {
        this.ɵdir = sr({
          type: n,
          selectors: [["", "ngClass", ""]],
          inputs: { klass: [0, "class", "klass"], ngClass: "ngClass" },
          standalone: !0,
        });
      }
    }
    return n;
  })();
var gm = class {
    constructor(e, t, r, i) {
      (this.$implicit = e),
        (this.ngForOf = t),
        (this.index = r),
        (this.count = i);
    }
    get first() {
      return this.index === 0;
    }
    get last() {
      return this.index === this.count - 1;
    }
    get even() {
      return this.index % 2 === 0;
    }
    get odd() {
      return !this.even;
    }
  },
  CW = (() => {
    class n {
      set ngForOf(t) {
        (this._ngForOf = t), (this._ngForOfDirty = !0);
      }
      set ngForTrackBy(t) {
        this._trackByFn = t;
      }
      get ngForTrackBy() {
        return this._trackByFn;
      }
      constructor(t, r, i) {
        (this._viewContainer = t),
          (this._template = r),
          (this._differs = i),
          (this._ngForOf = null),
          (this._ngForOfDirty = !0),
          (this._differ = null);
      }
      set ngForTemplate(t) {
        t && (this._template = t);
      }
      ngDoCheck() {
        if (this._ngForOfDirty) {
          this._ngForOfDirty = !1;
          let t = this._ngForOf;
          if (!this._differ && t)
            if (0)
              try {
              } catch {}
            else this._differ = this._differs.find(t).create(this.ngForTrackBy);
        }
        if (this._differ) {
          let t = this._differ.diff(this._ngForOf);
          t && this._applyChanges(t);
        }
      }
      _applyChanges(t) {
        let r = this._viewContainer;
        t.forEachOperation((i, s, o) => {
          if (i.previousIndex == null)
            r.createEmbeddedView(
              this._template,
              new gm(i.item, this._ngForOf, -1, -1),
              o === null ? void 0 : o
            );
          else if (o == null) r.remove(s === null ? void 0 : s);
          else if (s !== null) {
            let a = r.get(s);
            r.move(a, o), JE(a, i);
          }
        });
        for (let i = 0, s = r.length; i < s; i++) {
          let a = r.get(i).context;
          (a.index = i), (a.count = s), (a.ngForOf = this._ngForOf);
        }
        t.forEachIdentityChange((i) => {
          let s = r.get(i.currentIndex);
          JE(s, i);
        });
      }
      static ngTemplateContextGuard(t, r) {
        return !0;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(mt(ns), mt(ma), mt(_E));
        };
      }
      static {
        this.ɵdir = sr({
          type: n,
          selectors: [["", "ngFor", "", "ngForOf", ""]],
          inputs: {
            ngForOf: "ngForOf",
            ngForTrackBy: "ngForTrackBy",
            ngForTemplate: "ngForTemplate",
          },
          standalone: !0,
        });
      }
    }
    return n;
  })();
function JE(n, e) {
  n.context.$implicit = e.item;
}
var kW = (() => {
    class n {
      constructor(t, r) {
        (this._viewContainer = t),
          (this._context = new mm()),
          (this._thenTemplateRef = null),
          (this._elseTemplateRef = null),
          (this._thenViewRef = null),
          (this._elseViewRef = null),
          (this._thenTemplateRef = r);
      }
      set ngIf(t) {
        (this._context.$implicit = this._context.ngIf = t), this._updateView();
      }
      set ngIfThen(t) {
        YE("ngIfThen", t),
          (this._thenTemplateRef = t),
          (this._thenViewRef = null),
          this._updateView();
      }
      set ngIfElse(t) {
        YE("ngIfElse", t),
          (this._elseTemplateRef = t),
          (this._elseViewRef = null),
          this._updateView();
      }
      _updateView() {
        this._context.$implicit
          ? this._thenViewRef ||
            (this._viewContainer.clear(),
            (this._elseViewRef = null),
            this._thenTemplateRef &&
              (this._thenViewRef = this._viewContainer.createEmbeddedView(
                this._thenTemplateRef,
                this._context
              )))
          : this._elseViewRef ||
            (this._viewContainer.clear(),
            (this._thenViewRef = null),
            this._elseTemplateRef &&
              (this._elseViewRef = this._viewContainer.createEmbeddedView(
                this._elseTemplateRef,
                this._context
              )));
      }
      static ngTemplateContextGuard(t, r) {
        return !0;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(mt(ns), mt(ma));
        };
      }
      static {
        this.ɵdir = sr({
          type: n,
          selectors: [["", "ngIf", ""]],
          inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" },
          standalone: !0,
        });
      }
    }
    return n;
  })(),
  mm = class {
    constructor() {
      (this.$implicit = null), (this.ngIf = null);
    }
  };
function YE(n, e) {
  if (!!!(!e || e.createEmbeddedView))
    throw new Error(`${n} must be a TemplateRef, but received '${eE(e)}'.`);
}
var TW = (() => {
    class n {
      constructor(t, r, i) {
        (this._ngEl = t),
          (this._differs = r),
          (this._renderer = i),
          (this._ngStyle = null),
          (this._differ = null);
      }
      set ngStyle(t) {
        (this._ngStyle = t),
          !this._differ && t && (this._differ = this._differs.find(t).create());
      }
      ngDoCheck() {
        if (this._differ) {
          let t = this._differ.diff(this._ngStyle);
          t && this._applyChanges(t);
        }
      }
      _setStyle(t, r) {
        let [i, s] = t.split("."),
          o = i.indexOf("-") === -1 ? void 0 : ro.DashCase;
        r != null
          ? this._renderer.setStyle(
              this._ngEl.nativeElement,
              i,
              s ? `${r}${s}` : r,
              o
            )
          : this._renderer.removeStyle(this._ngEl.nativeElement, i, o);
      }
      _applyChanges(t) {
        t.forEachRemovedItem((r) => this._setStyle(r.key, null)),
          t.forEachAddedItem((r) => this._setStyle(r.key, r.currentValue)),
          t.forEachChangedItem((r) => this._setStyle(r.key, r.currentValue));
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(mt(mi), mt(PE), mt(yi));
        };
      }
      static {
        this.ɵdir = sr({
          type: n,
          selectors: [["", "ngStyle", ""]],
          inputs: { ngStyle: "ngStyle" },
          standalone: !0,
        });
      }
    }
    return n;
  })(),
  RW = (() => {
    class n {
      constructor(t) {
        (this._viewContainerRef = t),
          (this._viewRef = null),
          (this.ngTemplateOutletContext = null),
          (this.ngTemplateOutlet = null),
          (this.ngTemplateOutletInjector = null);
      }
      ngOnChanges(t) {
        if (this._shouldRecreateView(t)) {
          let r = this._viewContainerRef;
          if (
            (this._viewRef && r.remove(r.indexOf(this._viewRef)),
            !this.ngTemplateOutlet)
          ) {
            this._viewRef = null;
            return;
          }
          let i = this._createContextForwardProxy();
          this._viewRef = r.createEmbeddedView(this.ngTemplateOutlet, i, {
            injector: this.ngTemplateOutletInjector ?? void 0,
          });
        }
      }
      _shouldRecreateView(t) {
        return !!t.ngTemplateOutlet || !!t.ngTemplateOutletInjector;
      }
      _createContextForwardProxy() {
        return new Proxy(
          {},
          {
            set: (t, r, i) =>
              this.ngTemplateOutletContext
                ? Reflect.set(this.ngTemplateOutletContext, r, i)
                : !1,
            get: (t, r, i) => {
              if (this.ngTemplateOutletContext)
                return Reflect.get(this.ngTemplateOutletContext, r, i);
            },
          }
        );
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(mt(ns));
        };
      }
      static {
        this.ɵdir = sr({
          type: n,
          selectors: [["", "ngTemplateOutlet", ""]],
          inputs: {
            ngTemplateOutletContext: "ngTemplateOutletContext",
            ngTemplateOutlet: "ngTemplateOutlet",
            ngTemplateOutletInjector: "ngTemplateOutletInjector",
          },
          standalone: !0,
          features: [es],
        });
      }
    }
    return n;
  })();
function qh(n, e) {
  return new rt(2100, !1);
}
var ym = class {
    createSubscription(e, t) {
      return bi(() =>
        e.subscribe({
          next: t,
          error: (r) => {
            throw r;
          },
        })
      );
    }
    dispose(e) {
      bi(() => e.unsubscribe());
    }
  },
  wm = class {
    createSubscription(e, t) {
      return e.then(t, (r) => {
        throw r;
      });
    }
    dispose(e) {}
  },
  fD = new wm(),
  dD = new ym(),
  BW = (() => {
    class n {
      constructor(t) {
        (this._latestValue = null),
          (this.markForCheckOnValueUpdate = !0),
          (this._subscription = null),
          (this._obj = null),
          (this._strategy = null),
          (this._ref = t);
      }
      ngOnDestroy() {
        this._subscription && this._dispose(), (this._ref = null);
      }
      transform(t) {
        if (!this._obj) {
          if (t)
            try {
              (this.markForCheckOnValueUpdate = !1), this._subscribe(t);
            } finally {
              this.markForCheckOnValueUpdate = !0;
            }
          return this._latestValue;
        }
        return t !== this._obj
          ? (this._dispose(), this.transform(t))
          : this._latestValue;
      }
      _subscribe(t) {
        (this._obj = t),
          (this._strategy = this._selectStrategy(t)),
          (this._subscription = this._strategy.createSubscription(t, (r) =>
            this._updateLatestValue(t, r)
          ));
      }
      _selectStrategy(t) {
        if (Nh(t)) return fD;
        if (RE(t)) return dD;
        throw qh(n, t);
      }
      _dispose() {
        this._strategy.dispose(this._subscription),
          (this._latestValue = null),
          (this._subscription = null),
          (this._obj = null);
      }
      _updateLatestValue(t, r) {
        t === this._obj &&
          ((this._latestValue = r),
          this.markForCheckOnValueUpdate && this._ref?.markForCheck());
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(mt($r, 16));
        };
      }
      static {
        this.ɵpipe = pa({ name: "async", type: n, pure: !1, standalone: !0 });
      }
    }
    return n;
  })();
var DW = (() => {
    class n {
      constructor(t) {
        this._locale = t;
      }
      transform(t, r, i) {
        if (!km(t)) return null;
        i ||= this._locale;
        try {
          let s = Tm(t);
          return cD(s, i, r);
        } catch (s) {
          throw qh(n, s.message);
        }
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(mt(jh, 16));
        };
      }
      static {
        this.ɵpipe = pa({ name: "number", type: n, pure: !0, standalone: !0 });
      }
    }
    return n;
  })(),
  _W = (() => {
    class n {
      constructor(t) {
        this._locale = t;
      }
      transform(t, r, i) {
        if (!km(t)) return null;
        i ||= this._locale;
        try {
          let s = Tm(t);
          return aD(s, i, r);
        } catch (s) {
          throw qh(n, s.message);
        }
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(mt(jh, 16));
        };
      }
      static {
        this.ɵpipe = pa({ name: "percent", type: n, pure: !0, standalone: !0 });
      }
    }
    return n;
  })(),
  PW = (() => {
    class n {
      constructor(t, r = "USD") {
        (this._locale = t), (this._defaultCurrencyCode = r);
      }
      transform(t, r = this._defaultCurrencyCode, i = "symbol", s, o) {
        if (!km(t)) return null;
        (o ||= this._locale),
          typeof i == "boolean" && (i = i ? "symbol" : "code");
        let a = r || this._defaultCurrencyCode;
        i !== "code" &&
          (i === "symbol" || i === "symbol-narrow"
            ? (a = XB(a, i === "symbol" ? "wide" : "narrow", o))
            : (a = i));
        try {
          let c = Tm(t);
          return oD(c, o, a, r, s);
        } catch (c) {
          throw qh(n, c.message);
        }
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(mt(jh, 16), mt(BE, 16));
        };
      }
      static {
        this.ɵpipe = pa({
          name: "currency",
          type: n,
          pure: !0,
          standalone: !0,
        });
      }
    }
    return n;
  })();
function km(n) {
  return !(n == null || n === "" || n !== n);
}
function Tm(n) {
  if (typeof n == "string" && !isNaN(Number(n) - parseFloat(n)))
    return Number(n);
  if (typeof n != "number") throw new Error(`${n} is not a number`);
  return n;
}
var pD = (() => {
    class n {
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵmod = Xs({ type: n });
      }
      static {
        this.ɵinj = Zs({});
      }
    }
    return n;
  })(),
  Rm = "browser",
  gD = "server";
function mD(n) {
  return n === Rm;
}
function Bu(n) {
  return n === gD;
}
var Bm = (() => {
    class n {
      static {
        this.ɵprov = ae({
          token: n,
          providedIn: "root",
          factory: () => (mD(M(Vr)) ? new bm(M(Vt), window) : new Am()),
        });
      }
    }
    return n;
  })(),
  bm = class {
    constructor(e, t) {
      (this.document = e), (this.window = t), (this.offset = () => [0, 0]);
    }
    setOffset(e) {
      Array.isArray(e) ? (this.offset = () => e) : (this.offset = e);
    }
    getScrollPosition() {
      return [this.window.scrollX, this.window.scrollY];
    }
    scrollToPosition(e) {
      this.window.scrollTo(e[0], e[1]);
    }
    scrollToAnchor(e) {
      let t = yD(this.document, e);
      t && (this.scrollToElement(t), t.focus());
    }
    setHistoryScrollRestoration(e) {
      this.window.history.scrollRestoration = e;
    }
    scrollToElement(e) {
      let t = e.getBoundingClientRect(),
        r = t.left + this.window.pageXOffset,
        i = t.top + this.window.pageYOffset,
        s = this.offset();
      this.window.scrollTo(r - s[0], i - s[1]);
    }
  };
function yD(n, e) {
  let t = n.getElementById(e) || n.getElementsByName(e)[0];
  if (t) return t;
  if (
    typeof n.createTreeWalker == "function" &&
    n.body &&
    typeof n.body.attachShadow == "function"
  ) {
    let r = n.createTreeWalker(n.body, NodeFilter.SHOW_ELEMENT),
      i = r.currentNode;
    for (; i; ) {
      let s = i.shadowRoot;
      if (s) {
        let o = s.getElementById(e) || s.querySelector(`[name="${e}"]`);
        if (o) return o;
      }
      i = r.nextNode();
    }
  }
  return null;
}
var Am = class {
    setOffset(e) {}
    getScrollPosition() {
      return [0, 0];
    }
    scrollToPosition(e) {}
    scrollToAnchor(e) {}
    setHistoryScrollRestoration(e) {}
  },
  Ea = class {};
var o1 = (n) => n.src,
  wD = new Ae("", { providedIn: "root", factory: () => o1 });
var bD = new Ae("NG_OPTIMIZED_PRELOADED_IMAGES", {
    providedIn: "root",
    factory: () => new Set(),
  }),
  AD = (() => {
    class n {
      constructor() {
        (this.preloadedImages = M(bD)), (this.document = M(Vt));
      }
      createPreloadLinkTag(t, r, i, s) {
        if (this.preloadedImages.has(r)) return;
        this.preloadedImages.add(r);
        let o = t.createElement("link");
        t.setAttribute(o, "as", "image"),
          t.setAttribute(o, "href", r),
          t.setAttribute(o, "rel", "preload"),
          t.setAttribute(o, "fetchpriority", "high"),
          s && t.setAttribute(o, "imageSizes", s),
          i && t.setAttribute(o, "imageSrcset", i),
          t.appendChild(this.document.head, o);
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })();
var ED = /^((\s*\d+w\s*(,|$)){1,})$/;
var xD = [1, 2],
  SD = 640;
var vD = 1920,
  ID = 1080;
var LW = (() => {
  class n {
    constructor() {
      (this.imageLoader = M(wD)),
        (this.config = CD(M(uE))),
        (this.renderer = M(yi)),
        (this.imgElement = M(mi).nativeElement),
        (this.injector = M(pi)),
        (this.isServer = Bu(M(Vr))),
        (this.preloadLinkCreator = M(AD)),
        (this.lcpObserver = null),
        (this._renderedSrc = null),
        (this.priority = !1),
        (this.disableOptimizedSrcset = !1),
        (this.fill = !1);
    }
    ngOnInit() {
      om("NgOptimizedImage"),
        this.placeholder && this.removePlaceholderOnLoad(this.imgElement),
        this.setHostAttributes();
    }
    setHostAttributes() {
      this.fill
        ? (this.sizes ||= "100vw")
        : (this.setHostAttribute("width", this.width.toString()),
          this.setHostAttribute("height", this.height.toString())),
        this.setHostAttribute("loading", this.getLoadingBehavior()),
        this.setHostAttribute("fetchpriority", this.getFetchPriority()),
        this.setHostAttribute("ng-img", "true");
      let t = this.updateSrcAndSrcset();
      this.sizes && this.setHostAttribute("sizes", this.sizes),
        this.isServer &&
          this.priority &&
          this.preloadLinkCreator.createPreloadLinkTag(
            this.renderer,
            this.getRewrittenSrc(),
            t,
            this.sizes
          );
    }
    ngOnChanges(t) {
      if (t.ngSrc && !t.ngSrc.isFirstChange()) {
        let r = this._renderedSrc;
        this.updateSrcAndSrcset(!0);
        let i = this._renderedSrc;
        this.lcpObserver !== null &&
          r &&
          i &&
          r !== i &&
          this.injector.get(Kn).runOutsideAngular(() => {
            this.lcpObserver?.updateImage(r, i);
          });
      }
    }
    callImageLoader(t) {
      let r = t;
      return (
        this.loaderParams && (r.loaderParams = this.loaderParams),
        this.imageLoader(r)
      );
    }
    getLoadingBehavior() {
      return !this.priority && this.loading !== void 0
        ? this.loading
        : this.priority
        ? "eager"
        : "lazy";
    }
    getFetchPriority() {
      return this.priority ? "high" : "auto";
    }
    getRewrittenSrc() {
      if (!this._renderedSrc) {
        let t = { src: this.ngSrc };
        this._renderedSrc = this.callImageLoader(t);
      }
      return this._renderedSrc;
    }
    getRewrittenSrcset() {
      let t = ED.test(this.ngSrcset);
      return this.ngSrcset
        .split(",")
        .filter((i) => i !== "")
        .map((i) => {
          i = i.trim();
          let s = t ? parseFloat(i) : parseFloat(i) * this.width;
          return `${this.callImageLoader({ src: this.ngSrc, width: s })} ${i}`;
        })
        .join(", ");
    }
    getAutomaticSrcset() {
      return this.sizes ? this.getResponsiveSrcset() : this.getFixedSrcset();
    }
    getResponsiveSrcset() {
      let { breakpoints: t } = this.config,
        r = t;
      return (
        this.sizes?.trim() === "100vw" && (r = t.filter((s) => s >= SD)),
        r
          .map(
            (s) =>
              `${this.callImageLoader({ src: this.ngSrc, width: s })} ${s}w`
          )
          .join(", ")
      );
    }
    updateSrcAndSrcset(t = !1) {
      t && (this._renderedSrc = null);
      let r = this.getRewrittenSrc();
      this.setHostAttribute("src", r);
      let i;
      return (
        this.ngSrcset
          ? (i = this.getRewrittenSrcset())
          : this.shouldGenerateAutomaticSrcset() &&
            (i = this.getAutomaticSrcset()),
        i && this.setHostAttribute("srcset", i),
        i
      );
    }
    getFixedSrcset() {
      return xD
        .map(
          (r) =>
            `${this.callImageLoader({
              src: this.ngSrc,
              width: this.width * r,
            })} ${r}x`
        )
        .join(", ");
    }
    shouldGenerateAutomaticSrcset() {
      let t = !1;
      return (
        this.sizes || (t = this.width > vD || this.height > ID),
        !this.disableOptimizedSrcset &&
          !this.srcset &&
          this.imageLoader !== o1 &&
          !t
      );
    }
    generatePlaceholder(t) {
      let { placeholderResolution: r } = this.config;
      return t === !0
        ? `url(${this.callImageLoader({
            src: this.ngSrc,
            width: r,
            isPlaceholder: !0,
          })})`
        : typeof t == "string"
        ? `url(${t})`
        : null;
    }
    shouldBlurPlaceholder(t) {
      return !t || !t.hasOwnProperty("blur") ? !0 : !!t.blur;
    }
    removePlaceholderOnLoad(t) {
      let r = () => {
          let o = this.injector.get($r);
          i(), s(), (this.placeholder = !1), o.markForCheck();
        },
        i = this.renderer.listen(t, "load", r),
        s = this.renderer.listen(t, "error", r);
      kD(t, r);
    }
    ngOnDestroy() {}
    setHostAttribute(t, r) {
      this.renderer.setAttribute(this.imgElement, t, r);
    }
    static {
      this.ɵfac = function (r) {
        return new (r || n)();
      };
    }
    static {
      this.ɵdir = sr({
        type: n,
        selectors: [["img", "ngSrc", ""]],
        hostVars: 18,
        hostBindings: function (r, i) {
          r & 2 &&
            IE("position", i.fill ? "absolute" : null)(
              "width",
              i.fill ? "100%" : null
            )("height", i.fill ? "100%" : null)("inset", i.fill ? "0" : null)(
              "background-size",
              i.placeholder ? "cover" : null
            )("background-position", i.placeholder ? "50% 50%" : null)(
              "background-repeat",
              i.placeholder ? "no-repeat" : null
            )(
              "background-image",
              i.placeholder ? i.generatePlaceholder(i.placeholder) : null
            )(
              "filter",
              i.placeholder && i.shouldBlurPlaceholder(i.placeholderConfig)
                ? "blur(15px)"
                : null
            );
        },
        inputs: {
          ngSrc: [2, "ngSrc", "ngSrc", TD],
          ngSrcset: "ngSrcset",
          sizes: "sizes",
          width: [2, "width", "width", cm],
          height: [2, "height", "height", cm],
          loading: "loading",
          priority: [2, "priority", "priority", wi],
          loaderParams: "loaderParams",
          disableOptimizedSrcset: [
            2,
            "disableOptimizedSrcset",
            "disableOptimizedSrcset",
            wi,
          ],
          fill: [2, "fill", "fill", wi],
          placeholder: [2, "placeholder", "placeholder", RD],
          placeholderConfig: "placeholderConfig",
          src: "src",
          srcset: "srcset",
        },
        standalone: !0,
        features: [_h, es],
      });
    }
  }
  return n;
})();
function CD(n) {
  let e = {};
  return (
    n.breakpoints && (e.breakpoints = n.breakpoints.sort((t, r) => t - r)),
    Object.assign({}, cE, n, e)
  );
}
function kD(n, e) {
  n.complete && n.naturalWidth && e();
}
function TD(n) {
  return typeof n == "string" ? n : ts(n);
}
function RD(n) {
  return typeof n == "string" && n !== "true" && n !== "false" && n !== ""
    ? n
    : wi(n);
}
p();
p();
var _u = class {},
  Jh = class {},
  xi = class n {
    constructor(e) {
      (this.normalizedNames = new Map()),
        (this.lazyUpdate = null),
        e
          ? typeof e == "string"
            ? (this.lazyInit = () => {
                (this.headers = new Map()),
                  e
                    .split(
                      `
`
                    )
                    .forEach((t) => {
                      let r = t.indexOf(":");
                      if (r > 0) {
                        let i = t.slice(0, r),
                          s = i.toLowerCase(),
                          o = t.slice(r + 1).trim();
                        this.maybeSetNormalizedName(i, s),
                          this.headers.has(s)
                            ? this.headers.get(s).push(o)
                            : this.headers.set(s, [o]);
                      }
                    });
              })
            : typeof Headers < "u" && e instanceof Headers
            ? ((this.headers = new Map()),
              e.forEach((t, r) => {
                this.setHeaderEntries(r, t);
              }))
            : (this.lazyInit = () => {
                (this.headers = new Map()),
                  Object.entries(e).forEach(([t, r]) => {
                    this.setHeaderEntries(t, r);
                  });
              })
          : (this.headers = new Map());
    }
    has(e) {
      return this.init(), this.headers.has(e.toLowerCase());
    }
    get(e) {
      this.init();
      let t = this.headers.get(e.toLowerCase());
      return t && t.length > 0 ? t[0] : null;
    }
    keys() {
      return this.init(), Array.from(this.normalizedNames.values());
    }
    getAll(e) {
      return this.init(), this.headers.get(e.toLowerCase()) || null;
    }
    append(e, t) {
      return this.clone({ name: e, value: t, op: "a" });
    }
    set(e, t) {
      return this.clone({ name: e, value: t, op: "s" });
    }
    delete(e, t) {
      return this.clone({ name: e, value: t, op: "d" });
    }
    maybeSetNormalizedName(e, t) {
      this.normalizedNames.has(t) || this.normalizedNames.set(t, e);
    }
    init() {
      this.lazyInit &&
        (this.lazyInit instanceof n
          ? this.copyFrom(this.lazyInit)
          : this.lazyInit(),
        (this.lazyInit = null),
        this.lazyUpdate &&
          (this.lazyUpdate.forEach((e) => this.applyUpdate(e)),
          (this.lazyUpdate = null)));
    }
    copyFrom(e) {
      e.init(),
        Array.from(e.headers.keys()).forEach((t) => {
          this.headers.set(t, e.headers.get(t)),
            this.normalizedNames.set(t, e.normalizedNames.get(t));
        });
    }
    clone(e) {
      let t = new n();
      return (
        (t.lazyInit =
          this.lazyInit && this.lazyInit instanceof n ? this.lazyInit : this),
        (t.lazyUpdate = (this.lazyUpdate || []).concat([e])),
        t
      );
    }
    applyUpdate(e) {
      let t = e.name.toLowerCase();
      switch (e.op) {
        case "a":
        case "s":
          let r = e.value;
          if ((typeof r == "string" && (r = [r]), r.length === 0)) return;
          this.maybeSetNormalizedName(e.name, t);
          let i = (e.op === "a" ? this.headers.get(t) : void 0) || [];
          i.push(...r), this.headers.set(t, i);
          break;
        case "d":
          let s = e.value;
          if (!s) this.headers.delete(t), this.normalizedNames.delete(t);
          else {
            let o = this.headers.get(t);
            if (!o) return;
            (o = o.filter((a) => s.indexOf(a) === -1)),
              o.length === 0
                ? (this.headers.delete(t), this.normalizedNames.delete(t))
                : this.headers.set(t, o);
          }
          break;
      }
    }
    setHeaderEntries(e, t) {
      let r = (Array.isArray(t) ? t : [t]).map((s) => s.toString()),
        i = e.toLowerCase();
      this.headers.set(i, r), this.maybeSetNormalizedName(e, i);
    }
    forEach(e) {
      this.init(),
        Array.from(this.normalizedNames.keys()).forEach((t) =>
          e(this.normalizedNames.get(t), this.headers.get(t))
        );
    }
  };
var _m = class {
  encodeKey(e) {
    return c1(e);
  }
  encodeValue(e) {
    return c1(e);
  }
  decodeKey(e) {
    return decodeURIComponent(e);
  }
  decodeValue(e) {
    return decodeURIComponent(e);
  }
};
function BD(n, e) {
  let t = new Map();
  return (
    n.length > 0 &&
      n
        .replace(/^\?/, "")
        .split("&")
        .forEach((i) => {
          let s = i.indexOf("="),
            [o, a] =
              s == -1
                ? [e.decodeKey(i), ""]
                : [e.decodeKey(i.slice(0, s)), e.decodeValue(i.slice(s + 1))],
            c = t.get(o) || [];
          c.push(a), t.set(o, c);
        }),
    t
  );
}
var DD = /%(\d[a-f0-9])/gi,
  _D = {
    40: "@",
    "3A": ":",
    24: "$",
    "2C": ",",
    "3B": ";",
    "3D": "=",
    "3F": "?",
    "2F": "/",
  };
function c1(n) {
  return encodeURIComponent(n).replace(DD, (e, t) => _D[t] ?? e);
}
function Qh(n) {
  return `${n}`;
}
var ur = class n {
    constructor(e = {}) {
      if (
        ((this.updates = null),
        (this.cloneFrom = null),
        (this.encoder = e.encoder || new _m()),
        e.fromString)
      ) {
        if (e.fromObject)
          throw new Error("Cannot specify both fromString and fromObject.");
        this.map = BD(e.fromString, this.encoder);
      } else
        e.fromObject
          ? ((this.map = new Map()),
            Object.keys(e.fromObject).forEach((t) => {
              let r = e.fromObject[t],
                i = Array.isArray(r) ? r.map(Qh) : [Qh(r)];
              this.map.set(t, i);
            }))
          : (this.map = null);
    }
    has(e) {
      return this.init(), this.map.has(e);
    }
    get(e) {
      this.init();
      let t = this.map.get(e);
      return t ? t[0] : null;
    }
    getAll(e) {
      return this.init(), this.map.get(e) || null;
    }
    keys() {
      return this.init(), Array.from(this.map.keys());
    }
    append(e, t) {
      return this.clone({ param: e, value: t, op: "a" });
    }
    appendAll(e) {
      let t = [];
      return (
        Object.keys(e).forEach((r) => {
          let i = e[r];
          Array.isArray(i)
            ? i.forEach((s) => {
                t.push({ param: r, value: s, op: "a" });
              })
            : t.push({ param: r, value: i, op: "a" });
        }),
        this.clone(t)
      );
    }
    set(e, t) {
      return this.clone({ param: e, value: t, op: "s" });
    }
    delete(e, t) {
      return this.clone({ param: e, value: t, op: "d" });
    }
    toString() {
      return (
        this.init(),
        this.keys()
          .map((e) => {
            let t = this.encoder.encodeKey(e);
            return this.map
              .get(e)
              .map((r) => t + "=" + this.encoder.encodeValue(r))
              .join("&");
          })
          .filter((e) => e !== "")
          .join("&")
      );
    }
    clone(e) {
      let t = new n({ encoder: this.encoder });
      return (
        (t.cloneFrom = this.cloneFrom || this),
        (t.updates = (this.updates || []).concat(e)),
        t
      );
    }
    init() {
      this.map === null && (this.map = new Map()),
        this.cloneFrom !== null &&
          (this.cloneFrom.init(),
          this.cloneFrom
            .keys()
            .forEach((e) => this.map.set(e, this.cloneFrom.map.get(e))),
          this.updates.forEach((e) => {
            switch (e.op) {
              case "a":
              case "s":
                let t = (e.op === "a" ? this.map.get(e.param) : void 0) || [];
                t.push(Qh(e.value)), this.map.set(e.param, t);
                break;
              case "d":
                if (e.value !== void 0) {
                  let r = this.map.get(e.param) || [],
                    i = r.indexOf(Qh(e.value));
                  i !== -1 && r.splice(i, 1),
                    r.length > 0
                      ? this.map.set(e.param, r)
                      : this.map.delete(e.param);
                } else {
                  this.map.delete(e.param);
                  break;
                }
            }
          }),
          (this.cloneFrom = this.updates = null));
    }
  },
  Pu = class {
    constructor(e) {
      this.defaultValue = e;
    }
  },
  Sa = class {
    constructor() {
      this.map = new Map();
    }
    set(e, t) {
      return this.map.set(e, t), this;
    }
    get(e) {
      return (
        this.map.has(e) || this.map.set(e, e.defaultValue()), this.map.get(e)
      );
    }
    delete(e) {
      return this.map.delete(e), this;
    }
    has(e) {
      return this.map.has(e);
    }
    keys() {
      return this.map.keys();
    }
  };
function PD(n) {
  switch (n) {
    case "DELETE":
    case "GET":
    case "HEAD":
    case "OPTIONS":
    case "JSONP":
      return !1;
    default:
      return !0;
  }
}
function u1(n) {
  return typeof ArrayBuffer < "u" && n instanceof ArrayBuffer;
}
function l1(n) {
  return typeof Blob < "u" && n instanceof Blob;
}
function h1(n) {
  return typeof FormData < "u" && n instanceof FormData;
}
function LD(n) {
  return typeof URLSearchParams < "u" && n instanceof URLSearchParams;
}
var Du = class n {
    constructor(e, t, r, i) {
      (this.url = t),
        (this.body = null),
        (this.reportProgress = !1),
        (this.withCredentials = !1),
        (this.responseType = "json"),
        (this.method = e.toUpperCase());
      let s;
      if (
        (PD(this.method) || i
          ? ((this.body = r !== void 0 ? r : null), (s = i))
          : (s = r),
        s &&
          ((this.reportProgress = !!s.reportProgress),
          (this.withCredentials = !!s.withCredentials),
          s.responseType && (this.responseType = s.responseType),
          s.headers && (this.headers = s.headers),
          s.context && (this.context = s.context),
          s.params && (this.params = s.params),
          (this.transferCache = s.transferCache)),
        (this.headers ??= new xi()),
        (this.context ??= new Sa()),
        !this.params)
      )
        (this.params = new ur()), (this.urlWithParams = t);
      else {
        let o = this.params.toString();
        if (o.length === 0) this.urlWithParams = t;
        else {
          let a = t.indexOf("?"),
            c = a === -1 ? "?" : a < t.length - 1 ? "&" : "";
          this.urlWithParams = t + c + o;
        }
      }
    }
    serializeBody() {
      return this.body === null
        ? null
        : typeof this.body == "string" ||
          u1(this.body) ||
          l1(this.body) ||
          h1(this.body) ||
          LD(this.body)
        ? this.body
        : this.body instanceof ur
        ? this.body.toString()
        : typeof this.body == "object" ||
          typeof this.body == "boolean" ||
          Array.isArray(this.body)
        ? JSON.stringify(this.body)
        : this.body.toString();
    }
    detectContentTypeHeader() {
      return this.body === null || h1(this.body)
        ? null
        : l1(this.body)
        ? this.body.type || null
        : u1(this.body)
        ? null
        : typeof this.body == "string"
        ? "text/plain"
        : this.body instanceof ur
        ? "application/x-www-form-urlencoded;charset=UTF-8"
        : typeof this.body == "object" ||
          typeof this.body == "number" ||
          typeof this.body == "boolean"
        ? "application/json"
        : null;
    }
    clone(e = {}) {
      let t = e.method || this.method,
        r = e.url || this.url,
        i = e.responseType || this.responseType,
        s = e.transferCache ?? this.transferCache,
        o = e.body !== void 0 ? e.body : this.body,
        a = e.withCredentials ?? this.withCredentials,
        c = e.reportProgress ?? this.reportProgress,
        u = e.headers || this.headers,
        l = e.params || this.params,
        h = e.context ?? this.context;
      return (
        e.setHeaders !== void 0 &&
          (u = Object.keys(e.setHeaders).reduce(
            (f, g) => f.set(g, e.setHeaders[g]),
            u
          )),
        e.setParams &&
          (l = Object.keys(e.setParams).reduce(
            (f, g) => f.set(g, e.setParams[g]),
            l
          )),
        new n(t, r, o, {
          params: l,
          headers: u,
          context: h,
          reportProgress: c,
          responseType: i,
          withCredentials: a,
          transferCache: s,
        })
      );
    }
  },
  os = (function (n) {
    return (
      (n[(n.Sent = 0)] = "Sent"),
      (n[(n.UploadProgress = 1)] = "UploadProgress"),
      (n[(n.ResponseHeader = 2)] = "ResponseHeader"),
      (n[(n.DownloadProgress = 3)] = "DownloadProgress"),
      (n[(n.Response = 4)] = "Response"),
      (n[(n.User = 5)] = "User"),
      n
    );
  })(os || {}),
  Lu = class {
    constructor(e, t = 200, r = "OK") {
      (this.headers = e.headers || new xi()),
        (this.status = e.status !== void 0 ? e.status : t),
        (this.statusText = e.statusText || r),
        (this.url = e.url || null),
        (this.ok = this.status >= 200 && this.status < 300);
    }
  },
  Yh = class n extends Lu {
    constructor(e = {}) {
      super(e), (this.type = os.ResponseHeader);
    }
    clone(e = {}) {
      return new n({
        headers: e.headers || this.headers,
        status: e.status !== void 0 ? e.status : this.status,
        statusText: e.statusText || this.statusText,
        url: e.url || this.url || void 0,
      });
    }
  },
  Ou = class n extends Lu {
    constructor(e = {}) {
      super(e),
        (this.type = os.Response),
        (this.body = e.body !== void 0 ? e.body : null);
    }
    clone(e = {}) {
      return new n({
        body: e.body !== void 0 ? e.body : this.body,
        headers: e.headers || this.headers,
        status: e.status !== void 0 ? e.status : this.status,
        statusText: e.statusText || this.statusText,
        url: e.url || this.url || void 0,
      });
    }
  },
  ss = class extends Lu {
    constructor(e) {
      super(e, 0, "Unknown Error"),
        (this.name = "HttpErrorResponse"),
        (this.ok = !1),
        this.status >= 200 && this.status < 300
          ? (this.message = `Http failure during parsing for ${
              e.url || "(unknown url)"
            }`)
          : (this.message = `Http failure response for ${
              e.url || "(unknown url)"
            }: ${e.status} ${e.statusText}`),
        (this.error = e.error || null);
    }
  },
  g1 = 200,
  OD = 204;
function Dm(n, e) {
  return {
    body: e,
    headers: n.headers,
    context: n.context,
    observe: n.observe,
    params: n.params,
    reportProgress: n.reportProgress,
    responseType: n.responseType,
    withCredentials: n.withCredentials,
    transferCache: n.transferCache,
  };
}
var Om = (() => {
    class n {
      constructor(t) {
        this.handler = t;
      }
      request(t, r, i = {}) {
        let s;
        if (t instanceof Du) s = t;
        else {
          let c;
          i.headers instanceof xi ? (c = i.headers) : (c = new xi(i.headers));
          let u;
          i.params &&
            (i.params instanceof ur
              ? (u = i.params)
              : (u = new ur({ fromObject: i.params }))),
            (s = new Du(t, r, i.body !== void 0 ? i.body : null, {
              headers: c,
              context: i.context,
              params: u,
              reportProgress: i.reportProgress,
              responseType: i.responseType || "json",
              withCredentials: i.withCredentials,
              transferCache: i.transferCache,
            }));
        }
        let o = oe(s).pipe(Sn((c) => this.handler.handle(c)));
        if (t instanceof Du || i.observe === "events") return o;
        let a = o.pipe(xn((c) => c instanceof Ou));
        switch (i.observe || "body") {
          case "body":
            switch (s.responseType) {
              case "arraybuffer":
                return a.pipe(
                  xe((c) => {
                    if (c.body !== null && !(c.body instanceof ArrayBuffer))
                      throw new Error("Response is not an ArrayBuffer.");
                    return c.body;
                  })
                );
              case "blob":
                return a.pipe(
                  xe((c) => {
                    if (c.body !== null && !(c.body instanceof Blob))
                      throw new Error("Response is not a Blob.");
                    return c.body;
                  })
                );
              case "text":
                return a.pipe(
                  xe((c) => {
                    if (c.body !== null && typeof c.body != "string")
                      throw new Error("Response is not a string.");
                    return c.body;
                  })
                );
              case "json":
              default:
                return a.pipe(xe((c) => c.body));
            }
          case "response":
            return a;
          default:
            throw new Error(
              `Unreachable: unhandled observe type ${i.observe}}`
            );
        }
      }
      delete(t, r = {}) {
        return this.request("DELETE", t, r);
      }
      get(t, r = {}) {
        return this.request("GET", t, r);
      }
      head(t, r = {}) {
        return this.request("HEAD", t, r);
      }
      jsonp(t, r) {
        return this.request("JSONP", t, {
          params: new ur().append(r, "JSONP_CALLBACK"),
          observe: "body",
          responseType: "json",
        });
      }
      options(t, r = {}) {
        return this.request("OPTIONS", t, r);
      }
      patch(t, r, i = {}) {
        return this.request("PATCH", t, Dm(i, r));
      }
      post(t, r, i = {}) {
        return this.request("POST", t, Dm(i, r));
      }
      put(t, r, i = {}) {
        return this.request("PUT", t, Dm(i, r));
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(_u));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })(),
  ND = /^\)\]\}',?\n/,
  FD = "X-Request-URL";
function f1(n) {
  if (n.url) return n.url;
  let e = FD.toLocaleLowerCase();
  return n.headers.get(e);
}
var MD = (() => {
    class n {
      constructor() {
        (this.fetchImpl =
          M(Pm, { optional: !0 })?.fetch ?? ((...t) => globalThis.fetch(...t))),
          (this.ngZone = M(Kn));
      }
      handle(t) {
        return new Ys((r) => {
          let i = new AbortController();
          return (
            this.doRequest(t, i.signal, r).then(Lm, (s) =>
              r.error(new ss({ error: s }))
            ),
            () => i.abort()
          );
        });
      }
      doRequest(t, r, i) {
        return d(this, null, function* () {
          let s = this.createRequestInit(t),
            o;
          try {
            let g = this.ngZone.runOutsideAngular(() =>
              this.fetchImpl(t.urlWithParams, v({ signal: r }, s))
            );
            UD(g), i.next({ type: os.Sent }), (o = yield g);
          } catch (g) {
            i.error(
              new ss({
                error: g,
                status: g.status ?? 0,
                statusText: g.statusText,
                url: t.urlWithParams,
                headers: g.headers,
              })
            );
            return;
          }
          let a = new xi(o.headers),
            c = o.statusText,
            u = f1(o) ?? t.urlWithParams,
            l = o.status,
            h = null;
          if (
            (t.reportProgress &&
              i.next(new Yh({ headers: a, status: l, statusText: c, url: u })),
            o.body)
          ) {
            let g = o.headers.get("content-length"),
              y = [],
              w = o.body.getReader(),
              m = 0,
              b,
              I,
              E = typeof Zone < "u" && Zone.current;
            yield this.ngZone.runOutsideAngular(() =>
              d(this, null, function* () {
                for (;;) {
                  let { done: B, value: L } = yield w.read();
                  if (B) break;
                  if ((y.push(L), (m += L.length), t.reportProgress)) {
                    I =
                      t.responseType === "text"
                        ? (I ?? "") +
                          (b ??= new TextDecoder()).decode(L, { stream: !0 })
                        : void 0;
                    let U = () =>
                      i.next({
                        type: os.DownloadProgress,
                        total: g ? +g : void 0,
                        loaded: m,
                        partialText: I,
                      });
                    E ? E.run(U) : U();
                  }
                }
              })
            );
            let T = this.concatChunks(y, m);
            try {
              let B = o.headers.get("Content-Type") ?? "";
              h = this.parseBody(t, T, B);
            } catch (B) {
              i.error(
                new ss({
                  error: B,
                  headers: new xi(o.headers),
                  status: o.status,
                  statusText: o.statusText,
                  url: f1(o) ?? t.urlWithParams,
                })
              );
              return;
            }
          }
          l === 0 && (l = h ? g1 : 0),
            l >= 200 && l < 300
              ? (i.next(
                  new Ou({
                    body: h,
                    headers: a,
                    status: l,
                    statusText: c,
                    url: u,
                  })
                ),
                i.complete())
              : i.error(
                  new ss({
                    error: h,
                    headers: a,
                    status: l,
                    statusText: c,
                    url: u,
                  })
                );
        });
      }
      parseBody(t, r, i) {
        switch (t.responseType) {
          case "json":
            let s = new TextDecoder().decode(r).replace(ND, "");
            return s === "" ? null : JSON.parse(s);
          case "text":
            return new TextDecoder().decode(r);
          case "blob":
            return new Blob([r], { type: i });
          case "arraybuffer":
            return r.buffer;
        }
      }
      createRequestInit(t) {
        let r = {},
          i = t.withCredentials ? "include" : void 0;
        if (
          (t.headers.forEach((s, o) => (r[s] = o.join(","))),
          t.headers.has("Accept") ||
            (r.Accept = "application/json, text/plain, */*"),
          !t.headers.has("Content-Type"))
        ) {
          let s = t.detectContentTypeHeader();
          s !== null && (r["Content-Type"] = s);
        }
        return {
          body: t.serializeBody(),
          method: t.method,
          headers: r,
          credentials: i,
        };
      }
      concatChunks(t, r) {
        let i = new Uint8Array(r),
          s = 0;
        for (let o of t) i.set(o, s), (s += o.length);
        return i;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })(),
  Pm = class {};
function Lm() {}
function UD(n) {
  n.then(Lm, Lm);
}
function zD(n, e) {
  return e(n);
}
function jD(n, e, t) {
  return (r, i) => ar(t, () => e(r, (s) => n(s, i)));
}
var Nm = new Ae(""),
  WD = new Ae(""),
  HD = new Ae("", { providedIn: "root", factory: () => !0 });
var d1 = (() => {
  class n extends _u {
    constructor(t, r) {
      super(),
        (this.backend = t),
        (this.injector = r),
        (this.chain = null),
        (this.pendingTasks = M(Dh)),
        (this.contributeToStability = M(HD));
    }
    handle(t) {
      if (this.chain === null) {
        let r = Array.from(
          new Set([...this.injector.get(Nm), ...this.injector.get(WD, [])])
        );
        this.chain = r.reduceRight((i, s) => jD(i, s, this.injector), zD);
      }
      if (this.contributeToStability) {
        let r = this.pendingTasks.add();
        return this.chain(t, (i) => this.backend.handle(i)).pipe(
          Wr(() => this.pendingTasks.remove(r))
        );
      } else return this.chain(t, (r) => this.backend.handle(r));
    }
    static {
      this.ɵfac = function (r) {
        return new (r || n)(le(Jh), le(eo));
      };
    }
    static {
      this.ɵprov = ae({ token: n, factory: n.ɵfac });
    }
  }
  return n;
})();
var VD = /^\)\]\}',?\n/;
function $D(n) {
  return "responseURL" in n && n.responseURL
    ? n.responseURL
    : /^X-Request-URL:/m.test(n.getAllResponseHeaders())
    ? n.getResponseHeader("X-Request-URL")
    : null;
}
var p1 = (() => {
    class n {
      constructor(t) {
        this.xhrFactory = t;
      }
      handle(t) {
        if (t.method === "JSONP") throw new rt(-2800, !1);
        let r = this.xhrFactory;
        return (r.ɵloadImpl ? Ke(r.ɵloadImpl()) : oe(null)).pipe(
          ct(
            () =>
              new Ys((s) => {
                let o = r.build();
                if (
                  (o.open(t.method, t.urlWithParams),
                  t.withCredentials && (o.withCredentials = !0),
                  t.headers.forEach((w, m) =>
                    o.setRequestHeader(w, m.join(","))
                  ),
                  t.headers.has("Accept") ||
                    o.setRequestHeader(
                      "Accept",
                      "application/json, text/plain, */*"
                    ),
                  !t.headers.has("Content-Type"))
                ) {
                  let w = t.detectContentTypeHeader();
                  w !== null && o.setRequestHeader("Content-Type", w);
                }
                if (t.responseType) {
                  let w = t.responseType.toLowerCase();
                  o.responseType = w !== "json" ? w : "text";
                }
                let a = t.serializeBody(),
                  c = null,
                  u = () => {
                    if (c !== null) return c;
                    let w = o.statusText || "OK",
                      m = new xi(o.getAllResponseHeaders()),
                      b = $D(o) || t.url;
                    return (
                      (c = new Yh({
                        headers: m,
                        status: o.status,
                        statusText: w,
                        url: b,
                      })),
                      c
                    );
                  },
                  l = () => {
                    let { headers: w, status: m, statusText: b, url: I } = u(),
                      E = null;
                    m !== OD &&
                      (E =
                        typeof o.response > "u" ? o.responseText : o.response),
                      m === 0 && (m = E ? g1 : 0);
                    let T = m >= 200 && m < 300;
                    if (t.responseType === "json" && typeof E == "string") {
                      let B = E;
                      E = E.replace(VD, "");
                      try {
                        E = E !== "" ? JSON.parse(E) : null;
                      } catch (L) {
                        (E = B), T && ((T = !1), (E = { error: L, text: E }));
                      }
                    }
                    T
                      ? (s.next(
                          new Ou({
                            body: E,
                            headers: w,
                            status: m,
                            statusText: b,
                            url: I || void 0,
                          })
                        ),
                        s.complete())
                      : s.error(
                          new ss({
                            error: E,
                            headers: w,
                            status: m,
                            statusText: b,
                            url: I || void 0,
                          })
                        );
                  },
                  h = (w) => {
                    let { url: m } = u(),
                      b = new ss({
                        error: w,
                        status: o.status || 0,
                        statusText: o.statusText || "Unknown Error",
                        url: m || void 0,
                      });
                    s.error(b);
                  },
                  f = !1,
                  g = (w) => {
                    f || (s.next(u()), (f = !0));
                    let m = { type: os.DownloadProgress, loaded: w.loaded };
                    w.lengthComputable && (m.total = w.total),
                      t.responseType === "text" &&
                        o.responseText &&
                        (m.partialText = o.responseText),
                      s.next(m);
                  },
                  y = (w) => {
                    let m = { type: os.UploadProgress, loaded: w.loaded };
                    w.lengthComputable && (m.total = w.total), s.next(m);
                  };
                return (
                  o.addEventListener("load", l),
                  o.addEventListener("error", h),
                  o.addEventListener("timeout", h),
                  o.addEventListener("abort", h),
                  t.reportProgress &&
                    (o.addEventListener("progress", g),
                    a !== null &&
                      o.upload &&
                      o.upload.addEventListener("progress", y)),
                  o.send(a),
                  s.next({ type: os.Sent }),
                  () => {
                    o.removeEventListener("error", h),
                      o.removeEventListener("abort", h),
                      o.removeEventListener("load", l),
                      o.removeEventListener("timeout", h),
                      t.reportProgress &&
                        (o.removeEventListener("progress", g),
                        a !== null &&
                          o.upload &&
                          o.upload.removeEventListener("progress", y)),
                      o.readyState !== o.DONE && o.abort();
                  }
                );
              })
          )
        );
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Ea));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })(),
  m1 = new Ae(""),
  GD = "XSRF-TOKEN",
  KD = new Ae("", { providedIn: "root", factory: () => GD }),
  qD = "X-XSRF-TOKEN",
  QD = new Ae("", { providedIn: "root", factory: () => qD }),
  Zh = class {},
  JD = (() => {
    class n {
      constructor(t, r, i) {
        (this.doc = t),
          (this.platform = r),
          (this.cookieName = i),
          (this.lastCookieString = ""),
          (this.lastToken = null),
          (this.parseCount = 0);
      }
      getToken() {
        if (this.platform === "server") return null;
        let t = this.doc.cookie || "";
        return (
          t !== this.lastCookieString &&
            (this.parseCount++,
            (this.lastToken = Kh(t, this.cookieName)),
            (this.lastCookieString = t)),
          this.lastToken
        );
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Vt), le(Vr), le(KD));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })();
function YD(n, e) {
  let t = n.url.toLowerCase();
  if (
    !M(m1) ||
    n.method === "GET" ||
    n.method === "HEAD" ||
    t.startsWith("http://") ||
    t.startsWith("https://")
  )
    return e(n);
  let r = M(Zh).getToken(),
    i = M(QD);
  return (
    r != null &&
      !n.headers.has(i) &&
      (n = n.clone({ headers: n.headers.set(i, r) })),
    e(n)
  );
}
var y1 = (function (n) {
  return (
    (n[(n.Interceptors = 0)] = "Interceptors"),
    (n[(n.LegacyInterceptors = 1)] = "LegacyInterceptors"),
    (n[(n.CustomXsrfConfiguration = 2)] = "CustomXsrfConfiguration"),
    (n[(n.NoXsrfProtection = 3)] = "NoXsrfProtection"),
    (n[(n.JsonpSupport = 4)] = "JsonpSupport"),
    (n[(n.RequestsMadeViaParent = 5)] = "RequestsMadeViaParent"),
    (n[(n.Fetch = 6)] = "Fetch"),
    n
  );
})(y1 || {});
function ZD(n, e) {
  return { ɵkind: n, ɵproviders: e };
}
function qW(...n) {
  let e = [
    Om,
    p1,
    d1,
    { provide: _u, useExisting: d1 },
    { provide: Jh, useFactory: () => M(MD, { optional: !0 }) ?? M(p1) },
    { provide: Nm, useValue: YD, multi: !0 },
    { provide: m1, useValue: !0 },
    { provide: Zh, useClass: JD },
  ];
  for (let t of n) e.push(...t.ɵproviders);
  return or(e);
}
function QW(n) {
  return ZD(
    y1.Interceptors,
    n.map((e) => ({ provide: Nm, useValue: e, multi: !0 }))
  );
}
var Um = class extends Vh {
    constructor() {
      super(...arguments), (this.supportsDOMEvents = !0);
    }
  },
  zm = class n extends Um {
    static makeCurrent() {
      t1(new n());
    }
    onAndCancel(e, t, r) {
      return (
        e.addEventListener(t, r),
        () => {
          e.removeEventListener(t, r);
        }
      );
    }
    dispatchEvent(e, t) {
      e.dispatchEvent(t);
    }
    remove(e) {
      e.remove();
    }
    createElement(e, t) {
      return (t = t || this.getDefaultDocument()), t.createElement(e);
    }
    createHtmlDocument() {
      return document.implementation.createHTMLDocument("fakeTitle");
    }
    getDefaultDocument() {
      return document;
    }
    isElementNode(e) {
      return e.nodeType === Node.ELEMENT_NODE;
    }
    isShadowRoot(e) {
      return e instanceof DocumentFragment;
    }
    getGlobalEventTarget(e, t) {
      return t === "window"
        ? window
        : t === "document"
        ? e
        : t === "body"
        ? e.body
        : null;
    }
    getBaseHref(e) {
      let t = e_();
      return t == null ? null : t_(t);
    }
    resetBaseElement() {
      Nu = null;
    }
    getUserAgent() {
      return window.navigator.userAgent;
    }
    getCookie(e) {
      return Kh(document.cookie, e);
    }
  },
  Nu = null;
function e_() {
  return (
    (Nu = Nu || document.querySelector("base")),
    Nu ? Nu.getAttribute("href") : null
  );
}
function t_(n) {
  return new URL(n, document.baseURI).pathname;
}
var n_ = (() => {
    class n {
      build() {
        return new XMLHttpRequest();
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })(),
  jm = new Ae(""),
  E1 = (() => {
    class n {
      constructor(t, r) {
        (this._zone = r),
          (this._eventNameToPlugin = new Map()),
          t.forEach((i) => {
            i.manager = this;
          }),
          (this._plugins = t.slice().reverse());
      }
      addEventListener(t, r, i) {
        return this._findPluginFor(r).addEventListener(t, r, i);
      }
      getZone() {
        return this._zone;
      }
      _findPluginFor(t) {
        let r = this._eventNameToPlugin.get(t);
        if (r) return r;
        if (((r = this._plugins.find((s) => s.supports(t))), !r))
          throw new rt(5101, !1);
        return this._eventNameToPlugin.set(t, r), r;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(jm), le(Kn));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })(),
  Xh = class {
    constructor(e) {
      this._doc = e;
    }
  },
  Fm = "ng-app-id",
  x1 = (() => {
    class n {
      constructor(t, r, i, s = {}) {
        (this.doc = t),
          (this.appId = r),
          (this.nonce = i),
          (this.platformId = s),
          (this.styleRef = new Map()),
          (this.hostNodes = new Set()),
          (this.styleNodesInDOM = this.collectServerRenderedStyles()),
          (this.platformIsServer = Bu(s)),
          this.resetHostNodes();
      }
      addStyles(t) {
        for (let r of t)
          this.changeUsageCount(r, 1) === 1 && this.onStyleAdded(r);
      }
      removeStyles(t) {
        for (let r of t)
          this.changeUsageCount(r, -1) <= 0 && this.onStyleRemoved(r);
      }
      ngOnDestroy() {
        let t = this.styleNodesInDOM;
        t && (t.forEach((r) => r.remove()), t.clear());
        for (let r of this.getAllStyles()) this.onStyleRemoved(r);
        this.resetHostNodes();
      }
      addHost(t) {
        this.hostNodes.add(t);
        for (let r of this.getAllStyles()) this.addStyleToHost(t, r);
      }
      removeHost(t) {
        this.hostNodes.delete(t);
      }
      getAllStyles() {
        return this.styleRef.keys();
      }
      onStyleAdded(t) {
        for (let r of this.hostNodes) this.addStyleToHost(r, t);
      }
      onStyleRemoved(t) {
        let r = this.styleRef;
        r.get(t)?.elements?.forEach((i) => i.remove()), r.delete(t);
      }
      collectServerRenderedStyles() {
        let t = this.doc.head?.querySelectorAll(`style[${Fm}="${this.appId}"]`);
        if (t?.length) {
          let r = new Map();
          return (
            t.forEach((i) => {
              i.textContent != null && r.set(i.textContent, i);
            }),
            r
          );
        }
        return null;
      }
      changeUsageCount(t, r) {
        let i = this.styleRef;
        if (i.has(t)) {
          let s = i.get(t);
          return (s.usage += r), s.usage;
        }
        return i.set(t, { usage: r, elements: [] }), r;
      }
      getStyleElement(t, r) {
        let i = this.styleNodesInDOM,
          s = i?.get(r);
        if (s?.parentNode === t) return i.delete(r), s.removeAttribute(Fm), s;
        {
          let o = this.doc.createElement("style");
          return (
            this.nonce && o.setAttribute("nonce", this.nonce),
            (o.textContent = r),
            this.platformIsServer && o.setAttribute(Fm, this.appId),
            t.appendChild(o),
            o
          );
        }
      }
      addStyleToHost(t, r) {
        let i = this.getStyleElement(t, r),
          s = this.styleRef,
          o = s.get(r)?.elements;
        o ? o.push(i) : s.set(r, { elements: [i], usage: 1 });
      }
      resetHostNodes() {
        let t = this.hostNodes;
        t.clear(), t.add(this.doc.head);
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Vt), le(im), le(sm, 8), le(Vr));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })(),
  Mm = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/",
    math: "http://www.w3.org/1998/Math/MathML",
  },
  Hm = /%COMP%/g,
  S1 = "%COMP%",
  r_ = `_nghost-${S1}`,
  i_ = `_ngcontent-${S1}`,
  s_ = !0,
  o_ = new Ae("", { providedIn: "root", factory: () => s_ });
function a_(n) {
  return i_.replace(Hm, n);
}
function c_(n) {
  return r_.replace(Hm, n);
}
function v1(n, e) {
  return e.map((t) => t.replace(Hm, n));
}
var w1 = (() => {
    class n {
      constructor(t, r, i, s, o, a, c, u = null) {
        (this.eventManager = t),
          (this.sharedStylesHost = r),
          (this.appId = i),
          (this.removeStylesOnCompDestroy = s),
          (this.doc = o),
          (this.platformId = a),
          (this.ngZone = c),
          (this.nonce = u),
          (this.rendererByCompId = new Map()),
          (this.platformIsServer = Bu(a)),
          (this.defaultRenderer = new Fu(t, o, c, this.platformIsServer));
      }
      createRenderer(t, r) {
        if (!t || !r) return this.defaultRenderer;
        this.platformIsServer &&
          r.encapsulation === Cu.ShadowDom &&
          (r = $(v({}, r), { encapsulation: Cu.Emulated }));
        let i = this.getOrCreateRenderer(t, r);
        return (
          i instanceof ef
            ? i.applyToHost(t)
            : i instanceof Mu && i.applyStyles(),
          i
        );
      }
      getOrCreateRenderer(t, r) {
        let i = this.rendererByCompId,
          s = i.get(r.id);
        if (!s) {
          let o = this.doc,
            a = this.ngZone,
            c = this.eventManager,
            u = this.sharedStylesHost,
            l = this.removeStylesOnCompDestroy,
            h = this.platformIsServer;
          switch (r.encapsulation) {
            case Cu.Emulated:
              s = new ef(c, u, r, this.appId, l, o, a, h);
              break;
            case Cu.ShadowDom:
              return new Wm(c, u, t, r, o, a, this.nonce, h);
            default:
              s = new Mu(c, u, r, l, o, a, h);
              break;
          }
          i.set(r.id, s);
        }
        return s;
      }
      ngOnDestroy() {
        this.rendererByCompId.clear();
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(
            le(E1),
            le(x1),
            le(im),
            le(o_),
            le(Vt),
            le(Vr),
            le(Kn),
            le(sm)
          );
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })(),
  Fu = class {
    constructor(e, t, r, i) {
      (this.eventManager = e),
        (this.doc = t),
        (this.ngZone = r),
        (this.platformIsServer = i),
        (this.data = Object.create(null)),
        (this.throwOnSyntheticProps = !0),
        (this.destroyNode = null);
    }
    destroy() {}
    createElement(e, t) {
      return t
        ? this.doc.createElementNS(Mm[t] || t, e)
        : this.doc.createElement(e);
    }
    createComment(e) {
      return this.doc.createComment(e);
    }
    createText(e) {
      return this.doc.createTextNode(e);
    }
    appendChild(e, t) {
      (b1(e) ? e.content : e).appendChild(t);
    }
    insertBefore(e, t, r) {
      e && (b1(e) ? e.content : e).insertBefore(t, r);
    }
    removeChild(e, t) {
      t.remove();
    }
    selectRootElement(e, t) {
      let r = typeof e == "string" ? this.doc.querySelector(e) : e;
      if (!r) throw new rt(-5104, !1);
      return t || (r.textContent = ""), r;
    }
    parentNode(e) {
      return e.parentNode;
    }
    nextSibling(e) {
      return e.nextSibling;
    }
    setAttribute(e, t, r, i) {
      if (i) {
        t = i + ":" + t;
        let s = Mm[i];
        s ? e.setAttributeNS(s, t, r) : e.setAttribute(t, r);
      } else e.setAttribute(t, r);
    }
    removeAttribute(e, t, r) {
      if (r) {
        let i = Mm[r];
        i ? e.removeAttributeNS(i, t) : e.removeAttribute(`${r}:${t}`);
      } else e.removeAttribute(t);
    }
    addClass(e, t) {
      e.classList.add(t);
    }
    removeClass(e, t) {
      e.classList.remove(t);
    }
    setStyle(e, t, r, i) {
      i & (ro.DashCase | ro.Important)
        ? e.style.setProperty(t, r, i & ro.Important ? "important" : "")
        : (e.style[t] = r);
    }
    removeStyle(e, t, r) {
      r & ro.DashCase ? e.style.removeProperty(t) : (e.style[t] = "");
    }
    setProperty(e, t, r) {
      e != null && (e[t] = r);
    }
    setValue(e, t) {
      e.nodeValue = t;
    }
    listen(e, t, r) {
      if (
        typeof e == "string" &&
        ((e = Aa().getGlobalEventTarget(this.doc, e)), !e)
      )
        throw new Error(`Unsupported event target ${e} for event ${t}`);
      return this.eventManager.addEventListener(
        e,
        t,
        this.decoratePreventDefault(r)
      );
    }
    decoratePreventDefault(e) {
      return (t) => {
        if (t === "__ngUnwrap__") return e;
        (this.platformIsServer ? this.ngZone.runGuarded(() => e(t)) : e(t)) ===
          !1 && t.preventDefault();
      };
    }
  };
function b1(n) {
  return n.tagName === "TEMPLATE" && n.content !== void 0;
}
var Wm = class extends Fu {
    constructor(e, t, r, i, s, o, a, c) {
      super(e, s, o, c),
        (this.sharedStylesHost = t),
        (this.hostEl = r),
        (this.shadowRoot = r.attachShadow({ mode: "open" })),
        this.sharedStylesHost.addHost(this.shadowRoot);
      let u = v1(i.id, i.styles);
      for (let l of u) {
        let h = document.createElement("style");
        a && h.setAttribute("nonce", a),
          (h.textContent = l),
          this.shadowRoot.appendChild(h);
      }
    }
    nodeOrShadowRoot(e) {
      return e === this.hostEl ? this.shadowRoot : e;
    }
    appendChild(e, t) {
      return super.appendChild(this.nodeOrShadowRoot(e), t);
    }
    insertBefore(e, t, r) {
      return super.insertBefore(this.nodeOrShadowRoot(e), t, r);
    }
    removeChild(e, t) {
      return super.removeChild(null, t);
    }
    parentNode(e) {
      return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)));
    }
    destroy() {
      this.sharedStylesHost.removeHost(this.shadowRoot);
    }
  },
  Mu = class extends Fu {
    constructor(e, t, r, i, s, o, a, c) {
      super(e, s, o, a),
        (this.sharedStylesHost = t),
        (this.removeStylesOnCompDestroy = i),
        (this.styles = c ? v1(c, r.styles) : r.styles);
    }
    applyStyles() {
      this.sharedStylesHost.addStyles(this.styles);
    }
    destroy() {
      this.removeStylesOnCompDestroy &&
        this.sharedStylesHost.removeStyles(this.styles);
    }
  },
  ef = class extends Mu {
    constructor(e, t, r, i, s, o, a, c) {
      let u = i + "-" + r.id;
      super(e, t, r, s, o, a, c, u),
        (this.contentAttr = a_(u)),
        (this.hostAttr = c_(u));
    }
    applyToHost(e) {
      this.applyStyles(), this.setAttribute(e, this.hostAttr, "");
    }
    createElement(e, t) {
      let r = super.createElement(e, t);
      return super.setAttribute(r, this.contentAttr, ""), r;
    }
  },
  u_ = (() => {
    class n extends Xh {
      constructor(t) {
        super(t);
      }
      supports(t) {
        return !0;
      }
      addEventListener(t, r, i) {
        return (
          t.addEventListener(r, i, !1), () => this.removeEventListener(t, r, i)
        );
      }
      removeEventListener(t, r, i) {
        return t.removeEventListener(r, i);
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Vt));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })(),
  A1 = ["alt", "control", "meta", "shift"],
  l_ = {
    "\b": "Backspace",
    "	": "Tab",
    "\x7F": "Delete",
    "\x1B": "Escape",
    Del: "Delete",
    Esc: "Escape",
    Left: "ArrowLeft",
    Right: "ArrowRight",
    Up: "ArrowUp",
    Down: "ArrowDown",
    Menu: "ContextMenu",
    Scroll: "ScrollLock",
    Win: "OS",
  },
  h_ = {
    alt: (n) => n.altKey,
    control: (n) => n.ctrlKey,
    meta: (n) => n.metaKey,
    shift: (n) => n.shiftKey,
  },
  f_ = (() => {
    class n extends Xh {
      constructor(t) {
        super(t);
      }
      supports(t) {
        return n.parseEventName(t) != null;
      }
      addEventListener(t, r, i) {
        let s = n.parseEventName(r),
          o = n.eventCallback(s.fullKey, i, this.manager.getZone());
        return this.manager
          .getZone()
          .runOutsideAngular(() => Aa().onAndCancel(t, s.domEventName, o));
      }
      static parseEventName(t) {
        let r = t.toLowerCase().split("."),
          i = r.shift();
        if (r.length === 0 || !(i === "keydown" || i === "keyup")) return null;
        let s = n._normalizeKey(r.pop()),
          o = "",
          a = r.indexOf("code");
        if (
          (a > -1 && (r.splice(a, 1), (o = "code.")),
          A1.forEach((u) => {
            let l = r.indexOf(u);
            l > -1 && (r.splice(l, 1), (o += u + "."));
          }),
          (o += s),
          r.length != 0 || s.length === 0)
        )
          return null;
        let c = {};
        return (c.domEventName = i), (c.fullKey = o), c;
      }
      static matchEventFullKeyCode(t, r) {
        let i = l_[t.key] || t.key,
          s = "";
        return (
          r.indexOf("code.") > -1 && ((i = t.code), (s = "code.")),
          i == null || !i
            ? !1
            : ((i = i.toLowerCase()),
              i === " " ? (i = "space") : i === "." && (i = "dot"),
              A1.forEach((o) => {
                if (o !== i) {
                  let a = h_[o];
                  a(t) && (s += o + ".");
                }
              }),
              (s += i),
              s === r)
        );
      }
      static eventCallback(t, r, i) {
        return (s) => {
          n.matchEventFullKeyCode(s, t) && i.runGuarded(() => r(s));
        };
      }
      static _normalizeKey(t) {
        return t === "esc" ? "escape" : t;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Vt));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })();
function bH(n, e) {
  return LE(v({ rootComponent: n }, d_(e)));
}
function d_(n) {
  return {
    appProviders: [...w_, ...(n?.providers ?? [])],
    platformProviders: y_,
  };
}
function p_() {
  zm.makeCurrent();
}
function g_() {
  return new rm();
}
function m_() {
  return oE(document), document;
}
var y_ = [
  { provide: Vr, useValue: Rm },
  { provide: aE, useValue: p_, multi: !0 },
  { provide: Vt, useFactory: m_, deps: [] },
];
var w_ = [
  { provide: rE, useValue: "root" },
  { provide: rm, useFactory: g_, deps: [] },
  { provide: jm, useClass: u_, multi: !0, deps: [Vt, Kn, Vr] },
  { provide: jm, useClass: f_, multi: !0, deps: [Vt] },
  w1,
  x1,
  E1,
  { provide: AE, useExisting: w1 },
  { provide: Ea, useClass: n_, deps: [] },
  [],
];
var I1 = (() => {
  class n {
    constructor(t) {
      this._doc = t;
    }
    getTitle() {
      return this._doc.title;
    }
    setTitle(t) {
      this._doc.title = t || "";
    }
    static {
      this.ɵfac = function (r) {
        return new (r || n)(le(Vt));
      };
    }
    static {
      this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
    }
  }
  return n;
})();
var b_ = (() => {
    class n {
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({
          token: n,
          factory: function (r) {
            let i = null;
            return r ? (i = new (r || n)()) : (i = le(A_)), i;
          },
          providedIn: "root",
        });
      }
    }
    return n;
  })(),
  A_ = (() => {
    class n extends b_ {
      constructor(t) {
        super(), (this._doc = t);
      }
      sanitize(t, r) {
        if (r == null) return null;
        switch (t) {
          case no.NONE:
            return r;
          case no.HTML:
            return ga(r, "HTML") ? ts(r) : mE(this._doc, String(r)).toString();
          case no.STYLE:
            return ga(r, "Style") ? ts(r) : r;
          case no.SCRIPT:
            if (ga(r, "Script")) return ts(r);
            throw new rt(5200, !1);
          case no.URL:
            return ga(r, "URL") ? ts(r) : gE(String(r));
          case no.RESOURCE_URL:
            if (ga(r, "ResourceURL")) return ts(r);
            throw new rt(5201, !1);
          default:
            throw new rt(5202, !1);
        }
      }
      bypassSecurityTrustHtml(t) {
        return lE(t);
      }
      bypassSecurityTrustStyle(t) {
        return hE(t);
      }
      bypassSecurityTrustScript(t) {
        return fE(t);
      }
      bypassSecurityTrustUrl(t) {
        return dE(t);
      }
      bypassSecurityTrustResourceUrl(t) {
        return pE(t);
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Vt));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })();
p();
var Ce = "primary",
  Xu = Symbol("RouteTitle"),
  qm = class {
    constructor(e) {
      this.params = e || {};
    }
    has(e) {
      return Object.prototype.hasOwnProperty.call(this.params, e);
    }
    get(e) {
      if (this.has(e)) {
        let t = this.params[e];
        return Array.isArray(t) ? t[0] : t;
      }
      return null;
    }
    getAll(e) {
      if (this.has(e)) {
        let t = this.params[e];
        return Array.isArray(t) ? t : [t];
      }
      return [];
    }
    get keys() {
      return Object.keys(this.params);
    }
  };
function Ra(n) {
  return new qm(n);
}
function x_(n, e, t) {
  let r = t.path.split("/");
  if (
    r.length > n.length ||
    (t.pathMatch === "full" && (e.hasChildren() || r.length < n.length))
  )
    return null;
  let i = {};
  for (let s = 0; s < r.length; s++) {
    let o = r[s],
      a = n[s];
    if (o[0] === ":") i[o.substring(1)] = a;
    else if (o !== a.path) return null;
  }
  return { consumed: n.slice(0, r.length), posParams: i };
}
function S_(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0; t < n.length; ++t) if (!Gr(n[t], e[t])) return !1;
  return !0;
}
function Gr(n, e) {
  let t = n ? Qm(n) : void 0,
    r = e ? Qm(e) : void 0;
  if (!t || !r || t.length != r.length) return !1;
  let i;
  for (let s = 0; s < t.length; s++)
    if (((i = t[s]), !N1(n[i], e[i]))) return !1;
  return !0;
}
function Qm(n) {
  return [...Object.keys(n), ...Object.getOwnPropertySymbols(n)];
}
function N1(n, e) {
  if (Array.isArray(n) && Array.isArray(e)) {
    if (n.length !== e.length) return !1;
    let t = [...n].sort(),
      r = [...e].sort();
    return t.every((i, s) => r[s] === i);
  } else return n === e;
}
function F1(n) {
  return n.length > 0 ? n[n.length - 1] : null;
}
function us(n) {
  return Su(n) ? n : Nh(n) ? Ke(Promise.resolve(n)) : oe(n);
}
var v_ = { exact: U1, subset: z1 },
  M1 = { exact: I_, subset: C_, ignored: () => !0 };
function C1(n, e, t) {
  return (
    v_[t.paths](n.root, e.root, t.matrixParams) &&
    M1[t.queryParams](n.queryParams, e.queryParams) &&
    !(t.fragment === "exact" && n.fragment !== e.fragment)
  );
}
function I_(n, e) {
  return Gr(n, e);
}
function U1(n, e, t) {
  if (
    !so(n.segments, e.segments) ||
    !rf(n.segments, e.segments, t) ||
    n.numberOfChildren !== e.numberOfChildren
  )
    return !1;
  for (let r in e.children)
    if (!n.children[r] || !U1(n.children[r], e.children[r], t)) return !1;
  return !0;
}
function C_(n, e) {
  return (
    Object.keys(e).length <= Object.keys(n).length &&
    Object.keys(e).every((t) => N1(n[t], e[t]))
  );
}
function z1(n, e, t) {
  return j1(n, e, e.segments, t);
}
function j1(n, e, t, r) {
  if (n.segments.length > t.length) {
    let i = n.segments.slice(0, t.length);
    return !(!so(i, t) || e.hasChildren() || !rf(i, t, r));
  } else if (n.segments.length === t.length) {
    if (!so(n.segments, t) || !rf(n.segments, t, r)) return !1;
    for (let i in e.children)
      if (!n.children[i] || !z1(n.children[i], e.children[i], r)) return !1;
    return !0;
  } else {
    let i = t.slice(0, n.segments.length),
      s = t.slice(n.segments.length);
    return !so(n.segments, i) || !rf(n.segments, i, r) || !n.children[Ce]
      ? !1
      : j1(n.children[Ce], e, s, r);
  }
}
function rf(n, e, t) {
  return e.every((r, i) => M1[t](n[i].parameters, r.parameters));
}
var vi = class {
    constructor(e = new Je([], {}), t = {}, r = null) {
      (this.root = e), (this.queryParams = t), (this.fragment = r);
    }
    get queryParamMap() {
      return (
        (this._queryParamMap ??= Ra(this.queryParams)), this._queryParamMap
      );
    }
    toString() {
      return R_.serialize(this);
    }
  },
  Je = class {
    constructor(e, t) {
      (this.segments = e),
        (this.children = t),
        (this.parent = null),
        Object.values(t).forEach((r) => (r.parent = this));
    }
    hasChildren() {
      return this.numberOfChildren > 0;
    }
    get numberOfChildren() {
      return Object.keys(this.children).length;
    }
    toString() {
      return sf(this);
    }
  },
  io = class {
    constructor(e, t) {
      (this.path = e), (this.parameters = t);
    }
    get parameterMap() {
      return (this._parameterMap ??= Ra(this.parameters)), this._parameterMap;
    }
    toString() {
      return H1(this);
    }
  };
function k_(n, e) {
  return so(n, e) && n.every((t, r) => Gr(t.parameters, e[r].parameters));
}
function so(n, e) {
  return n.length !== e.length ? !1 : n.every((t, r) => t.path === e[r].path);
}
function T_(n, e) {
  let t = [];
  return (
    Object.entries(n.children).forEach(([r, i]) => {
      r === Ce && (t = t.concat(e(i, r)));
    }),
    Object.entries(n.children).forEach(([r, i]) => {
      r !== Ce && (t = t.concat(e(i, r)));
    }),
    t
  );
}
var La = (() => {
    class n {
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({
          token: n,
          factory: () => new Ba(),
          providedIn: "root",
        });
      }
    }
    return n;
  })(),
  Ba = class {
    parse(e) {
      let t = new Ym(e);
      return new vi(
        t.parseRootSegment(),
        t.parseQueryParams(),
        t.parseFragment()
      );
    }
    serialize(e) {
      let t = `/${Uu(e.root, !0)}`,
        r = __(e.queryParams),
        i = typeof e.fragment == "string" ? `#${B_(e.fragment)}` : "";
      return `${t}${r}${i}`;
    }
  },
  R_ = new Ba();
function sf(n) {
  return n.segments.map((e) => H1(e)).join("/");
}
function Uu(n, e) {
  if (!n.hasChildren()) return sf(n);
  if (e) {
    let t = n.children[Ce] ? Uu(n.children[Ce], !1) : "",
      r = [];
    return (
      Object.entries(n.children).forEach(([i, s]) => {
        i !== Ce && r.push(`${i}:${Uu(s, !1)}`);
      }),
      r.length > 0 ? `${t}(${r.join("//")})` : t
    );
  } else {
    let t = T_(n, (r, i) =>
      i === Ce ? [Uu(n.children[Ce], !1)] : [`${i}:${Uu(r, !1)}`]
    );
    return Object.keys(n.children).length === 1 && n.children[Ce] != null
      ? `${sf(n)}/${t[0]}`
      : `${sf(n)}/(${t.join("//")})`;
  }
}
function W1(n) {
  return encodeURIComponent(n)
    .replace(/%40/g, "@")
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",");
}
function tf(n) {
  return W1(n).replace(/%3B/gi, ";");
}
function B_(n) {
  return encodeURI(n);
}
function Jm(n) {
  return W1(n)
    .replace(/\(/g, "%28")
    .replace(/\)/g, "%29")
    .replace(/%26/gi, "&");
}
function of(n) {
  return decodeURIComponent(n);
}
function k1(n) {
  return of(n.replace(/\+/g, "%20"));
}
function H1(n) {
  return `${Jm(n.path)}${D_(n.parameters)}`;
}
function D_(n) {
  return Object.entries(n)
    .map(([e, t]) => `;${Jm(e)}=${Jm(t)}`)
    .join("");
}
function __(n) {
  let e = Object.entries(n)
    .map(([t, r]) =>
      Array.isArray(r)
        ? r.map((i) => `${tf(t)}=${tf(i)}`).join("&")
        : `${tf(t)}=${tf(r)}`
    )
    .filter((t) => t);
  return e.length ? `?${e.join("&")}` : "";
}
var P_ = /^[^\/()?;#]+/;
function Vm(n) {
  let e = n.match(P_);
  return e ? e[0] : "";
}
var L_ = /^[^\/()?;=#]+/;
function O_(n) {
  let e = n.match(L_);
  return e ? e[0] : "";
}
var N_ = /^[^=?&#]+/;
function F_(n) {
  let e = n.match(N_);
  return e ? e[0] : "";
}
var M_ = /^[^&#]+/;
function U_(n) {
  let e = n.match(M_);
  return e ? e[0] : "";
}
var Ym = class {
  constructor(e) {
    (this.url = e), (this.remaining = e);
  }
  parseRootSegment() {
    return (
      this.consumeOptional("/"),
      this.remaining === "" ||
      this.peekStartsWith("?") ||
      this.peekStartsWith("#")
        ? new Je([], {})
        : new Je([], this.parseChildren())
    );
  }
  parseQueryParams() {
    let e = {};
    if (this.consumeOptional("?"))
      do this.parseQueryParam(e);
      while (this.consumeOptional("&"));
    return e;
  }
  parseFragment() {
    return this.consumeOptional("#")
      ? decodeURIComponent(this.remaining)
      : null;
  }
  parseChildren() {
    if (this.remaining === "") return {};
    this.consumeOptional("/");
    let e = [];
    for (
      this.peekStartsWith("(") || e.push(this.parseSegment());
      this.peekStartsWith("/") &&
      !this.peekStartsWith("//") &&
      !this.peekStartsWith("/(");

    )
      this.capture("/"), e.push(this.parseSegment());
    let t = {};
    this.peekStartsWith("/(") &&
      (this.capture("/"), (t = this.parseParens(!0)));
    let r = {};
    return (
      this.peekStartsWith("(") && (r = this.parseParens(!1)),
      (e.length > 0 || Object.keys(t).length > 0) && (r[Ce] = new Je(e, t)),
      r
    );
  }
  parseSegment() {
    let e = Vm(this.remaining);
    if (e === "" && this.peekStartsWith(";")) throw new rt(4009, !1);
    return this.capture(e), new io(of(e), this.parseMatrixParams());
  }
  parseMatrixParams() {
    let e = {};
    for (; this.consumeOptional(";"); ) this.parseParam(e);
    return e;
  }
  parseParam(e) {
    let t = O_(this.remaining);
    if (!t) return;
    this.capture(t);
    let r = "";
    if (this.consumeOptional("=")) {
      let i = Vm(this.remaining);
      i && ((r = i), this.capture(r));
    }
    e[of(t)] = of(r);
  }
  parseQueryParam(e) {
    let t = F_(this.remaining);
    if (!t) return;
    this.capture(t);
    let r = "";
    if (this.consumeOptional("=")) {
      let o = U_(this.remaining);
      o && ((r = o), this.capture(r));
    }
    let i = k1(t),
      s = k1(r);
    if (e.hasOwnProperty(i)) {
      let o = e[i];
      Array.isArray(o) || ((o = [o]), (e[i] = o)), o.push(s);
    } else e[i] = s;
  }
  parseParens(e) {
    let t = {};
    for (
      this.capture("(");
      !this.consumeOptional(")") && this.remaining.length > 0;

    ) {
      let r = Vm(this.remaining),
        i = this.remaining[r.length];
      if (i !== "/" && i !== ")" && i !== ";") throw new rt(4010, !1);
      let s;
      r.indexOf(":") > -1
        ? ((s = r.slice(0, r.indexOf(":"))), this.capture(s), this.capture(":"))
        : e && (s = Ce);
      let o = this.parseChildren();
      (t[s] = Object.keys(o).length === 1 ? o[Ce] : new Je([], o)),
        this.consumeOptional("//");
    }
    return t;
  }
  peekStartsWith(e) {
    return this.remaining.startsWith(e);
  }
  consumeOptional(e) {
    return this.peekStartsWith(e)
      ? ((this.remaining = this.remaining.substring(e.length)), !0)
      : !1;
  }
  capture(e) {
    if (!this.consumeOptional(e)) throw new rt(4011, !1);
  }
};
function V1(n) {
  return n.segments.length > 0 ? new Je([], { [Ce]: n }) : n;
}
function $1(n) {
  let e = {};
  for (let [r, i] of Object.entries(n.children)) {
    let s = $1(i);
    if (r === Ce && s.segments.length === 0 && s.hasChildren())
      for (let [o, a] of Object.entries(s.children)) e[o] = a;
    else (s.segments.length > 0 || s.hasChildren()) && (e[r] = s);
  }
  let t = new Je(n.segments, e);
  return z_(t);
}
function z_(n) {
  if (n.numberOfChildren === 1 && n.children[Ce]) {
    let e = n.children[Ce];
    return new Je(n.segments.concat(e.segments), e.children);
  }
  return n;
}
function oo(n) {
  return n instanceof vi;
}
function j_(n, e, t = null, r = null) {
  let i = G1(n);
  return K1(i, e, t, r);
}
function G1(n) {
  let e;
  function t(s) {
    let o = {};
    for (let c of s.children) {
      let u = t(c);
      o[c.outlet] = u;
    }
    let a = new Je(s.url, o);
    return s === n && (e = a), a;
  }
  let r = t(n.root),
    i = V1(r);
  return e ?? i;
}
function K1(n, e, t, r) {
  let i = n;
  for (; i.parent; ) i = i.parent;
  if (e.length === 0) return $m(i, i, i, t, r);
  let s = W_(e);
  if (s.toRoot()) return $m(i, i, new Je([], {}), t, r);
  let o = H_(s, i, n),
    a = o.processChildren
      ? Wu(o.segmentGroup, o.index, s.commands)
      : Q1(o.segmentGroup, o.index, s.commands);
  return $m(i, o.segmentGroup, a, t, r);
}
function af(n) {
  return typeof n == "object" && n != null && !n.outlets && !n.segmentPath;
}
function $u(n) {
  return typeof n == "object" && n != null && n.outlets;
}
function $m(n, e, t, r, i) {
  let s = {};
  r &&
    Object.entries(r).forEach(([c, u]) => {
      s[c] = Array.isArray(u) ? u.map((l) => `${l}`) : `${u}`;
    });
  let o;
  n === e ? (o = t) : (o = q1(n, e, t));
  let a = V1($1(o));
  return new vi(a, s, i);
}
function q1(n, e, t) {
  let r = {};
  return (
    Object.entries(n.children).forEach(([i, s]) => {
      s === e ? (r[i] = t) : (r[i] = q1(s, e, t));
    }),
    new Je(n.segments, r)
  );
}
var cf = class {
  constructor(e, t, r) {
    if (
      ((this.isAbsolute = e),
      (this.numberOfDoubleDots = t),
      (this.commands = r),
      e && r.length > 0 && af(r[0]))
    )
      throw new rt(4003, !1);
    let i = r.find($u);
    if (i && i !== F1(r)) throw new rt(4004, !1);
  }
  toRoot() {
    return (
      this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/"
    );
  }
};
function W_(n) {
  if (typeof n[0] == "string" && n.length === 1 && n[0] === "/")
    return new cf(!0, 0, n);
  let e = 0,
    t = !1,
    r = n.reduce((i, s, o) => {
      if (typeof s == "object" && s != null) {
        if (s.outlets) {
          let a = {};
          return (
            Object.entries(s.outlets).forEach(([c, u]) => {
              a[c] = typeof u == "string" ? u.split("/") : u;
            }),
            [...i, { outlets: a }]
          );
        }
        if (s.segmentPath) return [...i, s.segmentPath];
      }
      return typeof s != "string"
        ? [...i, s]
        : o === 0
        ? (s.split("/").forEach((a, c) => {
            (c == 0 && a === ".") ||
              (c == 0 && a === ""
                ? (t = !0)
                : a === ".."
                ? e++
                : a != "" && i.push(a));
          }),
          i)
        : [...i, s];
    }, []);
  return new cf(t, e, r);
}
var Ca = class {
  constructor(e, t, r) {
    (this.segmentGroup = e), (this.processChildren = t), (this.index = r);
  }
};
function H_(n, e, t) {
  if (n.isAbsolute) return new Ca(e, !0, 0);
  if (!t) return new Ca(e, !1, NaN);
  if (t.parent === null) return new Ca(t, !0, 0);
  let r = af(n.commands[0]) ? 0 : 1,
    i = t.segments.length - 1 + r;
  return V_(t, i, n.numberOfDoubleDots);
}
function V_(n, e, t) {
  let r = n,
    i = e,
    s = t;
  for (; s > i; ) {
    if (((s -= i), (r = r.parent), !r)) throw new rt(4005, !1);
    i = r.segments.length;
  }
  return new Ca(r, !1, i - s);
}
function $_(n) {
  return $u(n[0]) ? n[0].outlets : { [Ce]: n };
}
function Q1(n, e, t) {
  if (((n ??= new Je([], {})), n.segments.length === 0 && n.hasChildren()))
    return Wu(n, e, t);
  let r = G_(n, e, t),
    i = t.slice(r.commandIndex);
  if (r.match && r.pathIndex < n.segments.length) {
    let s = new Je(n.segments.slice(0, r.pathIndex), {});
    return (
      (s.children[Ce] = new Je(n.segments.slice(r.pathIndex), n.children)),
      Wu(s, 0, i)
    );
  } else
    return r.match && i.length === 0
      ? new Je(n.segments, {})
      : r.match && !n.hasChildren()
      ? Zm(n, e, t)
      : r.match
      ? Wu(n, 0, i)
      : Zm(n, e, t);
}
function Wu(n, e, t) {
  if (t.length === 0) return new Je(n.segments, {});
  {
    let r = $_(t),
      i = {};
    if (
      Object.keys(r).some((s) => s !== Ce) &&
      n.children[Ce] &&
      n.numberOfChildren === 1 &&
      n.children[Ce].segments.length === 0
    ) {
      let s = Wu(n.children[Ce], e, t);
      return new Je(n.segments, s.children);
    }
    return (
      Object.entries(r).forEach(([s, o]) => {
        typeof o == "string" && (o = [o]),
          o !== null && (i[s] = Q1(n.children[s], e, o));
      }),
      Object.entries(n.children).forEach(([s, o]) => {
        r[s] === void 0 && (i[s] = o);
      }),
      new Je(n.segments, i)
    );
  }
}
function G_(n, e, t) {
  let r = 0,
    i = e,
    s = { match: !1, pathIndex: 0, commandIndex: 0 };
  for (; i < n.segments.length; ) {
    if (r >= t.length) return s;
    let o = n.segments[i],
      a = t[r];
    if ($u(a)) break;
    let c = `${a}`,
      u = r < t.length - 1 ? t[r + 1] : null;
    if (i > 0 && c === void 0) break;
    if (c && u && typeof u == "object" && u.outlets === void 0) {
      if (!R1(c, u, o)) return s;
      r += 2;
    } else {
      if (!R1(c, {}, o)) return s;
      r++;
    }
    i++;
  }
  return { match: !0, pathIndex: i, commandIndex: r };
}
function Zm(n, e, t) {
  let r = n.segments.slice(0, e),
    i = 0;
  for (; i < t.length; ) {
    let s = t[i];
    if ($u(s)) {
      let c = K_(s.outlets);
      return new Je(r, c);
    }
    if (i === 0 && af(t[0])) {
      let c = n.segments[e];
      r.push(new io(c.path, T1(t[0]))), i++;
      continue;
    }
    let o = $u(s) ? s.outlets[Ce] : `${s}`,
      a = i < t.length - 1 ? t[i + 1] : null;
    o && a && af(a)
      ? (r.push(new io(o, T1(a))), (i += 2))
      : (r.push(new io(o, {})), i++);
  }
  return new Je(r, {});
}
function K_(n) {
  let e = {};
  return (
    Object.entries(n).forEach(([t, r]) => {
      typeof r == "string" && (r = [r]),
        r !== null && (e[t] = Zm(new Je([], {}), 0, r));
    }),
    e
  );
}
function T1(n) {
  let e = {};
  return Object.entries(n).forEach(([t, r]) => (e[t] = `${r}`)), e;
}
function R1(n, e, t) {
  return n == t.path && Gr(e, t.parameters);
}
var Hu = "imperative",
  $t = (function (n) {
    return (
      (n[(n.NavigationStart = 0)] = "NavigationStart"),
      (n[(n.NavigationEnd = 1)] = "NavigationEnd"),
      (n[(n.NavigationCancel = 2)] = "NavigationCancel"),
      (n[(n.NavigationError = 3)] = "NavigationError"),
      (n[(n.RoutesRecognized = 4)] = "RoutesRecognized"),
      (n[(n.ResolveStart = 5)] = "ResolveStart"),
      (n[(n.ResolveEnd = 6)] = "ResolveEnd"),
      (n[(n.GuardsCheckStart = 7)] = "GuardsCheckStart"),
      (n[(n.GuardsCheckEnd = 8)] = "GuardsCheckEnd"),
      (n[(n.RouteConfigLoadStart = 9)] = "RouteConfigLoadStart"),
      (n[(n.RouteConfigLoadEnd = 10)] = "RouteConfigLoadEnd"),
      (n[(n.ChildActivationStart = 11)] = "ChildActivationStart"),
      (n[(n.ChildActivationEnd = 12)] = "ChildActivationEnd"),
      (n[(n.ActivationStart = 13)] = "ActivationStart"),
      (n[(n.ActivationEnd = 14)] = "ActivationEnd"),
      (n[(n.Scroll = 15)] = "Scroll"),
      (n[(n.NavigationSkipped = 16)] = "NavigationSkipped"),
      n
    );
  })($t || {}),
  lr = class {
    constructor(e, t) {
      (this.id = e), (this.url = t);
    }
  },
  Da = class extends lr {
    constructor(e, t, r = "imperative", i = null) {
      super(e, t),
        (this.type = $t.NavigationStart),
        (this.navigationTrigger = r),
        (this.restoredState = i);
    }
    toString() {
      return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
    }
  },
  Kr = class extends lr {
    constructor(e, t, r) {
      super(e, t), (this.urlAfterRedirects = r), (this.type = $t.NavigationEnd);
    }
    toString() {
      return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
    }
  },
  Qn = (function (n) {
    return (
      (n[(n.Redirect = 0)] = "Redirect"),
      (n[(n.SupersededByNewNavigation = 1)] = "SupersededByNewNavigation"),
      (n[(n.NoDataFromResolver = 2)] = "NoDataFromResolver"),
      (n[(n.GuardRejected = 3)] = "GuardRejected"),
      n
    );
  })(Qn || {}),
  uf = (function (n) {
    return (
      (n[(n.IgnoredSameUrlNavigation = 0)] = "IgnoredSameUrlNavigation"),
      (n[(n.IgnoredByUrlHandlingStrategy = 1)] =
        "IgnoredByUrlHandlingStrategy"),
      n
    );
  })(uf || {}),
  Si = class extends lr {
    constructor(e, t, r, i) {
      super(e, t),
        (this.reason = r),
        (this.code = i),
        (this.type = $t.NavigationCancel);
    }
    toString() {
      return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
    }
  },
  as = class extends lr {
    constructor(e, t, r, i) {
      super(e, t),
        (this.reason = r),
        (this.code = i),
        (this.type = $t.NavigationSkipped);
    }
  },
  Gu = class extends lr {
    constructor(e, t, r, i) {
      super(e, t),
        (this.error = r),
        (this.target = i),
        (this.type = $t.NavigationError);
    }
    toString() {
      return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
    }
  },
  lf = class extends lr {
    constructor(e, t, r, i) {
      super(e, t),
        (this.urlAfterRedirects = r),
        (this.state = i),
        (this.type = $t.RoutesRecognized);
    }
    toString() {
      return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
    }
  },
  Xm = class extends lr {
    constructor(e, t, r, i) {
      super(e, t),
        (this.urlAfterRedirects = r),
        (this.state = i),
        (this.type = $t.GuardsCheckStart);
    }
    toString() {
      return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
    }
  },
  e0 = class extends lr {
    constructor(e, t, r, i, s) {
      super(e, t),
        (this.urlAfterRedirects = r),
        (this.state = i),
        (this.shouldActivate = s),
        (this.type = $t.GuardsCheckEnd);
    }
    toString() {
      return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
    }
  },
  t0 = class extends lr {
    constructor(e, t, r, i) {
      super(e, t),
        (this.urlAfterRedirects = r),
        (this.state = i),
        (this.type = $t.ResolveStart);
    }
    toString() {
      return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
    }
  },
  n0 = class extends lr {
    constructor(e, t, r, i) {
      super(e, t),
        (this.urlAfterRedirects = r),
        (this.state = i),
        (this.type = $t.ResolveEnd);
    }
    toString() {
      return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
    }
  },
  r0 = class {
    constructor(e) {
      (this.route = e), (this.type = $t.RouteConfigLoadStart);
    }
    toString() {
      return `RouteConfigLoadStart(path: ${this.route.path})`;
    }
  },
  i0 = class {
    constructor(e) {
      (this.route = e), (this.type = $t.RouteConfigLoadEnd);
    }
    toString() {
      return `RouteConfigLoadEnd(path: ${this.route.path})`;
    }
  },
  s0 = class {
    constructor(e) {
      (this.snapshot = e), (this.type = $t.ChildActivationStart);
    }
    toString() {
      return `ChildActivationStart(path: '${
        (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
      }')`;
    }
  },
  o0 = class {
    constructor(e) {
      (this.snapshot = e), (this.type = $t.ChildActivationEnd);
    }
    toString() {
      return `ChildActivationEnd(path: '${
        (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
      }')`;
    }
  },
  a0 = class {
    constructor(e) {
      (this.snapshot = e), (this.type = $t.ActivationStart);
    }
    toString() {
      return `ActivationStart(path: '${
        (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
      }')`;
    }
  },
  c0 = class {
    constructor(e) {
      (this.snapshot = e), (this.type = $t.ActivationEnd);
    }
    toString() {
      return `ActivationEnd(path: '${
        (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
      }')`;
    }
  },
  hf = class {
    constructor(e, t, r) {
      (this.routerEvent = e),
        (this.position = t),
        (this.anchor = r),
        (this.type = $t.Scroll);
    }
    toString() {
      let e = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
      return `Scroll(anchor: '${this.anchor}', position: '${e}')`;
    }
  },
  Ku = class {},
  _a = class {
    constructor(e, t) {
      (this.url = e), (this.navigationBehaviorOptions = t);
    }
  };
function q_(n, e) {
  return (
    n.providers &&
      !n._injector &&
      (n._injector = am(n.providers, e, `Route: ${n.path}`)),
    n._injector ?? e
  );
}
function Ar(n) {
  return n.outlet || Ce;
}
function Q_(n, e) {
  let t = n.filter((r) => Ar(r) === e);
  return t.push(...n.filter((r) => Ar(r) !== e)), t;
}
function el(n) {
  if (!n) return null;
  if (n.routeConfig?._injector) return n.routeConfig._injector;
  for (let e = n.parent; e; e = e.parent) {
    let t = e.routeConfig;
    if (t?._loadedInjector) return t._loadedInjector;
    if (t?._injector) return t._injector;
  }
  return null;
}
var u0 = class {
    get injector() {
      return el(this.route?.snapshot) ?? this.rootInjector;
    }
    set injector(e) {}
    constructor(e) {
      (this.rootInjector = e),
        (this.outlet = null),
        (this.route = null),
        (this.children = new tl(this.rootInjector)),
        (this.attachRef = null);
    }
  },
  tl = (() => {
    class n {
      constructor(t) {
        (this.rootInjector = t), (this.contexts = new Map());
      }
      onChildOutletCreated(t, r) {
        let i = this.getOrCreateContext(t);
        (i.outlet = r), this.contexts.set(t, i);
      }
      onChildOutletDestroyed(t) {
        let r = this.getContext(t);
        r && ((r.outlet = null), (r.attachRef = null));
      }
      onOutletDeactivated() {
        let t = this.contexts;
        return (this.contexts = new Map()), t;
      }
      onOutletReAttached(t) {
        this.contexts = t;
      }
      getOrCreateContext(t) {
        let r = this.getContext(t);
        return (
          r || ((r = new u0(this.rootInjector)), this.contexts.set(t, r)), r
        );
      }
      getContext(t) {
        return this.contexts.get(t) || null;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(eo));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })(),
  ff = class {
    constructor(e) {
      this._root = e;
    }
    get root() {
      return this._root.value;
    }
    parent(e) {
      let t = this.pathFromRoot(e);
      return t.length > 1 ? t[t.length - 2] : null;
    }
    children(e) {
      let t = l0(e, this._root);
      return t ? t.children.map((r) => r.value) : [];
    }
    firstChild(e) {
      let t = l0(e, this._root);
      return t && t.children.length > 0 ? t.children[0].value : null;
    }
    siblings(e) {
      let t = h0(e, this._root);
      return t.length < 2
        ? []
        : t[t.length - 2].children.map((i) => i.value).filter((i) => i !== e);
    }
    pathFromRoot(e) {
      return h0(e, this._root).map((t) => t.value);
    }
  };
function l0(n, e) {
  if (n === e.value) return e;
  for (let t of e.children) {
    let r = l0(n, t);
    if (r) return r;
  }
  return null;
}
function h0(n, e) {
  if (n === e.value) return [e];
  for (let t of e.children) {
    let r = h0(n, t);
    if (r.length) return r.unshift(e), r;
  }
  return [];
}
var qn = class {
  constructor(e, t) {
    (this.value = e), (this.children = t);
  }
  toString() {
    return `TreeNode(${this.value})`;
  }
};
function Ia(n) {
  let e = {};
  return n && n.children.forEach((t) => (e[t.value.outlet] = t)), e;
}
var df = class extends ff {
  constructor(e, t) {
    super(e), (this.snapshot = t), A0(this, e);
  }
  toString() {
    return this.snapshot.toString();
  }
};
function J1(n) {
  let e = J_(n),
    t = new hn([new io("", {})]),
    r = new hn({}),
    i = new hn({}),
    s = new hn({}),
    o = new hn(""),
    a = new cs(t, r, s, o, i, Ce, n, e.root);
  return (a.snapshot = e.root), new df(new qn(a, []), e);
}
function J_(n) {
  let e = {},
    t = {},
    r = {},
    i = "",
    s = new ka([], e, r, i, t, Ce, n, null, {});
  return new gf("", new qn(s, []));
}
var cs = class {
  constructor(e, t, r, i, s, o, a, c) {
    (this.urlSubject = e),
      (this.paramsSubject = t),
      (this.queryParamsSubject = r),
      (this.fragmentSubject = i),
      (this.dataSubject = s),
      (this.outlet = o),
      (this.component = a),
      (this._futureSnapshot = c),
      (this.title = this.dataSubject?.pipe(xe((u) => u[Xu])) ?? oe(void 0)),
      (this.url = e),
      (this.params = t),
      (this.queryParams = r),
      (this.fragment = i),
      (this.data = s);
  }
  get routeConfig() {
    return this._futureSnapshot.routeConfig;
  }
  get root() {
    return this._routerState.root;
  }
  get parent() {
    return this._routerState.parent(this);
  }
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  get children() {
    return this._routerState.children(this);
  }
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    return (
      (this._paramMap ??= this.params.pipe(xe((e) => Ra(e)))), this._paramMap
    );
  }
  get queryParamMap() {
    return (
      (this._queryParamMap ??= this.queryParams.pipe(xe((e) => Ra(e)))),
      this._queryParamMap
    );
  }
  toString() {
    return this.snapshot
      ? this.snapshot.toString()
      : `Future(${this._futureSnapshot})`;
  }
};
function pf(n, e, t = "emptyOnly") {
  let r,
    { routeConfig: i } = n;
  return (
    e !== null &&
    (t === "always" ||
      i?.path === "" ||
      (!e.component && !e.routeConfig?.loadComponent))
      ? (r = {
          params: v(v({}, e.params), n.params),
          data: v(v({}, e.data), n.data),
          resolve: v(v(v(v({}, n.data), e.data), i?.data), n._resolvedData),
        })
      : (r = {
          params: v({}, n.params),
          data: v({}, n.data),
          resolve: v(v({}, n.data), n._resolvedData ?? {}),
        }),
    i && Z1(i) && (r.resolve[Xu] = i.title),
    r
  );
}
var ka = class {
    get title() {
      return this.data?.[Xu];
    }
    constructor(e, t, r, i, s, o, a, c, u) {
      (this.url = e),
        (this.params = t),
        (this.queryParams = r),
        (this.fragment = i),
        (this.data = s),
        (this.outlet = o),
        (this.component = a),
        (this.routeConfig = c),
        (this._resolve = u);
    }
    get root() {
      return this._routerState.root;
    }
    get parent() {
      return this._routerState.parent(this);
    }
    get firstChild() {
      return this._routerState.firstChild(this);
    }
    get children() {
      return this._routerState.children(this);
    }
    get pathFromRoot() {
      return this._routerState.pathFromRoot(this);
    }
    get paramMap() {
      return (this._paramMap ??= Ra(this.params)), this._paramMap;
    }
    get queryParamMap() {
      return (
        (this._queryParamMap ??= Ra(this.queryParams)), this._queryParamMap
      );
    }
    toString() {
      let e = this.url.map((r) => r.toString()).join("/"),
        t = this.routeConfig ? this.routeConfig.path : "";
      return `Route(url:'${e}', path:'${t}')`;
    }
  },
  gf = class extends ff {
    constructor(e, t) {
      super(t), (this.url = e), A0(this, t);
    }
    toString() {
      return Y1(this._root);
    }
  };
function A0(n, e) {
  (e.value._routerState = n), e.children.forEach((t) => A0(n, t));
}
function Y1(n) {
  let e = n.children.length > 0 ? ` { ${n.children.map(Y1).join(", ")} } ` : "";
  return `${n.value}${e}`;
}
function Gm(n) {
  if (n.snapshot) {
    let e = n.snapshot,
      t = n._futureSnapshot;
    (n.snapshot = t),
      Gr(e.queryParams, t.queryParams) ||
        n.queryParamsSubject.next(t.queryParams),
      e.fragment !== t.fragment && n.fragmentSubject.next(t.fragment),
      Gr(e.params, t.params) || n.paramsSubject.next(t.params),
      S_(e.url, t.url) || n.urlSubject.next(t.url),
      Gr(e.data, t.data) || n.dataSubject.next(t.data);
  } else
    (n.snapshot = n._futureSnapshot),
      n.dataSubject.next(n._futureSnapshot.data);
}
function f0(n, e) {
  let t = Gr(n.params, e.params) && k_(n.url, e.url),
    r = !n.parent != !e.parent;
  return t && !r && (!n.parent || f0(n.parent, e.parent));
}
function Z1(n) {
  return typeof n.title == "string" || n.title === null;
}
var Y_ = (() => {
    class n {
      constructor() {
        (this.activated = null),
          (this._activatedRoute = null),
          (this.name = Ce),
          (this.activateEvents = new to()),
          (this.deactivateEvents = new to()),
          (this.attachEvents = new to()),
          (this.detachEvents = new to()),
          (this.parentContexts = M(tl)),
          (this.location = M(ns)),
          (this.changeDetector = M($r)),
          (this.inputBinder = M(bf, { optional: !0 })),
          (this.supportsBindingToComponentInputs = !0);
      }
      get activatedComponentRef() {
        return this.activated;
      }
      ngOnChanges(t) {
        if (t.name) {
          let { firstChange: r, previousValue: i } = t.name;
          if (r) return;
          this.isTrackedInParentContexts(i) &&
            (this.deactivate(), this.parentContexts.onChildOutletDestroyed(i)),
            this.initializeOutletWithName();
        }
      }
      ngOnDestroy() {
        this.isTrackedInParentContexts(this.name) &&
          this.parentContexts.onChildOutletDestroyed(this.name),
          this.inputBinder?.unsubscribeFromRouteData(this);
      }
      isTrackedInParentContexts(t) {
        return this.parentContexts.getContext(t)?.outlet === this;
      }
      ngOnInit() {
        this.initializeOutletWithName();
      }
      initializeOutletWithName() {
        if (
          (this.parentContexts.onChildOutletCreated(this.name, this),
          this.activated)
        )
          return;
        let t = this.parentContexts.getContext(this.name);
        t?.route &&
          (t.attachRef
            ? this.attach(t.attachRef, t.route)
            : this.activateWith(t.route, t.injector));
      }
      get isActivated() {
        return !!this.activated;
      }
      get component() {
        if (!this.activated) throw new rt(4012, !1);
        return this.activated.instance;
      }
      get activatedRoute() {
        if (!this.activated) throw new rt(4012, !1);
        return this._activatedRoute;
      }
      get activatedRouteData() {
        return this._activatedRoute ? this._activatedRoute.snapshot.data : {};
      }
      detach() {
        if (!this.activated) throw new rt(4012, !1);
        this.location.detach();
        let t = this.activated;
        return (
          (this.activated = null),
          (this._activatedRoute = null),
          this.detachEvents.emit(t.instance),
          t
        );
      }
      attach(t, r) {
        (this.activated = t),
          (this._activatedRoute = r),
          this.location.insert(t.hostView),
          this.inputBinder?.bindActivatedRouteToOutletComponent(this),
          this.attachEvents.emit(t.instance);
      }
      deactivate() {
        if (this.activated) {
          let t = this.component;
          this.activated.destroy(),
            (this.activated = null),
            (this._activatedRoute = null),
            this.deactivateEvents.emit(t);
        }
      }
      activateWith(t, r) {
        if (this.isActivated) throw new rt(4013, !1);
        this._activatedRoute = t;
        let i = this.location,
          o = t.snapshot.component,
          a = this.parentContexts.getOrCreateContext(this.name).children,
          c = new d0(t, a, i.injector);
        (this.activated = i.createComponent(o, {
          index: i.length,
          injector: c,
          environmentInjector: r,
        })),
          this.changeDetector.markForCheck(),
          this.inputBinder?.bindActivatedRouteToOutletComponent(this),
          this.activateEvents.emit(this.activated.instance);
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵdir = sr({
          type: n,
          selectors: [["router-outlet"]],
          inputs: { name: "name" },
          outputs: {
            activateEvents: "activate",
            deactivateEvents: "deactivate",
            attachEvents: "attach",
            detachEvents: "detach",
          },
          exportAs: ["outlet"],
          standalone: !0,
          features: [es],
        });
      }
    }
    return n;
  })(),
  d0 = class n {
    __ngOutletInjector(e) {
      return new n(this.route, this.childContexts, e);
    }
    constructor(e, t, r) {
      (this.route = e), (this.childContexts = t), (this.parent = r);
    }
    get(e, t) {
      return e === cs
        ? this.route
        : e === tl
        ? this.childContexts
        : this.parent.get(e, t);
    }
  },
  bf = new Ae(""),
  B1 = (() => {
    class n {
      constructor() {
        this.outletDataSubscriptions = new Map();
      }
      bindActivatedRouteToOutletComponent(t) {
        this.unsubscribeFromRouteData(t), this.subscribeToRouteData(t);
      }
      unsubscribeFromRouteData(t) {
        this.outletDataSubscriptions.get(t)?.unsubscribe(),
          this.outletDataSubscriptions.delete(t);
      }
      subscribeToRouteData(t) {
        let { activatedRoute: r } = t,
          i = dn([r.queryParams, r.params, r.data])
            .pipe(
              ct(
                ([s, o, a], c) => (
                  (a = v(v(v({}, s), o), a)),
                  c === 0 ? oe(a) : Promise.resolve(a)
                )
              )
            )
            .subscribe((s) => {
              if (
                !t.isActivated ||
                !t.activatedComponentRef ||
                t.activatedRoute !== r ||
                r.component === null
              ) {
                this.unsubscribeFromRouteData(t);
                return;
              }
              let o = NE(r.component);
              if (!o) {
                this.unsubscribeFromRouteData(t);
                return;
              }
              for (let { templateName: a } of o.inputs)
                t.activatedComponentRef.setInput(a, s[a]);
            });
        this.outletDataSubscriptions.set(t, i);
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })();
function Z_(n, e, t) {
  let r = qu(n, e._root, t ? t._root : void 0);
  return new df(r, e);
}
function qu(n, e, t) {
  if (t && n.shouldReuseRoute(e.value, t.value.snapshot)) {
    let r = t.value;
    r._futureSnapshot = e.value;
    let i = X_(n, e, t);
    return new qn(r, i);
  } else {
    if (n.shouldAttach(e.value)) {
      let s = n.retrieve(e.value);
      if (s !== null) {
        let o = s.route;
        return (
          (o.value._futureSnapshot = e.value),
          (o.children = e.children.map((a) => qu(n, a))),
          o
        );
      }
    }
    let r = eP(e.value),
      i = e.children.map((s) => qu(n, s));
    return new qn(r, i);
  }
}
function X_(n, e, t) {
  return e.children.map((r) => {
    for (let i of t.children)
      if (n.shouldReuseRoute(r.value, i.value.snapshot)) return qu(n, r, i);
    return qu(n, r);
  });
}
function eP(n) {
  return new cs(
    new hn(n.url),
    new hn(n.params),
    new hn(n.queryParams),
    new hn(n.fragment),
    new hn(n.data),
    n.outlet,
    n.component,
    n
  );
}
var Qu = class {
    constructor(e, t) {
      (this.redirectTo = e), (this.navigationBehaviorOptions = t);
    }
  },
  X1 = "ngNavigationCancelingError";
function mf(n, e) {
  let { redirectTo: t, navigationBehaviorOptions: r } = oo(e)
      ? { redirectTo: e, navigationBehaviorOptions: void 0 }
      : e,
    i = ex(!1, Qn.Redirect);
  return (i.url = t), (i.navigationBehaviorOptions = r), i;
}
function ex(n, e) {
  let t = new Error(`NavigationCancelingError: ${n || ""}`);
  return (t[X1] = !0), (t.cancellationCode = e), t;
}
function tP(n) {
  return tx(n) && oo(n.url);
}
function tx(n) {
  return !!n && n[X1];
}
var nP = (n, e, t, r) =>
    xe(
      (i) => (
        new p0(e, i.targetRouterState, i.currentRouterState, t, r).activate(n),
        i
      )
    ),
  p0 = class {
    constructor(e, t, r, i, s) {
      (this.routeReuseStrategy = e),
        (this.futureState = t),
        (this.currState = r),
        (this.forwardEvent = i),
        (this.inputBindingEnabled = s);
    }
    activate(e) {
      let t = this.futureState._root,
        r = this.currState ? this.currState._root : null;
      this.deactivateChildRoutes(t, r, e),
        Gm(this.futureState.root),
        this.activateChildRoutes(t, r, e);
    }
    deactivateChildRoutes(e, t, r) {
      let i = Ia(t);
      e.children.forEach((s) => {
        let o = s.value.outlet;
        this.deactivateRoutes(s, i[o], r), delete i[o];
      }),
        Object.values(i).forEach((s) => {
          this.deactivateRouteAndItsChildren(s, r);
        });
    }
    deactivateRoutes(e, t, r) {
      let i = e.value,
        s = t ? t.value : null;
      if (i === s)
        if (i.component) {
          let o = r.getContext(i.outlet);
          o && this.deactivateChildRoutes(e, t, o.children);
        } else this.deactivateChildRoutes(e, t, r);
      else s && this.deactivateRouteAndItsChildren(t, r);
    }
    deactivateRouteAndItsChildren(e, t) {
      e.value.component &&
      this.routeReuseStrategy.shouldDetach(e.value.snapshot)
        ? this.detachAndStoreRouteSubtree(e, t)
        : this.deactivateRouteAndOutlet(e, t);
    }
    detachAndStoreRouteSubtree(e, t) {
      let r = t.getContext(e.value.outlet),
        i = r && e.value.component ? r.children : t,
        s = Ia(e);
      for (let o of Object.values(s)) this.deactivateRouteAndItsChildren(o, i);
      if (r && r.outlet) {
        let o = r.outlet.detach(),
          a = r.children.onOutletDeactivated();
        this.routeReuseStrategy.store(e.value.snapshot, {
          componentRef: o,
          route: e,
          contexts: a,
        });
      }
    }
    deactivateRouteAndOutlet(e, t) {
      let r = t.getContext(e.value.outlet),
        i = r && e.value.component ? r.children : t,
        s = Ia(e);
      for (let o of Object.values(s)) this.deactivateRouteAndItsChildren(o, i);
      r &&
        (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()),
        (r.attachRef = null),
        (r.route = null));
    }
    activateChildRoutes(e, t, r) {
      let i = Ia(t);
      e.children.forEach((s) => {
        this.activateRoutes(s, i[s.value.outlet], r),
          this.forwardEvent(new c0(s.value.snapshot));
      }),
        e.children.length && this.forwardEvent(new o0(e.value.snapshot));
    }
    activateRoutes(e, t, r) {
      let i = e.value,
        s = t ? t.value : null;
      if ((Gm(i), i === s))
        if (i.component) {
          let o = r.getOrCreateContext(i.outlet);
          this.activateChildRoutes(e, t, o.children);
        } else this.activateChildRoutes(e, t, r);
      else if (i.component) {
        let o = r.getOrCreateContext(i.outlet);
        if (this.routeReuseStrategy.shouldAttach(i.snapshot)) {
          let a = this.routeReuseStrategy.retrieve(i.snapshot);
          this.routeReuseStrategy.store(i.snapshot, null),
            o.children.onOutletReAttached(a.contexts),
            (o.attachRef = a.componentRef),
            (o.route = a.route.value),
            o.outlet && o.outlet.attach(a.componentRef, a.route.value),
            Gm(a.route.value),
            this.activateChildRoutes(e, null, o.children);
        } else
          (o.attachRef = null),
            (o.route = i),
            o.outlet && o.outlet.activateWith(i, o.injector),
            this.activateChildRoutes(e, null, o.children);
      } else this.activateChildRoutes(e, null, r);
    }
  },
  yf = class {
    constructor(e) {
      (this.path = e), (this.route = this.path[this.path.length - 1]);
    }
  },
  Ta = class {
    constructor(e, t) {
      (this.component = e), (this.route = t);
    }
  };
function rP(n, e, t) {
  let r = n._root,
    i = e ? e._root : null;
  return zu(r, i, t, [r.value]);
}
function iP(n) {
  let e = n.routeConfig ? n.routeConfig.canActivateChild : null;
  return !e || e.length === 0 ? null : { node: n, guards: e };
}
function Oa(n, e) {
  let t = Symbol(),
    r = e.get(n, t);
  return r === t ? (typeof n == "function" && !tE(n) ? n : e.get(n)) : r;
}
function zu(
  n,
  e,
  t,
  r,
  i = { canDeactivateChecks: [], canActivateChecks: [] }
) {
  let s = Ia(e);
  return (
    n.children.forEach((o) => {
      sP(o, s[o.value.outlet], t, r.concat([o.value]), i),
        delete s[o.value.outlet];
    }),
    Object.entries(s).forEach(([o, a]) => Vu(a, t.getContext(o), i)),
    i
  );
}
function sP(
  n,
  e,
  t,
  r,
  i = { canDeactivateChecks: [], canActivateChecks: [] }
) {
  let s = n.value,
    o = e ? e.value : null,
    a = t ? t.getContext(n.value.outlet) : null;
  if (o && s.routeConfig === o.routeConfig) {
    let c = oP(o, s, s.routeConfig.runGuardsAndResolvers);
    c
      ? i.canActivateChecks.push(new yf(r))
      : ((s.data = o.data), (s._resolvedData = o._resolvedData)),
      s.component ? zu(n, e, a ? a.children : null, r, i) : zu(n, e, t, r, i),
      c &&
        a &&
        a.outlet &&
        a.outlet.isActivated &&
        i.canDeactivateChecks.push(new Ta(a.outlet.component, o));
  } else
    o && Vu(e, a, i),
      i.canActivateChecks.push(new yf(r)),
      s.component
        ? zu(n, null, a ? a.children : null, r, i)
        : zu(n, null, t, r, i);
  return i;
}
function oP(n, e, t) {
  if (typeof t == "function") return t(n, e);
  switch (t) {
    case "pathParamsChange":
      return !so(n.url, e.url);
    case "pathParamsOrQueryParamsChange":
      return !so(n.url, e.url) || !Gr(n.queryParams, e.queryParams);
    case "always":
      return !0;
    case "paramsOrQueryParamsChange":
      return !f0(n, e) || !Gr(n.queryParams, e.queryParams);
    case "paramsChange":
    default:
      return !f0(n, e);
  }
}
function Vu(n, e, t) {
  let r = Ia(n),
    i = n.value;
  Object.entries(r).forEach(([s, o]) => {
    i.component
      ? e
        ? Vu(o, e.children.getContext(s), t)
        : Vu(o, null, t)
      : Vu(o, e, t);
  }),
    i.component
      ? e && e.outlet && e.outlet.isActivated
        ? t.canDeactivateChecks.push(new Ta(e.outlet.component, i))
        : t.canDeactivateChecks.push(new Ta(null, i))
      : t.canDeactivateChecks.push(new Ta(null, i));
}
function nl(n) {
  return typeof n == "function";
}
function aP(n) {
  return typeof n == "boolean";
}
function cP(n) {
  return n && nl(n.canLoad);
}
function uP(n) {
  return n && nl(n.canActivate);
}
function lP(n) {
  return n && nl(n.canActivateChild);
}
function hP(n) {
  return n && nl(n.canDeactivate);
}
function fP(n) {
  return n && nl(n.canMatch);
}
function nx(n) {
  return n instanceof $A || n?.name === "EmptyError";
}
var nf = Symbol("INITIAL_VALUE");
function Pa() {
  return ct((n) =>
    dn(n.map((e) => e.pipe(br(1), XA(nf)))).pipe(
      xe((e) => {
        for (let t of e)
          if (t !== !0) {
            if (t === nf) return nf;
            if (t === !1 || dP(t)) return t;
          }
        return !0;
      }),
      xn((e) => e !== nf),
      br(1)
    )
  );
}
function dP(n) {
  return oo(n) || n instanceof Qu;
}
function pP(n, e) {
  return Gn((t) => {
    let {
      targetSnapshot: r,
      currentSnapshot: i,
      guards: { canActivateChecks: s, canDeactivateChecks: o },
    } = t;
    return o.length === 0 && s.length === 0
      ? oe($(v({}, t), { guardsResult: !0 }))
      : gP(o, r, i, n).pipe(
          Gn((a) => (a && aP(a) ? mP(r, s, n, e) : oe(a))),
          xe((a) => $(v({}, t), { guardsResult: a }))
        );
  });
}
function gP(n, e, t, r) {
  return Ke(n).pipe(
    Gn((i) => EP(i.component, i.route, t, e, r)),
    ir((i) => i !== !0, !0)
  );
}
function mP(n, e, t, r) {
  return Ke(e).pipe(
    Sn((i) =>
      GA(
        wP(i.route.parent, r),
        yP(i.route, r),
        AP(n, i.path, t),
        bP(n, i.route, t)
      )
    ),
    ir((i) => i !== !0, !0)
  );
}
function yP(n, e) {
  return n !== null && e && e(new a0(n)), oe(!0);
}
function wP(n, e) {
  return n !== null && e && e(new s0(n)), oe(!0);
}
function bP(n, e, t) {
  let r = e.routeConfig ? e.routeConfig.canActivate : null;
  if (!r || r.length === 0) return oe(!0);
  let i = r.map((s) =>
    pn(() => {
      let o = el(e) ?? t,
        a = Oa(s, o),
        c = uP(a) ? a.canActivate(e, n) : ar(o, () => a(e, n));
      return us(c).pipe(ir());
    })
  );
  return oe(i).pipe(Pa());
}
function AP(n, e, t) {
  let r = e[e.length - 1],
    s = e
      .slice(0, e.length - 1)
      .reverse()
      .map((o) => iP(o))
      .filter((o) => o !== null)
      .map((o) =>
        pn(() => {
          let a = o.guards.map((c) => {
            let u = el(o.node) ?? t,
              l = Oa(c, u),
              h = lP(l) ? l.canActivateChild(r, n) : ar(u, () => l(r, n));
            return us(h).pipe(ir());
          });
          return oe(a).pipe(Pa());
        })
      );
  return oe(s).pipe(Pa());
}
function EP(n, e, t, r, i) {
  let s = e && e.routeConfig ? e.routeConfig.canDeactivate : null;
  if (!s || s.length === 0) return oe(!0);
  let o = s.map((a) => {
    let c = el(e) ?? i,
      u = Oa(a, c),
      l = hP(u) ? u.canDeactivate(n, e, t, r) : ar(c, () => u(n, e, t, r));
    return us(l).pipe(ir());
  });
  return oe(o).pipe(Pa());
}
function xP(n, e, t, r) {
  let i = e.canLoad;
  if (i === void 0 || i.length === 0) return oe(!0);
  let s = i.map((o) => {
    let a = Oa(o, n),
      c = cP(a) ? a.canLoad(e, t) : ar(n, () => a(e, t));
    return us(c);
  });
  return oe(s).pipe(Pa(), rx(r));
}
function rx(n) {
  return WA(
    Oe((e) => {
      if (typeof e != "boolean") throw mf(n, e);
    }),
    xe((e) => e === !0)
  );
}
function SP(n, e, t, r) {
  let i = e.canMatch;
  if (!i || i.length === 0) return oe(!0);
  let s = i.map((o) => {
    let a = Oa(o, n),
      c = fP(a) ? a.canMatch(e, t) : ar(n, () => a(e, t));
    return us(c);
  });
  return oe(s).pipe(Pa(), rx(r));
}
var Ju = class {
    constructor(e) {
      this.segmentGroup = e || null;
    }
  },
  Yu = class extends Error {
    constructor(e) {
      super(), (this.urlTree = e);
    }
  };
function va(n) {
  return Tt(new Ju(n));
}
function vP(n) {
  return Tt(new rt(4e3, !1));
}
function IP(n) {
  return Tt(ex(!1, Qn.GuardRejected));
}
var g0 = class {
    constructor(e, t) {
      (this.urlSerializer = e), (this.urlTree = t);
    }
    lineralizeSegments(e, t) {
      let r = [],
        i = t.root;
      for (;;) {
        if (((r = r.concat(i.segments)), i.numberOfChildren === 0))
          return oe(r);
        if (i.numberOfChildren > 1 || !i.children[Ce])
          return vP(`${e.redirectTo}`);
        i = i.children[Ce];
      }
    }
    applyRedirectCommands(e, t, r, i, s) {
      if (typeof t != "string") {
        let a = t,
          {
            queryParams: c,
            fragment: u,
            routeConfig: l,
            url: h,
            outlet: f,
            params: g,
            data: y,
            title: w,
          } = i,
          m = ar(s, () =>
            a({
              params: g,
              data: y,
              queryParams: c,
              fragment: u,
              routeConfig: l,
              url: h,
              outlet: f,
              title: w,
            })
          );
        if (m instanceof vi) throw new Yu(m);
        t = m;
      }
      let o = this.applyRedirectCreateUrlTree(
        t,
        this.urlSerializer.parse(t),
        e,
        r
      );
      if (t[0] === "/") throw new Yu(o);
      return o;
    }
    applyRedirectCreateUrlTree(e, t, r, i) {
      let s = this.createSegmentGroup(e, t.root, r, i);
      return new vi(
        s,
        this.createQueryParams(t.queryParams, this.urlTree.queryParams),
        t.fragment
      );
    }
    createQueryParams(e, t) {
      let r = {};
      return (
        Object.entries(e).forEach(([i, s]) => {
          if (typeof s == "string" && s[0] === ":") {
            let a = s.substring(1);
            r[i] = t[a];
          } else r[i] = s;
        }),
        r
      );
    }
    createSegmentGroup(e, t, r, i) {
      let s = this.createSegments(e, t.segments, r, i),
        o = {};
      return (
        Object.entries(t.children).forEach(([a, c]) => {
          o[a] = this.createSegmentGroup(e, c, r, i);
        }),
        new Je(s, o)
      );
    }
    createSegments(e, t, r, i) {
      return t.map((s) =>
        s.path[0] === ":" ? this.findPosParam(e, s, i) : this.findOrReturn(s, r)
      );
    }
    findPosParam(e, t, r) {
      let i = r[t.path.substring(1)];
      if (!i) throw new rt(4001, !1);
      return i;
    }
    findOrReturn(e, t) {
      let r = 0;
      for (let i of t) {
        if (i.path === e.path) return t.splice(r), i;
        r++;
      }
      return e;
    }
  },
  m0 = {
    matched: !1,
    consumedSegments: [],
    remainingSegments: [],
    parameters: {},
    positionalParamSegments: {},
  };
function CP(n, e, t, r, i) {
  let s = ix(n, e, t);
  return s.matched
    ? ((r = q_(e, r)),
      SP(r, e, t, i).pipe(xe((o) => (o === !0 ? s : v({}, m0)))))
    : oe(s);
}
function ix(n, e, t) {
  if (e.path === "**") return kP(t);
  if (e.path === "")
    return e.pathMatch === "full" && (n.hasChildren() || t.length > 0)
      ? v({}, m0)
      : {
          matched: !0,
          consumedSegments: [],
          remainingSegments: t,
          parameters: {},
          positionalParamSegments: {},
        };
  let i = (e.matcher || x_)(t, n, e);
  if (!i) return v({}, m0);
  let s = {};
  Object.entries(i.posParams ?? {}).forEach(([a, c]) => {
    s[a] = c.path;
  });
  let o =
    i.consumed.length > 0
      ? v(v({}, s), i.consumed[i.consumed.length - 1].parameters)
      : s;
  return {
    matched: !0,
    consumedSegments: i.consumed,
    remainingSegments: t.slice(i.consumed.length),
    parameters: o,
    positionalParamSegments: i.posParams ?? {},
  };
}
function kP(n) {
  return {
    matched: !0,
    parameters: n.length > 0 ? F1(n).parameters : {},
    consumedSegments: n,
    remainingSegments: [],
    positionalParamSegments: {},
  };
}
function D1(n, e, t, r) {
  return t.length > 0 && BP(n, t, r)
    ? {
        segmentGroup: new Je(e, RP(r, new Je(t, n.children))),
        slicedSegments: [],
      }
    : t.length === 0 && DP(n, t, r)
    ? {
        segmentGroup: new Je(n.segments, TP(n, t, r, n.children)),
        slicedSegments: t,
      }
    : { segmentGroup: new Je(n.segments, n.children), slicedSegments: t };
}
function TP(n, e, t, r) {
  let i = {};
  for (let s of t)
    if (Af(n, e, s) && !r[Ar(s)]) {
      let o = new Je([], {});
      i[Ar(s)] = o;
    }
  return v(v({}, r), i);
}
function RP(n, e) {
  let t = {};
  t[Ce] = e;
  for (let r of n)
    if (r.path === "" && Ar(r) !== Ce) {
      let i = new Je([], {});
      t[Ar(r)] = i;
    }
  return t;
}
function BP(n, e, t) {
  return t.some((r) => Af(n, e, r) && Ar(r) !== Ce);
}
function DP(n, e, t) {
  return t.some((r) => Af(n, e, r));
}
function Af(n, e, t) {
  return (n.hasChildren() || e.length > 0) && t.pathMatch === "full"
    ? !1
    : t.path === "";
}
function _P(n, e, t) {
  return e.length === 0 && !n.children[t];
}
var y0 = class {};
function PP(n, e, t, r, i, s, o = "emptyOnly") {
  return new w0(n, e, t, r, i, o, s).recognize();
}
var LP = 31,
  w0 = class {
    constructor(e, t, r, i, s, o, a) {
      (this.injector = e),
        (this.configLoader = t),
        (this.rootComponentType = r),
        (this.config = i),
        (this.urlTree = s),
        (this.paramsInheritanceStrategy = o),
        (this.urlSerializer = a),
        (this.applyRedirects = new g0(this.urlSerializer, this.urlTree)),
        (this.absoluteRedirectCount = 0),
        (this.allowRedirects = !0);
    }
    noMatchError(e) {
      return new rt(4002, `'${e.segmentGroup}'`);
    }
    recognize() {
      let e = D1(this.urlTree.root, [], [], this.config).segmentGroup;
      return this.match(e).pipe(
        xe(({ children: t, rootSnapshot: r }) => {
          let i = new qn(r, t),
            s = new gf("", i),
            o = j_(r, [], this.urlTree.queryParams, this.urlTree.fragment);
          return (
            (o.queryParams = this.urlTree.queryParams),
            (s.url = this.urlSerializer.serialize(o)),
            { state: s, tree: o }
          );
        })
      );
    }
    match(e) {
      let t = new ka(
        [],
        Object.freeze({}),
        Object.freeze(v({}, this.urlTree.queryParams)),
        this.urlTree.fragment,
        Object.freeze({}),
        Ce,
        this.rootComponentType,
        null,
        {}
      );
      return this.processSegmentGroup(
        this.injector,
        this.config,
        e,
        Ce,
        t
      ).pipe(
        xe((r) => ({ children: r, rootSnapshot: t })),
        _n((r) => {
          if (r instanceof Yu)
            return (this.urlTree = r.urlTree), this.match(r.urlTree.root);
          throw r instanceof Ju ? this.noMatchError(r) : r;
        })
      );
    }
    processSegmentGroup(e, t, r, i, s) {
      return r.segments.length === 0 && r.hasChildren()
        ? this.processChildren(e, t, r, s)
        : this.processSegment(e, t, r, r.segments, i, !0, s).pipe(
            xe((o) => (o instanceof qn ? [o] : []))
          );
    }
    processChildren(e, t, r, i) {
      let s = [];
      for (let o of Object.keys(r.children))
        o === "primary" ? s.unshift(o) : s.push(o);
      return Ke(s).pipe(
        Sn((o) => {
          let a = r.children[o],
            c = Q_(t, o);
          return this.processSegmentGroup(e, c, a, o, i);
        }),
        ZA((o, a) => (o.push(...a), o)),
        Zg(null),
        JA(),
        Gn((o) => {
          if (o === null) return va(r);
          let a = sx(o);
          return OP(a), oe(a);
        })
      );
    }
    processSegment(e, t, r, i, s, o, a) {
      return Ke(t).pipe(
        Sn((c) =>
          this.processSegmentAgainstRoute(
            c._injector ?? e,
            t,
            c,
            r,
            i,
            s,
            o,
            a
          ).pipe(
            _n((u) => {
              if (u instanceof Ju) return oe(null);
              throw u;
            })
          )
        ),
        ir((c) => !!c),
        _n((c) => {
          if (nx(c)) return _P(r, i, s) ? oe(new y0()) : va(r);
          throw c;
        })
      );
    }
    processSegmentAgainstRoute(e, t, r, i, s, o, a, c) {
      return Ar(r) !== o && (o === Ce || !Af(i, s, r))
        ? va(i)
        : r.redirectTo === void 0
        ? this.matchSegmentAgainstRoute(e, i, r, s, o, c)
        : this.allowRedirects && a
        ? this.expandSegmentAgainstRouteUsingRedirect(e, i, t, r, s, o, c)
        : va(i);
    }
    expandSegmentAgainstRouteUsingRedirect(e, t, r, i, s, o, a) {
      let {
        matched: c,
        parameters: u,
        consumedSegments: l,
        positionalParamSegments: h,
        remainingSegments: f,
      } = ix(t, i, s);
      if (!c) return va(t);
      typeof i.redirectTo == "string" &&
        i.redirectTo[0] === "/" &&
        (this.absoluteRedirectCount++,
        this.absoluteRedirectCount > LP && (this.allowRedirects = !1));
      let g = new ka(
          s,
          u,
          Object.freeze(v({}, this.urlTree.queryParams)),
          this.urlTree.fragment,
          _1(i),
          Ar(i),
          i.component ?? i._loadedComponent ?? null,
          i,
          P1(i)
        ),
        y = pf(g, a, this.paramsInheritanceStrategy);
      (g.params = Object.freeze(y.params)), (g.data = Object.freeze(y.data));
      let w = this.applyRedirects.applyRedirectCommands(
        l,
        i.redirectTo,
        h,
        g,
        e
      );
      return this.applyRedirects
        .lineralizeSegments(i, w)
        .pipe(Gn((m) => this.processSegment(e, r, t, m.concat(f), o, !1, a)));
    }
    matchSegmentAgainstRoute(e, t, r, i, s, o) {
      let a = CP(t, r, i, e, this.urlSerializer);
      return (
        r.path === "**" && (t.children = {}),
        a.pipe(
          ct((c) =>
            c.matched
              ? ((e = r._injector ?? e),
                this.getChildConfig(e, r, i).pipe(
                  ct(({ routes: u }) => {
                    let l = r._loadedInjector ?? e,
                      {
                        parameters: h,
                        consumedSegments: f,
                        remainingSegments: g,
                      } = c,
                      y = new ka(
                        f,
                        h,
                        Object.freeze(v({}, this.urlTree.queryParams)),
                        this.urlTree.fragment,
                        _1(r),
                        Ar(r),
                        r.component ?? r._loadedComponent ?? null,
                        r,
                        P1(r)
                      ),
                      w = pf(y, o, this.paramsInheritanceStrategy);
                    (y.params = Object.freeze(w.params)),
                      (y.data = Object.freeze(w.data));
                    let { segmentGroup: m, slicedSegments: b } = D1(t, f, g, u);
                    if (b.length === 0 && m.hasChildren())
                      return this.processChildren(l, u, m, y).pipe(
                        xe((E) => new qn(y, E))
                      );
                    if (u.length === 0 && b.length === 0)
                      return oe(new qn(y, []));
                    let I = Ar(r) === s;
                    return this.processSegment(
                      l,
                      u,
                      m,
                      b,
                      I ? Ce : s,
                      !0,
                      y
                    ).pipe(xe((E) => new qn(y, E instanceof qn ? [E] : [])));
                  })
                ))
              : va(t)
          )
        )
      );
    }
    getChildConfig(e, t, r) {
      return t.children
        ? oe({ routes: t.children, injector: e })
        : t.loadChildren
        ? t._loadedRoutes !== void 0
          ? oe({ routes: t._loadedRoutes, injector: t._loadedInjector })
          : xP(e, t, r, this.urlSerializer).pipe(
              Gn((i) =>
                i
                  ? this.configLoader.loadChildren(e, t).pipe(
                      Oe((s) => {
                        (t._loadedRoutes = s.routes),
                          (t._loadedInjector = s.injector);
                      })
                    )
                  : IP(t)
              )
            )
        : oe({ routes: [], injector: e });
    }
  };
function OP(n) {
  n.sort((e, t) =>
    e.value.outlet === Ce
      ? -1
      : t.value.outlet === Ce
      ? 1
      : e.value.outlet.localeCompare(t.value.outlet)
  );
}
function NP(n) {
  let e = n.value.routeConfig;
  return e && e.path === "";
}
function sx(n) {
  let e = [],
    t = new Set();
  for (let r of n) {
    if (!NP(r)) {
      e.push(r);
      continue;
    }
    let i = e.find((s) => r.value.routeConfig === s.value.routeConfig);
    i !== void 0 ? (i.children.push(...r.children), t.add(i)) : e.push(r);
  }
  for (let r of t) {
    let i = sx(r.children);
    e.push(new qn(r.value, i));
  }
  return e.filter((r) => !t.has(r));
}
function _1(n) {
  return n.data || {};
}
function P1(n) {
  return n.resolve || {};
}
function FP(n, e, t, r, i, s) {
  return Gn((o) =>
    PP(n, e, t, r, o.extractedUrl, i, s).pipe(
      xe(({ state: a, tree: c }) =>
        $(v({}, o), { targetSnapshot: a, urlAfterRedirects: c })
      )
    )
  );
}
function MP(n, e) {
  return Gn((t) => {
    let {
      targetSnapshot: r,
      guards: { canActivateChecks: i },
    } = t;
    if (!i.length) return oe(t);
    let s = new Set(i.map((c) => c.route)),
      o = new Set();
    for (let c of s) if (!o.has(c)) for (let u of ox(c)) o.add(u);
    let a = 0;
    return Ke(o).pipe(
      Sn((c) =>
        s.has(c)
          ? UP(c, r, n, e)
          : ((c.data = pf(c, c.parent, n).resolve), oe(void 0))
      ),
      Oe(() => a++),
      Xg(1),
      Gn((c) => (a === o.size ? oe(t) : fn))
    );
  });
}
function ox(n) {
  let e = n.children.map((t) => ox(t)).flat();
  return [n, ...e];
}
function UP(n, e, t, r) {
  let i = n.routeConfig,
    s = n._resolve;
  return (
    i?.title !== void 0 && !Z1(i) && (s[Xu] = i.title),
    zP(s, n, e, r).pipe(
      xe(
        (o) => (
          (n._resolvedData = o), (n.data = pf(n, n.parent, t).resolve), null
        )
      )
    )
  );
}
function zP(n, e, t, r) {
  let i = Qm(n);
  if (i.length === 0) return oe({});
  let s = {};
  return Ke(i).pipe(
    Gn((o) =>
      jP(n[o], e, t, r).pipe(
        ir(),
        Oe((a) => {
          if (a instanceof Qu) throw mf(new Ba(), a);
          s[o] = a;
        })
      )
    ),
    Xg(1),
    QA(s),
    _n((o) => (nx(o) ? fn : Tt(o)))
  );
}
function jP(n, e, t, r) {
  let i = el(e) ?? r,
    s = Oa(n, i),
    o = s.resolve ? s.resolve(e, t) : ar(i, () => s(e, t));
  return us(o);
}
function Km(n) {
  return ct((e) => {
    let t = n(e);
    return t ? Ke(t).pipe(xe(() => e)) : oe(e);
  });
}
var ax = (() => {
    class n {
      buildTitle(t) {
        let r,
          i = t.root;
        for (; i !== void 0; )
          (r = this.getResolvedTitleForRoute(i) ?? r),
            (i = i.children.find((s) => s.outlet === Ce));
        return r;
      }
      getResolvedTitleForRoute(t) {
        return t.data[Xu];
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: () => M(WP), providedIn: "root" });
      }
    }
    return n;
  })(),
  WP = (() => {
    class n extends ax {
      constructor(t) {
        super(), (this.title = t);
      }
      updateTitle(t) {
        let r = this.buildTitle(t);
        r !== void 0 && this.title.setTitle(r);
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(I1));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })(),
  rl = new Ae("", { providedIn: "root", factory: () => ({}) }),
  HP = (() => {
    class n {
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵcmp = da({
          type: n,
          selectors: [["ng-component"]],
          standalone: !0,
          features: [ba],
          decls: 1,
          vars: 0,
          template: function (r, i) {
            r & 1 && ya(0, "router-outlet");
          },
          dependencies: [Y_],
          encapsulation: 2,
        });
      }
    }
    return n;
  })();
function E0(n) {
  let e = n.children && n.children.map(E0),
    t = e ? $(v({}, n), { children: e }) : v({}, n);
  return (
    !t.component &&
      !t.loadComponent &&
      (e || t.loadChildren) &&
      t.outlet &&
      t.outlet !== Ce &&
      (t.component = HP),
    t
  );
}
var Zu = new Ae(""),
  x0 = (() => {
    class n {
      constructor() {
        (this.componentLoaders = new WeakMap()),
          (this.childrenLoaders = new WeakMap()),
          (this.compiler = M(zh));
      }
      loadComponent(t) {
        if (this.componentLoaders.get(t)) return this.componentLoaders.get(t);
        if (t._loadedComponent) return oe(t._loadedComponent);
        this.onLoadStartListener && this.onLoadStartListener(t);
        let r = us(t.loadComponent()).pipe(
            xe(cx),
            Oe((s) => {
              this.onLoadEndListener && this.onLoadEndListener(t),
                (t._loadedComponent = s);
            }),
            Wr(() => {
              this.componentLoaders.delete(t);
            })
          ),
          i = new Kg(r, () => new rr()).pipe(Gg());
        return this.componentLoaders.set(t, i), i;
      }
      loadChildren(t, r) {
        if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r);
        if (r._loadedRoutes)
          return oe({ routes: r._loadedRoutes, injector: r._loadedInjector });
        this.onLoadStartListener && this.onLoadStartListener(r);
        let s = VP(r, this.compiler, t, this.onLoadEndListener).pipe(
            Wr(() => {
              this.childrenLoaders.delete(r);
            })
          ),
          o = new Kg(s, () => new rr()).pipe(Gg());
        return this.childrenLoaders.set(r, o), o;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })();
function VP(n, e, t, r) {
  return us(n.loadChildren()).pipe(
    xe(cx),
    Gn((i) =>
      i instanceof xE || Array.isArray(i) ? oe(i) : Ke(e.compileModuleAsync(i))
    ),
    xe((i) => {
      r && r(n);
      let s,
        o,
        a = !1;
      return (
        Array.isArray(i)
          ? ((o = i), (a = !0))
          : ((s = i.create(t).injector),
            (o = s.get(Zu, [], { optional: !0, self: !0 }).flat())),
        { routes: o.map(E0), injector: s }
      );
    })
  );
}
function $P(n) {
  return n && typeof n == "object" && "default" in n;
}
function cx(n) {
  return $P(n) ? n.default : n;
}
var S0 = (() => {
    class n {
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: () => M(GP), providedIn: "root" });
      }
    }
    return n;
  })(),
  GP = (() => {
    class n {
      shouldProcessUrl(t) {
        return !0;
      }
      extract(t) {
        return t;
      }
      merge(t, r) {
        return t;
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })(),
  ux = new Ae(""),
  lx = new Ae("");
function KP(n, e, t) {
  let r = n.get(lx),
    i = n.get(Vt);
  return n.get(Kn).runOutsideAngular(() => {
    if (!i.startViewTransition || r.skipNextTransition)
      return (r.skipNextTransition = !1), new Promise((u) => setTimeout(u));
    let s,
      o = new Promise((u) => {
        s = u;
      }),
      a = i.startViewTransition(() => (s(), qP(n))),
      { onViewTransitionCreated: c } = r;
    return c && ar(n, () => c({ transition: a, from: e, to: t })), o;
  });
}
function qP(n) {
  return new Promise((e) => {
    SE({ read: () => setTimeout(e) }, { injector: n });
  });
}
var QP = new Ae(""),
  Ef = (() => {
    class n {
      get hasRequestedNavigation() {
        return this.navigationId !== 0;
      }
      constructor() {
        (this.currentNavigation = null),
          (this.currentTransition = null),
          (this.lastSuccessfulNavigation = null),
          (this.events = new rr()),
          (this.transitionAbortSubject = new rr()),
          (this.configLoader = M(x0)),
          (this.environmentInjector = M(eo)),
          (this.urlSerializer = M(La)),
          (this.rootContexts = M(tl)),
          (this.location = M(xa)),
          (this.inputBindingEnabled = M(bf, { optional: !0 }) !== null),
          (this.titleStrategy = M(ax)),
          (this.options = M(rl, { optional: !0 }) || {}),
          (this.paramsInheritanceStrategy =
            this.options.paramsInheritanceStrategy || "emptyOnly"),
          (this.urlHandlingStrategy = M(S0)),
          (this.createViewTransition = M(ux, { optional: !0 })),
          (this.navigationErrorHandler = M(QP, { optional: !0 })),
          (this.navigationId = 0),
          (this.afterPreactivation = () => oe(void 0)),
          (this.rootComponentType = null);
        let t = (i) => this.events.next(new r0(i)),
          r = (i) => this.events.next(new i0(i));
        (this.configLoader.onLoadEndListener = r),
          (this.configLoader.onLoadStartListener = t);
      }
      complete() {
        this.transitions?.complete();
      }
      handleNavigationRequest(t) {
        let r = ++this.navigationId;
        this.transitions?.next(
          $(v(v({}, this.transitions.value), t), { id: r })
        );
      }
      setupNavigations(t, r, i) {
        return (
          (this.transitions = new hn({
            id: 0,
            currentUrlTree: r,
            currentRawUrl: r,
            extractedUrl: this.urlHandlingStrategy.extract(r),
            urlAfterRedirects: this.urlHandlingStrategy.extract(r),
            rawUrl: r,
            extras: {},
            resolve: () => {},
            reject: () => {},
            promise: Promise.resolve(!0),
            source: Hu,
            restoredState: null,
            currentSnapshot: i.snapshot,
            targetSnapshot: null,
            currentRouterState: i,
            targetRouterState: null,
            guards: { canActivateChecks: [], canDeactivateChecks: [] },
            guardsResult: null,
          })),
          this.transitions.pipe(
            xn((s) => s.id !== 0),
            xe((s) =>
              $(v({}, s), {
                extractedUrl: this.urlHandlingStrategy.extract(s.rawUrl),
              })
            ),
            ct((s) => {
              let o = !1,
                a = !1;
              return oe(s).pipe(
                ct((c) => {
                  if (this.navigationId > s.id)
                    return (
                      this.cancelNavigationTransition(
                        s,
                        "",
                        Qn.SupersededByNewNavigation
                      ),
                      fn
                    );
                  (this.currentTransition = s),
                    (this.currentNavigation = {
                      id: c.id,
                      initialUrl: c.rawUrl,
                      extractedUrl: c.extractedUrl,
                      targetBrowserUrl:
                        typeof c.extras.browserUrl == "string"
                          ? this.urlSerializer.parse(c.extras.browserUrl)
                          : c.extras.browserUrl,
                      trigger: c.source,
                      extras: c.extras,
                      previousNavigation: this.lastSuccessfulNavigation
                        ? $(v({}, this.lastSuccessfulNavigation), {
                            previousNavigation: null,
                          })
                        : null,
                    });
                  let u =
                      !t.navigated ||
                      this.isUpdatingInternalState() ||
                      this.isUpdatedBrowserUrl(),
                    l = c.extras.onSameUrlNavigation ?? t.onSameUrlNavigation;
                  if (!u && l !== "reload") {
                    let h = "";
                    return (
                      this.events.next(
                        new as(
                          c.id,
                          this.urlSerializer.serialize(c.rawUrl),
                          h,
                          uf.IgnoredSameUrlNavigation
                        )
                      ),
                      c.resolve(!1),
                      fn
                    );
                  }
                  if (this.urlHandlingStrategy.shouldProcessUrl(c.rawUrl))
                    return oe(c).pipe(
                      ct((h) => {
                        let f = this.transitions?.getValue();
                        return (
                          this.events.next(
                            new Da(
                              h.id,
                              this.urlSerializer.serialize(h.extractedUrl),
                              h.source,
                              h.restoredState
                            )
                          ),
                          f !== this.transitions?.getValue()
                            ? fn
                            : Promise.resolve(h)
                        );
                      }),
                      FP(
                        this.environmentInjector,
                        this.configLoader,
                        this.rootComponentType,
                        t.config,
                        this.urlSerializer,
                        this.paramsInheritanceStrategy
                      ),
                      Oe((h) => {
                        (s.targetSnapshot = h.targetSnapshot),
                          (s.urlAfterRedirects = h.urlAfterRedirects),
                          (this.currentNavigation = $(
                            v({}, this.currentNavigation),
                            { finalUrl: h.urlAfterRedirects }
                          ));
                        let f = new lf(
                          h.id,
                          this.urlSerializer.serialize(h.extractedUrl),
                          this.urlSerializer.serialize(h.urlAfterRedirects),
                          h.targetSnapshot
                        );
                        this.events.next(f);
                      })
                    );
                  if (
                    u &&
                    this.urlHandlingStrategy.shouldProcessUrl(c.currentRawUrl)
                  ) {
                    let {
                        id: h,
                        extractedUrl: f,
                        source: g,
                        restoredState: y,
                        extras: w,
                      } = c,
                      m = new Da(h, this.urlSerializer.serialize(f), g, y);
                    this.events.next(m);
                    let b = J1(this.rootComponentType).snapshot;
                    return (
                      (this.currentTransition = s =
                        $(v({}, c), {
                          targetSnapshot: b,
                          urlAfterRedirects: f,
                          extras: $(v({}, w), {
                            skipLocationChange: !1,
                            replaceUrl: !1,
                          }),
                        })),
                      (this.currentNavigation.finalUrl = f),
                      oe(s)
                    );
                  } else {
                    let h = "";
                    return (
                      this.events.next(
                        new as(
                          c.id,
                          this.urlSerializer.serialize(c.extractedUrl),
                          h,
                          uf.IgnoredByUrlHandlingStrategy
                        )
                      ),
                      c.resolve(!1),
                      fn
                    );
                  }
                }),
                Oe((c) => {
                  let u = new Xm(
                    c.id,
                    this.urlSerializer.serialize(c.extractedUrl),
                    this.urlSerializer.serialize(c.urlAfterRedirects),
                    c.targetSnapshot
                  );
                  this.events.next(u);
                }),
                xe(
                  (c) => (
                    (this.currentTransition = s =
                      $(v({}, c), {
                        guards: rP(
                          c.targetSnapshot,
                          c.currentSnapshot,
                          this.rootContexts
                        ),
                      })),
                    s
                  )
                ),
                pP(this.environmentInjector, (c) => this.events.next(c)),
                Oe((c) => {
                  if (
                    ((s.guardsResult = c.guardsResult),
                    c.guardsResult && typeof c.guardsResult != "boolean")
                  )
                    throw mf(this.urlSerializer, c.guardsResult);
                  let u = new e0(
                    c.id,
                    this.urlSerializer.serialize(c.extractedUrl),
                    this.urlSerializer.serialize(c.urlAfterRedirects),
                    c.targetSnapshot,
                    !!c.guardsResult
                  );
                  this.events.next(u);
                }),
                xn((c) =>
                  c.guardsResult
                    ? !0
                    : (this.cancelNavigationTransition(c, "", Qn.GuardRejected),
                      !1)
                ),
                Km((c) => {
                  if (c.guards.canActivateChecks.length)
                    return oe(c).pipe(
                      Oe((u) => {
                        let l = new t0(
                          u.id,
                          this.urlSerializer.serialize(u.extractedUrl),
                          this.urlSerializer.serialize(u.urlAfterRedirects),
                          u.targetSnapshot
                        );
                        this.events.next(l);
                      }),
                      ct((u) => {
                        let l = !1;
                        return oe(u).pipe(
                          MP(
                            this.paramsInheritanceStrategy,
                            this.environmentInjector
                          ),
                          Oe({
                            next: () => (l = !0),
                            complete: () => {
                              l ||
                                this.cancelNavigationTransition(
                                  u,
                                  "",
                                  Qn.NoDataFromResolver
                                );
                            },
                          })
                        );
                      }),
                      Oe((u) => {
                        let l = new n0(
                          u.id,
                          this.urlSerializer.serialize(u.extractedUrl),
                          this.urlSerializer.serialize(u.urlAfterRedirects),
                          u.targetSnapshot
                        );
                        this.events.next(l);
                      })
                    );
                }),
                Km((c) => {
                  let u = (l) => {
                    let h = [];
                    l.routeConfig?.loadComponent &&
                      !l.routeConfig._loadedComponent &&
                      h.push(
                        this.configLoader.loadComponent(l.routeConfig).pipe(
                          Oe((f) => {
                            l.component = f;
                          }),
                          xe(() => {})
                        )
                      );
                    for (let f of l.children) h.push(...u(f));
                    return h;
                  };
                  return dn(u(c.targetSnapshot.root)).pipe(Zg(null), br(1));
                }),
                Km(() => this.afterPreactivation()),
                ct(() => {
                  let { currentSnapshot: c, targetSnapshot: u } = s,
                    l = this.createViewTransition?.(
                      this.environmentInjector,
                      c.root,
                      u.root
                    );
                  return l ? Ke(l).pipe(xe(() => s)) : oe(s);
                }),
                xe((c) => {
                  let u = Z_(
                    t.routeReuseStrategy,
                    c.targetSnapshot,
                    c.currentRouterState
                  );
                  return (
                    (this.currentTransition = s =
                      $(v({}, c), { targetRouterState: u })),
                    (this.currentNavigation.targetRouterState = u),
                    s
                  );
                }),
                Oe(() => {
                  this.events.next(new Ku());
                }),
                nP(
                  this.rootContexts,
                  t.routeReuseStrategy,
                  (c) => this.events.next(c),
                  this.inputBindingEnabled
                ),
                br(1),
                Oe({
                  next: (c) => {
                    (o = !0),
                      (this.lastSuccessfulNavigation = this.currentNavigation),
                      this.events.next(
                        new Kr(
                          c.id,
                          this.urlSerializer.serialize(c.extractedUrl),
                          this.urlSerializer.serialize(c.urlAfterRedirects)
                        )
                      ),
                      this.titleStrategy?.updateTitle(
                        c.targetRouterState.snapshot
                      ),
                      c.resolve(!0);
                  },
                  complete: () => {
                    o = !0;
                  },
                }),
                Hr(
                  this.transitionAbortSubject.pipe(
                    Oe((c) => {
                      throw c;
                    })
                  )
                ),
                Wr(() => {
                  !o &&
                    !a &&
                    this.cancelNavigationTransition(
                      s,
                      "",
                      Qn.SupersededByNewNavigation
                    ),
                    this.currentTransition?.id === s.id &&
                      ((this.currentNavigation = null),
                      (this.currentTransition = null));
                }),
                _n((c) => {
                  if (((a = !0), tx(c)))
                    this.events.next(
                      new Si(
                        s.id,
                        this.urlSerializer.serialize(s.extractedUrl),
                        c.message,
                        c.cancellationCode
                      )
                    ),
                      tP(c)
                        ? this.events.next(
                            new _a(c.url, c.navigationBehaviorOptions)
                          )
                        : s.resolve(!1);
                  else {
                    let u = new Gu(
                      s.id,
                      this.urlSerializer.serialize(s.extractedUrl),
                      c,
                      s.targetSnapshot ?? void 0
                    );
                    try {
                      let l = ar(this.environmentInjector, () =>
                        this.navigationErrorHandler?.(u)
                      );
                      if (l instanceof Qu) {
                        let { message: h, cancellationCode: f } = mf(
                          this.urlSerializer,
                          l
                        );
                        this.events.next(
                          new Si(
                            s.id,
                            this.urlSerializer.serialize(s.extractedUrl),
                            h,
                            f
                          )
                        ),
                          this.events.next(
                            new _a(l.redirectTo, l.navigationBehaviorOptions)
                          );
                      } else {
                        this.events.next(u);
                        let h = t.errorHandler(c);
                        s.resolve(!!h);
                      }
                    } catch (l) {
                      this.options.resolveNavigationPromiseOnError
                        ? s.resolve(!1)
                        : s.reject(l);
                    }
                  }
                  return fn;
                })
              );
            })
          )
        );
      }
      cancelNavigationTransition(t, r, i) {
        let s = new Si(
          t.id,
          this.urlSerializer.serialize(t.extractedUrl),
          r,
          i
        );
        this.events.next(s), t.resolve(!1);
      }
      isUpdatingInternalState() {
        return (
          this.currentTransition?.extractedUrl.toString() !==
          this.currentTransition?.currentUrlTree.toString()
        );
      }
      isUpdatedBrowserUrl() {
        let t = this.urlHandlingStrategy.extract(
            this.urlSerializer.parse(this.location.path(!0))
          ),
          r =
            this.currentNavigation?.targetBrowserUrl ??
            this.currentNavigation?.extractedUrl;
        return (
          t.toString() !== r?.toString() &&
          !this.currentNavigation?.extras.skipLocationChange
        );
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })();
function JP(n) {
  return n !== Hu;
}
var YP = (() => {
    class n {
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: () => M(ZP), providedIn: "root" });
      }
    }
    return n;
  })(),
  b0 = class {
    shouldDetach(e) {
      return !1;
    }
    store(e, t) {}
    shouldAttach(e) {
      return !1;
    }
    retrieve(e) {
      return null;
    }
    shouldReuseRoute(e, t) {
      return e.routeConfig === t.routeConfig;
    }
  },
  ZP = (() => {
    class n extends b0 {
      static {
        this.ɵfac = (() => {
          let t;
          return function (i) {
            return (t || (t = Bh(n)))(i || n);
          };
        })();
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })(),
  hx = (() => {
    class n {
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: () => M(XP), providedIn: "root" });
      }
    }
    return n;
  })(),
  XP = (() => {
    class n extends hx {
      constructor() {
        super(...arguments),
          (this.location = M(xa)),
          (this.urlSerializer = M(La)),
          (this.options = M(rl, { optional: !0 }) || {}),
          (this.canceledNavigationResolution =
            this.options.canceledNavigationResolution || "replace"),
          (this.urlHandlingStrategy = M(S0)),
          (this.urlUpdateStrategy =
            this.options.urlUpdateStrategy || "deferred"),
          (this.currentUrlTree = new vi()),
          (this.rawUrlTree = this.currentUrlTree),
          (this.currentPageId = 0),
          (this.lastSuccessfulId = -1),
          (this.routerState = J1(null)),
          (this.stateMemento = this.createStateMemento());
      }
      getCurrentUrlTree() {
        return this.currentUrlTree;
      }
      getRawUrlTree() {
        return this.rawUrlTree;
      }
      restoredState() {
        return this.location.getState();
      }
      get browserPageId() {
        return this.canceledNavigationResolution !== "computed"
          ? this.currentPageId
          : this.restoredState()?.ɵrouterPageId ?? this.currentPageId;
      }
      getRouterState() {
        return this.routerState;
      }
      createStateMemento() {
        return {
          rawUrlTree: this.rawUrlTree,
          currentUrlTree: this.currentUrlTree,
          routerState: this.routerState,
        };
      }
      registerNonRouterCurrentEntryChangeListener(t) {
        return this.location.subscribe((r) => {
          r.type === "popstate" && t(r.url, r.state);
        });
      }
      handleRouterEvent(t, r) {
        if (t instanceof Da) this.stateMemento = this.createStateMemento();
        else if (t instanceof as) this.rawUrlTree = r.initialUrl;
        else if (t instanceof lf) {
          if (
            this.urlUpdateStrategy === "eager" &&
            !r.extras.skipLocationChange
          ) {
            let i = this.urlHandlingStrategy.merge(r.finalUrl, r.initialUrl);
            this.setBrowserUrl(r.targetBrowserUrl ?? i, r);
          }
        } else
          t instanceof Ku
            ? ((this.currentUrlTree = r.finalUrl),
              (this.rawUrlTree = this.urlHandlingStrategy.merge(
                r.finalUrl,
                r.initialUrl
              )),
              (this.routerState = r.targetRouterState),
              this.urlUpdateStrategy === "deferred" &&
                !r.extras.skipLocationChange &&
                this.setBrowserUrl(r.targetBrowserUrl ?? this.rawUrlTree, r))
            : t instanceof Si &&
              (t.code === Qn.GuardRejected || t.code === Qn.NoDataFromResolver)
            ? this.restoreHistory(r)
            : t instanceof Gu
            ? this.restoreHistory(r, !0)
            : t instanceof Kr &&
              ((this.lastSuccessfulId = t.id),
              (this.currentPageId = this.browserPageId));
      }
      setBrowserUrl(t, r) {
        let i = t instanceof vi ? this.urlSerializer.serialize(t) : t;
        if (this.location.isCurrentPathEqualTo(i) || r.extras.replaceUrl) {
          let s = this.browserPageId,
            o = v(v({}, r.extras.state), this.generateNgRouterState(r.id, s));
          this.location.replaceState(i, "", o);
        } else {
          let s = v(
            v({}, r.extras.state),
            this.generateNgRouterState(r.id, this.browserPageId + 1)
          );
          this.location.go(i, "", s);
        }
      }
      restoreHistory(t, r = !1) {
        if (this.canceledNavigationResolution === "computed") {
          let i = this.browserPageId,
            s = this.currentPageId - i;
          s !== 0
            ? this.location.historyGo(s)
            : this.currentUrlTree === t.finalUrl &&
              s === 0 &&
              (this.resetState(t), this.resetUrlToCurrentUrlTree());
        } else
          this.canceledNavigationResolution === "replace" &&
            (r && this.resetState(t), this.resetUrlToCurrentUrlTree());
      }
      resetState(t) {
        (this.routerState = this.stateMemento.routerState),
          (this.currentUrlTree = this.stateMemento.currentUrlTree),
          (this.rawUrlTree = this.urlHandlingStrategy.merge(
            this.currentUrlTree,
            t.finalUrl ?? this.rawUrlTree
          ));
      }
      resetUrlToCurrentUrlTree() {
        this.location.replaceState(
          this.urlSerializer.serialize(this.rawUrlTree),
          "",
          this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)
        );
      }
      generateNgRouterState(t, r) {
        return this.canceledNavigationResolution === "computed"
          ? { navigationId: t, ɵrouterPageId: r }
          : { navigationId: t };
      }
      static {
        this.ɵfac = (() => {
          let t;
          return function (i) {
            return (t || (t = Bh(n)))(i || n);
          };
        })();
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })(),
  ju = (function (n) {
    return (
      (n[(n.COMPLETE = 0)] = "COMPLETE"),
      (n[(n.FAILED = 1)] = "FAILED"),
      (n[(n.REDIRECTING = 2)] = "REDIRECTING"),
      n
    );
  })(ju || {});
function fx(n, e) {
  n.events
    .pipe(
      xn(
        (t) =>
          t instanceof Kr ||
          t instanceof Si ||
          t instanceof Gu ||
          t instanceof as
      ),
      xe((t) =>
        t instanceof Kr || t instanceof as
          ? ju.COMPLETE
          : (
              t instanceof Si
                ? t.code === Qn.Redirect ||
                  t.code === Qn.SupersededByNewNavigation
                : !1
            )
          ? ju.REDIRECTING
          : ju.FAILED
      ),
      xn((t) => t !== ju.REDIRECTING),
      br(1)
    )
    .subscribe(() => {
      e();
    });
}
function eL(n) {
  throw n;
}
var tL = {
    paths: "exact",
    fragment: "ignored",
    matrixParams: "ignored",
    queryParams: "exact",
  },
  nL = {
    paths: "subset",
    fragment: "ignored",
    matrixParams: "ignored",
    queryParams: "subset",
  },
  Er = (() => {
    class n {
      get currentUrlTree() {
        return this.stateManager.getCurrentUrlTree();
      }
      get rawUrlTree() {
        return this.stateManager.getRawUrlTree();
      }
      get events() {
        return this._events;
      }
      get routerState() {
        return this.stateManager.getRouterState();
      }
      constructor() {
        (this.disposed = !1),
          (this.console = M(Oh)),
          (this.stateManager = M(hx)),
          (this.options = M(rl, { optional: !0 }) || {}),
          (this.pendingTasks = M(Dh)),
          (this.urlUpdateStrategy =
            this.options.urlUpdateStrategy || "deferred"),
          (this.navigationTransitions = M(Ef)),
          (this.urlSerializer = M(La)),
          (this.location = M(xa)),
          (this.urlHandlingStrategy = M(S0)),
          (this._events = new rr()),
          (this.errorHandler = this.options.errorHandler || eL),
          (this.navigated = !1),
          (this.routeReuseStrategy = M(YP)),
          (this.onSameUrlNavigation =
            this.options.onSameUrlNavigation || "ignore"),
          (this.config = M(Zu, { optional: !0 })?.flat() ?? []),
          (this.componentInputBindingEnabled = !!M(bf, { optional: !0 })),
          (this.eventsSubscription = new Ch()),
          this.resetConfig(this.config),
          this.navigationTransitions
            .setupNavigations(this, this.currentUrlTree, this.routerState)
            .subscribe({
              error: (t) => {
                this.console.warn(t);
              },
            }),
          this.subscribeToNavigationEvents();
      }
      subscribeToNavigationEvents() {
        let t = this.navigationTransitions.events.subscribe((r) => {
          try {
            let i = this.navigationTransitions.currentTransition,
              s = this.navigationTransitions.currentNavigation;
            if (i !== null && s !== null) {
              if (
                (this.stateManager.handleRouterEvent(r, s),
                r instanceof Si &&
                  r.code !== Qn.Redirect &&
                  r.code !== Qn.SupersededByNewNavigation)
              )
                this.navigated = !0;
              else if (r instanceof Kr) this.navigated = !0;
              else if (r instanceof _a) {
                let o = r.navigationBehaviorOptions,
                  a = this.urlHandlingStrategy.merge(r.url, i.currentRawUrl),
                  c = v(
                    {
                      browserUrl: i.extras.browserUrl,
                      info: i.extras.info,
                      skipLocationChange: i.extras.skipLocationChange,
                      replaceUrl:
                        i.extras.replaceUrl ||
                        this.urlUpdateStrategy === "eager" ||
                        JP(i.source),
                    },
                    o
                  );
                this.scheduleNavigation(a, Hu, null, c, {
                  resolve: i.resolve,
                  reject: i.reject,
                  promise: i.promise,
                });
              }
            }
            iL(r) && this._events.next(r);
          } catch (i) {
            this.navigationTransitions.transitionAbortSubject.next(i);
          }
        });
        this.eventsSubscription.add(t);
      }
      resetRootComponentType(t) {
        (this.routerState.root.component = t),
          (this.navigationTransitions.rootComponentType = t);
      }
      initialNavigation() {
        this.setUpLocationChangeListener(),
          this.navigationTransitions.hasRequestedNavigation ||
            this.navigateToSyncWithBrowser(
              this.location.path(!0),
              Hu,
              this.stateManager.restoredState()
            );
      }
      setUpLocationChangeListener() {
        this.nonRouterCurrentEntryChangeSubscription ??=
          this.stateManager.registerNonRouterCurrentEntryChangeListener(
            (t, r) => {
              setTimeout(() => {
                this.navigateToSyncWithBrowser(t, "popstate", r);
              }, 0);
            }
          );
      }
      navigateToSyncWithBrowser(t, r, i) {
        let s = { replaceUrl: !0 },
          o = i?.navigationId ? i : null;
        if (i) {
          let c = v({}, i);
          delete c.navigationId,
            delete c.ɵrouterPageId,
            Object.keys(c).length !== 0 && (s.state = c);
        }
        let a = this.parseUrl(t);
        this.scheduleNavigation(a, r, o, s);
      }
      get url() {
        return this.serializeUrl(this.currentUrlTree);
      }
      getCurrentNavigation() {
        return this.navigationTransitions.currentNavigation;
      }
      get lastSuccessfulNavigation() {
        return this.navigationTransitions.lastSuccessfulNavigation;
      }
      resetConfig(t) {
        (this.config = t.map(E0)), (this.navigated = !1);
      }
      ngOnDestroy() {
        this.dispose();
      }
      dispose() {
        this.navigationTransitions.complete(),
          this.nonRouterCurrentEntryChangeSubscription &&
            (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(),
            (this.nonRouterCurrentEntryChangeSubscription = void 0)),
          (this.disposed = !0),
          this.eventsSubscription.unsubscribe();
      }
      createUrlTree(t, r = {}) {
        let {
            relativeTo: i,
            queryParams: s,
            fragment: o,
            queryParamsHandling: a,
            preserveFragment: c,
          } = r,
          u = c ? this.currentUrlTree.fragment : o,
          l = null;
        switch (a ?? this.options.defaultQueryParamsHandling) {
          case "merge":
            l = v(v({}, this.currentUrlTree.queryParams), s);
            break;
          case "preserve":
            l = this.currentUrlTree.queryParams;
            break;
          default:
            l = s || null;
        }
        l !== null && (l = this.removeEmptyProps(l));
        let h;
        try {
          let f = i ? i.snapshot : this.routerState.snapshot.root;
          h = G1(f);
        } catch {
          (typeof t[0] != "string" || t[0][0] !== "/") && (t = []),
            (h = this.currentUrlTree.root);
        }
        return K1(h, t, l, u ?? null);
      }
      navigateByUrl(t, r = { skipLocationChange: !1 }) {
        let i = oo(t) ? t : this.parseUrl(t),
          s = this.urlHandlingStrategy.merge(i, this.rawUrlTree);
        return this.scheduleNavigation(s, Hu, null, r);
      }
      navigate(t, r = { skipLocationChange: !1 }) {
        return rL(t), this.navigateByUrl(this.createUrlTree(t, r), r);
      }
      serializeUrl(t) {
        return this.urlSerializer.serialize(t);
      }
      parseUrl(t) {
        try {
          return this.urlSerializer.parse(t);
        } catch {
          return this.urlSerializer.parse("/");
        }
      }
      isActive(t, r) {
        let i;
        if (
          (r === !0 ? (i = v({}, tL)) : r === !1 ? (i = v({}, nL)) : (i = r),
          oo(t))
        )
          return C1(this.currentUrlTree, t, i);
        let s = this.parseUrl(t);
        return C1(this.currentUrlTree, s, i);
      }
      removeEmptyProps(t) {
        return Object.entries(t).reduce(
          (r, [i, s]) => (s != null && (r[i] = s), r),
          {}
        );
      }
      scheduleNavigation(t, r, i, s, o) {
        if (this.disposed) return Promise.resolve(!1);
        let a, c, u;
        o
          ? ((a = o.resolve), (c = o.reject), (u = o.promise))
          : (u = new Promise((h, f) => {
              (a = h), (c = f);
            }));
        let l = this.pendingTasks.add();
        return (
          fx(this, () => {
            queueMicrotask(() => this.pendingTasks.remove(l));
          }),
          this.navigationTransitions.handleNavigationRequest({
            source: r,
            restoredState: i,
            currentUrlTree: this.currentUrlTree,
            currentRawUrl: this.currentUrlTree,
            rawUrl: t,
            extras: s,
            resolve: a,
            reject: c,
            promise: u,
            currentSnapshot: this.routerState.snapshot,
            currentRouterState: this.routerState,
          }),
          u.catch((h) => Promise.reject(h))
        );
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })();
function rL(n) {
  for (let e = 0; e < n.length; e++) if (n[e] == null) throw new rt(4008, !1);
}
function iL(n) {
  return !(n instanceof Ku) && !(n instanceof _a);
}
var WH = (() => {
  class n {
    constructor(t, r, i, s, o, a) {
      (this.router = t),
        (this.route = r),
        (this.tabIndexAttribute = i),
        (this.renderer = s),
        (this.el = o),
        (this.locationStrategy = a),
        (this.href = null),
        (this.onChanges = new rr()),
        (this.preserveFragment = !1),
        (this.skipLocationChange = !1),
        (this.replaceUrl = !1),
        (this.routerLinkInput = null);
      let c = o.nativeElement.tagName?.toLowerCase();
      (this.isAnchorElement = c === "a" || c === "area"),
        this.isAnchorElement
          ? (this.subscription = t.events.subscribe((u) => {
              u instanceof Kr && this.updateHref();
            }))
          : this.setTabIndexIfNotOnNativeEl("0");
    }
    setTabIndexIfNotOnNativeEl(t) {
      this.tabIndexAttribute != null ||
        this.isAnchorElement ||
        this.applyAttributeValue("tabindex", t);
    }
    ngOnChanges(t) {
      this.isAnchorElement && this.updateHref(), this.onChanges.next(this);
    }
    set routerLink(t) {
      t == null
        ? ((this.routerLinkInput = null), this.setTabIndexIfNotOnNativeEl(null))
        : (oo(t)
            ? (this.routerLinkInput = t)
            : (this.routerLinkInput = Array.isArray(t) ? t : [t]),
          this.setTabIndexIfNotOnNativeEl("0"));
    }
    onClick(t, r, i, s, o) {
      let a = this.urlTree;
      if (
        a === null ||
        (this.isAnchorElement &&
          (t !== 0 ||
            r ||
            i ||
            s ||
            o ||
            (typeof this.target == "string" && this.target != "_self")))
      )
        return !0;
      let c = {
        skipLocationChange: this.skipLocationChange,
        replaceUrl: this.replaceUrl,
        state: this.state,
        info: this.info,
      };
      return this.router.navigateByUrl(a, c), !this.isAnchorElement;
    }
    ngOnDestroy() {
      this.subscription?.unsubscribe();
    }
    updateHref() {
      let t = this.urlTree;
      this.href =
        t !== null && this.locationStrategy
          ? this.locationStrategy?.prepareExternalUrl(
              this.router.serializeUrl(t)
            )
          : null;
      let r =
        this.href === null
          ? null
          : wE(this.href, this.el.nativeElement.tagName.toLowerCase(), "href");
      this.applyAttributeValue("href", r);
    }
    applyAttributeValue(t, r) {
      let i = this.renderer,
        s = this.el.nativeElement;
      r !== null ? i.setAttribute(s, t, r) : i.removeAttribute(s, t);
    }
    get urlTree() {
      return this.routerLinkInput === null
        ? null
        : oo(this.routerLinkInput)
        ? this.routerLinkInput
        : this.router.createUrlTree(this.routerLinkInput, {
            relativeTo:
              this.relativeTo !== void 0 ? this.relativeTo : this.route,
            queryParams: this.queryParams,
            fragment: this.fragment,
            queryParamsHandling: this.queryParamsHandling,
            preserveFragment: this.preserveFragment,
          });
    }
    static {
      this.ɵfac = function (r) {
        return new (r || n)(
          mt(Er),
          mt(cs),
          nm("tabindex"),
          mt(yi),
          mt(mi),
          mt(Ei)
        );
      };
    }
    static {
      this.ɵdir = sr({
        type: n,
        selectors: [["", "routerLink", ""]],
        hostVars: 1,
        hostBindings: function (r, i) {
          r & 1 &&
            TE("click", function (o) {
              return i.onClick(
                o.button,
                o.ctrlKey,
                o.shiftKey,
                o.altKey,
                o.metaKey
              );
            }),
            r & 2 && Ph("target", i.target);
        },
        inputs: {
          target: "target",
          queryParams: "queryParams",
          fragment: "fragment",
          queryParamsHandling: "queryParamsHandling",
          state: "state",
          info: "info",
          relativeTo: "relativeTo",
          preserveFragment: [2, "preserveFragment", "preserveFragment", wi],
          skipLocationChange: [
            2,
            "skipLocationChange",
            "skipLocationChange",
            wi,
          ],
          replaceUrl: [2, "replaceUrl", "replaceUrl", wi],
          routerLink: "routerLink",
        },
        standalone: !0,
        features: [_h, es],
      });
    }
  }
  return n;
})();
var wf = class {};
var sL = (() => {
    class n {
      constructor(t, r, i, s, o) {
        (this.router = t),
          (this.injector = i),
          (this.preloadingStrategy = s),
          (this.loader = o);
      }
      setUpPreloading() {
        this.subscription = this.router.events
          .pipe(
            xn((t) => t instanceof Kr),
            Sn(() => this.preload())
          )
          .subscribe(() => {});
      }
      preload() {
        return this.processRoutes(this.injector, this.router.config);
      }
      ngOnDestroy() {
        this.subscription && this.subscription.unsubscribe();
      }
      processRoutes(t, r) {
        let i = [];
        for (let s of r) {
          s.providers &&
            !s._injector &&
            (s._injector = am(s.providers, t, `Route: ${s.path}`));
          let o = s._injector ?? t,
            a = s._loadedInjector ?? o;
          ((s.loadChildren && !s._loadedRoutes && s.canLoad === void 0) ||
            (s.loadComponent && !s._loadedComponent)) &&
            i.push(this.preloadConfig(o, s)),
            (s.children || s._loadedRoutes) &&
              i.push(this.processRoutes(a, s.children ?? s._loadedRoutes));
        }
        return Ke(i).pipe(Jg());
      }
      preloadConfig(t, r) {
        return this.preloadingStrategy.preload(r, () => {
          let i;
          r.loadChildren && r.canLoad === void 0
            ? (i = this.loader.loadChildren(t, r))
            : (i = oe(null));
          let s = i.pipe(
            Gn((o) =>
              o === null
                ? oe(void 0)
                : ((r._loadedRoutes = o.routes),
                  (r._loadedInjector = o.injector),
                  this.processRoutes(o.injector ?? t, o.routes))
            )
          );
          if (r.loadComponent && !r._loadedComponent) {
            let o = this.loader.loadComponent(r);
            return Ke([s, o]).pipe(Jg());
          } else return s;
        });
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(Er), le(zh), le(eo), le(wf), le(x0));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
      }
    }
    return n;
  })(),
  v0 = new Ae(""),
  dx = (() => {
    class n {
      constructor(t, r, i, s, o = {}) {
        (this.urlSerializer = t),
          (this.transitions = r),
          (this.viewportScroller = i),
          (this.zone = s),
          (this.options = o),
          (this.lastId = 0),
          (this.lastSource = "imperative"),
          (this.restoredId = 0),
          (this.store = {}),
          (o.scrollPositionRestoration ||= "disabled"),
          (o.anchorScrolling ||= "disabled");
      }
      init() {
        this.options.scrollPositionRestoration !== "disabled" &&
          this.viewportScroller.setHistoryScrollRestoration("manual"),
          (this.routerEventsSubscription = this.createScrollEvents()),
          (this.scrollEventsSubscription = this.consumeScrollEvents());
      }
      createScrollEvents() {
        return this.transitions.events.subscribe((t) => {
          t instanceof Da
            ? ((this.store[this.lastId] =
                this.viewportScroller.getScrollPosition()),
              (this.lastSource = t.navigationTrigger),
              (this.restoredId = t.restoredState
                ? t.restoredState.navigationId
                : 0))
            : t instanceof Kr
            ? ((this.lastId = t.id),
              this.scheduleScrollEvent(
                t,
                this.urlSerializer.parse(t.urlAfterRedirects).fragment
              ))
            : t instanceof as &&
              t.code === uf.IgnoredSameUrlNavigation &&
              ((this.lastSource = void 0),
              (this.restoredId = 0),
              this.scheduleScrollEvent(
                t,
                this.urlSerializer.parse(t.url).fragment
              ));
        });
      }
      consumeScrollEvents() {
        return this.transitions.events.subscribe((t) => {
          t instanceof hf &&
            (t.position
              ? this.options.scrollPositionRestoration === "top"
                ? this.viewportScroller.scrollToPosition([0, 0])
                : this.options.scrollPositionRestoration === "enabled" &&
                  this.viewportScroller.scrollToPosition(t.position)
              : t.anchor && this.options.anchorScrolling === "enabled"
              ? this.viewportScroller.scrollToAnchor(t.anchor)
              : this.options.scrollPositionRestoration !== "disabled" &&
                this.viewportScroller.scrollToPosition([0, 0]));
        });
      }
      scheduleScrollEvent(t, r) {
        this.zone.runOutsideAngular(() => {
          setTimeout(() => {
            this.zone.run(() => {
              this.transitions.events.next(
                new hf(
                  t,
                  this.lastSource === "popstate"
                    ? this.store[this.restoredId]
                    : null,
                  r
                )
              );
            });
          }, 0);
        });
      }
      ngOnDestroy() {
        this.routerEventsSubscription?.unsubscribe(),
          this.scrollEventsSubscription?.unsubscribe();
      }
      static {
        this.ɵfac = function (r) {
          bE();
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })();
function HH(n, ...e) {
  return or([
    { provide: Zu, multi: !0, useValue: n },
    [],
    { provide: cs, useFactory: px, deps: [Er] },
    { provide: Mh, multi: !0, useFactory: gx },
    e.map((t) => t.ɵproviders),
  ]);
}
function px(n) {
  return n.routerState.root;
}
function Na(n, e) {
  return { ɵkind: n, ɵproviders: e };
}
function VH(n = {}) {
  return Na(4, [
    {
      provide: v0,
      useFactory: () => {
        let t = M(Bm),
          r = M(Kn),
          i = M(Ef),
          s = M(La);
        return new dx(s, i, t, r, n);
      },
    },
  ]);
}
function gx() {
  let n = M(pi);
  return (e) => {
    let t = n.get(Uh);
    if (e !== t.components[0]) return;
    let r = n.get(Er),
      i = n.get(mx);
    n.get(I0) === 1 && r.initialNavigation(),
      n.get(yx, null, em.Optional)?.setUpPreloading(),
      n.get(v0, null, em.Optional)?.init(),
      r.resetRootComponentType(t.componentTypes[0]),
      i.closed || (i.next(), i.complete(), i.unsubscribe());
  };
}
var mx = new Ae("", { factory: () => new rr() }),
  I0 = new Ae("", { providedIn: "root", factory: () => 1 });
function oL() {
  return Na(2, [
    { provide: I0, useValue: 0 },
    {
      provide: Fh,
      multi: !0,
      deps: [pi],
      useFactory: (e) => {
        let t = e.get(n1, Promise.resolve());
        return () =>
          t.then(
            () =>
              new Promise((r) => {
                let i = e.get(Er),
                  s = e.get(mx);
                fx(i, () => {
                  r(!0);
                }),
                  (e.get(Ef).afterPreactivation = () => (
                    r(!0), s.closed ? oe(void 0) : s
                  )),
                  i.initialNavigation();
              })
          );
      },
    },
  ]);
}
function aL() {
  return Na(3, [
    {
      provide: Fh,
      multi: !0,
      useFactory: () => {
        let e = M(Er);
        return () => {
          e.setUpLocationChangeListener();
        };
      },
    },
    { provide: I0, useValue: 2 },
  ]);
}
var yx = new Ae("");
function cL(n) {
  return Na(0, [
    { provide: yx, useExisting: sL },
    { provide: wf, useExisting: n },
  ]);
}
function uL() {
  return Na(8, [B1, { provide: bf, useExisting: B1 }]);
}
function lL(n) {
  let e = [
    { provide: ux, useValue: KP },
    {
      provide: lx,
      useValue: v({ skipNextTransition: !!n?.skipInitialTransition }, n),
    },
  ];
  return Na(9, e);
}
var L1 = new Ae("ROUTER_FORROOT_GUARD"),
  hL = [
    xa,
    { provide: La, useClass: Ba },
    Er,
    tl,
    { provide: cs, useFactory: px, deps: [Er] },
    x0,
    [],
  ],
  $H = (() => {
    class n {
      constructor(t) {}
      static forRoot(t, r) {
        return {
          ngModule: n,
          providers: [
            hL,
            [],
            { provide: Zu, multi: !0, useValue: t },
            { provide: L1, useFactory: gL, deps: [[Er, new tm(), new nE()]] },
            { provide: rl, useValue: r || {} },
            r?.useHash ? dL() : pL(),
            fL(),
            r?.preloadingStrategy ? cL(r.preloadingStrategy).ɵproviders : [],
            r?.initialNavigation ? mL(r) : [],
            r?.bindToComponentInputs ? uL().ɵproviders : [],
            r?.enableViewTransitions ? lL().ɵproviders : [],
            yL(),
          ],
        };
      }
      static forChild(t) {
        return {
          ngModule: n,
          providers: [{ provide: Zu, multi: !0, useValue: t }],
        };
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(L1, 8));
        };
      }
      static {
        this.ɵmod = Xs({ type: n });
      }
      static {
        this.ɵinj = Zs({});
      }
    }
    return n;
  })();
function fL() {
  return {
    provide: v0,
    useFactory: () => {
      let n = M(Bm),
        e = M(Kn),
        t = M(rl),
        r = M(Ef),
        i = M(La);
      return (
        t.scrollOffset && n.setOffset(t.scrollOffset), new dx(i, r, n, e, t)
      );
    },
  };
}
function dL() {
  return { provide: Ei, useClass: i1 };
}
function pL() {
  return { provide: Ei, useClass: Sm };
}
function gL(n) {
  return "guarded";
}
function mL(n) {
  return [
    n.initialNavigation === "disabled" ? aL().ɵproviders : [],
    n.initialNavigation === "enabledBlocking" ? oL().ɵproviders : [],
  ];
}
var O1 = new Ae("");
function yL() {
  return [
    { provide: O1, useFactory: gx },
    { provide: Mh, multi: !0, useExisting: O1 },
  ];
}
p();
var wx = class n {
  size = sE(40);
  static ɵfac = function (t) {
    return new (t || n)();
  };
  static ɵcmp = da({
    type: n,
    selectors: [["app-spinner"]],
    inputs: { size: [1, "size"] },
    standalone: !0,
    features: [ba],
    decls: 3,
    vars: 2,
    consts: [
      [
        "aria-hidden",
        "true",
        "viewBox",
        "0 0 100 101",
        "fill",
        "none",
        "xmlns",
        "http://www.w3.org/2000/svg",
        1,
        "text-gray-200",
        "animate-spin",
        "dark:text-gray-600",
        "fill-red",
      ],
      [
        "d",
        "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
        "fill",
        "currentColor",
      ],
      [
        "d",
        "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
        "fill",
        "currentFill",
      ],
    ],
    template: function (t, r) {
      t & 1 && (iE(), CE(0, "svg", 0), ya(1, "path", 1)(2, "path", 2), kE()),
        t & 2 && Ph("width", r.size())("height", r.size());
    },
    encapsulation: 2,
    changeDetection: 0,
  });
};
p();
p();
function ao(n) {
  n || (ku(ao), (n = M(gi)));
  let e = new Ys((t) => n.onDestroy(t.next.bind(t)));
  return (t) => t.pipe(Hr(e));
}
function wL(n, e) {
  !e?.injector && ku(wL);
  let t = e?.injector ?? M(pi),
    r = new xu(1),
    i = OE(
      () => {
        let s;
        try {
          s = n();
        } catch (o) {
          bi(() => r.error(o));
          return;
        }
        bi(() => r.next(s));
      },
      { injector: t, manualCleanup: !0 }
    );
  return (
    t.get(gi).onDestroy(() => {
      i.destroy(), r.complete();
    }),
    r.asObservable()
  );
}
function Ii(n, e) {
  let t = !e?.manualCleanup;
  t && !e?.injector && ku(Ii);
  let r = t ? e?.injector?.get(gi) ?? M(gi) : null,
    i = bL(e?.equal),
    s;
  e?.requireSync
    ? (s = Tu({ kind: 0 }, { equal: i }))
    : (s = Tu({ kind: 1, value: e?.initialValue }, { equal: i }));
  let o = n.subscribe({
    next: (a) => s.set({ kind: 1, value: a }),
    error: (a) => {
      if (e?.rejectErrors) throw a;
      s.set({ kind: 2, error: a });
    },
  });
  if (e?.requireSync && s().kind === 0) throw new rt(601, !1);
  return (
    r?.onDestroy(o.unsubscribe.bind(o)),
    Pn(
      () => {
        let a = s();
        switch (a.kind) {
          case 1:
            return a.value;
          case 2:
            throw a.error;
          case 0:
            throw new rt(601, !1);
        }
      },
      { equal: e?.equal }
    )
  );
}
function bL(n = Object.is) {
  return (e, t) => e.kind === 1 && t.kind === 1 && n(e.value, t.value);
}
p();
function bx(n) {
  return (
    n &&
    n.constructor &&
    typeof n.constructor.isBuffer == "function" &&
    n.constructor.isBuffer(n)
  );
}
function Ax(n) {
  return n;
}
function C0(n, e) {
  e = e || {};
  let t = e.delimiter || ".",
    r = e.maxDepth,
    i = e.transformKey || Ax,
    s = {};
  function o(a, c, u) {
    (u = u || 1),
      Object.keys(a).forEach(function (l) {
        let h = a[l],
          f = e.safe && Array.isArray(h),
          g = Object.prototype.toString.call(h),
          y = bx(h),
          w = g === "[object Object]" || g === "[object Array]",
          m = c ? c + t + i(l) : i(l);
        if (!f && !y && w && Object.keys(h).length && (!e.maxDepth || u < r))
          return o(h, m, u + 1);
        s[m] = h;
      });
  }
  return o(n), s;
}
function k0(n, e) {
  e = e || {};
  let t = e.delimiter || ".",
    r = e.overwrite || !1,
    i = e.transformKey || Ax,
    s = {};
  if (bx(n) || Object.prototype.toString.call(n) !== "[object Object]")
    return n;
  function a(l) {
    let h = Number(l);
    return isNaN(h) || l.indexOf(".") !== -1 || e.object ? l : h;
  }
  function c(l, h, f) {
    return Object.keys(f).reduce(function (g, y) {
      return (g[l + t + y] = f[y]), g;
    }, h);
  }
  function u(l) {
    let h = Object.prototype.toString.call(l),
      f = h === "[object Array]",
      g = h === "[object Object]";
    if (l) {
      if (f) return !l.length;
      if (g) return !Object.keys(l).length;
    } else return !0;
  }
  return (
    (n = Object.keys(n).reduce(function (l, h) {
      let f = Object.prototype.toString.call(n[h]);
      return !(f === "[object Object]" || f === "[object Array]") || u(n[h])
        ? ((l[h] = n[h]), l)
        : c(h, l, C0(n[h], e));
    }, {})),
    Object.keys(n).forEach(function (l) {
      let h = l.split(t).map(i),
        f = a(h.shift()),
        g = a(h[0]),
        y = s;
      for (; g !== void 0; ) {
        if (f === "__proto__") return;
        let w = Object.prototype.toString.call(y[f]),
          m = w === "[object Object]" || w === "[object Array]";
        if (!r && !m && typeof y[f] < "u") return;
        ((r && !m) || (!r && y[f] == null)) &&
          (y[f] = typeof g == "number" && !e.object ? [] : {}),
          (y = y[f]),
          h.length > 0 && ((f = a(h.shift())), (g = a(h[0])));
      }
      y[f] = k0(n[l], e);
    }),
    s
  );
}
var B0 = class {
    translations;
    constructor(e) {
      this.translations = e;
    }
    getTranslation(e) {
      return oe(this.translations.get(e) || {});
    }
  },
  Sx = new Ae("TRANSLOCO_LOADER");
function T0(n, e) {
  return (
    n &&
    (Object.prototype.hasOwnProperty.call(n, e)
      ? n[e]
      : e.split(".").reduce((t, r) => t?.[r], n))
  );
}
function AL(n, e, t) {
  n = v({}, n);
  let r = e.split("."),
    i = r.length - 1;
  return (
    r.reduce(
      (s, o, a) => (
        a === i
          ? (s[o] = t)
          : (s[o] = Array.isArray(s[o]) ? s[o].slice() : v({}, s[o])),
        s && s[o]
      ),
      n
    ),
    n
  );
}
function vx(n) {
  return n
    ? Array.isArray(n)
      ? n.length
      : N0(n)
      ? Object.keys(n).length
      : n
      ? n.length
      : 0
    : 0;
}
function EL(n) {
  return vx(n) === 0;
}
function xL(n) {
  return typeof n == "function";
}
function Ma(n) {
  return typeof n == "string";
}
function N0(n) {
  return !!n && typeof n == "object" && !Array.isArray(n);
}
function Ix(n) {
  return n
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (e, t) =>
      t == 0 ? e.toLowerCase() : e.toUpperCase()
    )
    .replace(/\s+|_|-|\//g, "");
}
function D0(n) {
  return n == null;
}
function Ex(n) {
  return D0(n) === !1;
}
function Cx(n) {
  return n && typeof n.scope == "string";
}
function SL(n) {
  return n && N0(n.loader);
}
function vL(n) {
  return k0(n);
}
function xx(n) {
  return C0(n, { safe: !0 });
}
var Ua = new Ae("TRANSLOCO_CONFIG", { providedIn: "root", factory: () => Fa }),
  Fa = {
    defaultLang: "en",
    reRenderOnLangChange: !1,
    prodMode: !1,
    failedRetries: 2,
    fallbackLang: [],
    availableLangs: [],
    missingHandler: {
      logMissingKey: !0,
      useFallbackTranslation: !1,
      allowEmpty: !1,
    },
    flatten: { aot: !1 },
    interpolation: ["{{", "}}"],
    scopes: { keepCasing: !1 },
  };
function IL(n = {}) {
  return $(v(v({}, Fa), n), {
    missingHandler: v(v({}, Fa.missingHandler), n.missingHandler),
    flatten: v(v({}, Fa.flatten), n.flatten),
    scopes: v(v({}, Fa.scopes), n.scopes),
  });
}
var kx = new Ae("TRANSLOCO_TRANSPILER"),
  CL = (() => {
    class n {
      config = M(Ua, { optional: !0 }) ?? Fa;
      get interpolationMatcher() {
        return kL(this.config);
      }
      transpile({ value: t, params: r = {}, translation: i, key: s }) {
        if (Ma(t)) {
          let o,
            a = t;
          for (; (o = this.interpolationMatcher.exec(a)) !== null; ) {
            let [c, u] = o;
            a = a.replace(c, () => {
              let l = u.trim(),
                h = T0(r, l);
              return Ex(h)
                ? h
                : Ex(i[l])
                ? this.transpile({
                    params: r,
                    translation: i,
                    key: s,
                    value: i[l],
                  })
                : "";
            });
          }
          return a;
        } else
          r &&
            (N0(t)
              ? (t = this.handleObject({
                  value: t,
                  params: r,
                  translation: i,
                  key: s,
                }))
              : Array.isArray(t) &&
                (t = this.handleArray({
                  value: t,
                  params: r,
                  translation: i,
                  key: s,
                })));
        return t;
      }
      handleObject({ value: t, params: r = {}, translation: i, key: s }) {
        let o = t;
        return (
          Object.keys(r).forEach((a) => {
            let c = this.transpile({
              value: T0(o, a),
              params: T0(r, a),
              translation: i,
              key: s,
            });
            o = AL(o, a, c);
          }),
          o
        );
      }
      handleArray(i) {
        var s = i,
          { value: t } = s,
          r = ln(s, ["value"]);
        return t.map((o) => this.transpile(v({ value: o }, r)));
      }
      static ɵfac = function (r) {
        return new (r || n)();
      };
      static ɵprov = ae({ token: n, factory: n.ɵfac });
    }
    return n;
  })();
function kL(n) {
  let [e, t] = n.interpolation;
  return new RegExp(`${e}([^${e}${t}]*?)${t}`, "g");
}
var Tx = new Ae("TRANSLOCO_MISSING_HANDLER"),
  TL = (() => {
    class n {
      handle(t, r) {
        if (r.missingHandler.logMissingKey && !r.prodMode) {
          let i = `Missing translation for '${t}'`;
          console.warn(`%c ${i}`, "font-size: 12px; color: red");
        }
        return t;
      }
      static ɵfac = function (r) {
        return new (r || n)();
      };
      static ɵprov = ae({ token: n, factory: n.ɵfac });
    }
    return n;
  })(),
  Rx = new Ae("TRANSLOCO_INTERCEPTOR"),
  RL = (() => {
    class n {
      preSaveTranslation(t) {
        return t;
      }
      preSaveTranslationKey(t, r) {
        return r;
      }
      static ɵfac = function (r) {
        return new (r || n)();
      };
      static ɵprov = ae({ token: n, factory: n.ɵfac });
    }
    return n;
  })(),
  Bx = new Ae("TRANSLOCO_FALLBACK_STRATEGY"),
  BL = (() => {
    class n {
      userConfig;
      constructor(t) {
        this.userConfig = t;
      }
      getNextLangs() {
        let t = this.userConfig.fallbackLang;
        if (!t)
          throw new Error(
            "When using the default fallback, a fallback language must be provided in the config!"
          );
        return Array.isArray(t) ? t : [t];
      }
      static ɵfac = function (r) {
        return new (r || n)(le(Ua));
      };
      static ɵprov = ae({ token: n, factory: n.ɵfac });
    }
    return n;
  })();
function il(n) {
  if (!n) return "";
  let e = n.split("/");
  return e.pop(), e.join("/");
}
function ls(n) {
  return n ? n.split("/").pop() : "";
}
function _0(n, e, t = "|") {
  if (Ma(n)) {
    let r = n.split(t),
      i = r.pop();
    return i === e ? [!0, r.toString()] : [!1, i];
  }
  return [!1, ""];
}
function DL(n, e) {
  let [t] = _0(e, "static");
  return t ? !1 : !!n.config.reRenderOnLangChange;
}
function _L(n) {
  return n ? (e) => e : br(1);
}
function PL(n, e) {
  return Object.keys(n).reduce((t, r) => ((t[`${e}/${r}`] = n[r]), t), {});
}
function Dx(n, e) {
  return SL(n) ? PL(n.loader, e) : void 0;
}
function R0(n) {
  return { scope: il(n) || null, langName: ls(n) };
}
function _x(n) {
  let { path: e, inlineLoader: t, mainLoader: r, data: i } = n;
  if (t) {
    let s = t[e];
    if (xL(s) === !1)
      throw `You're using an inline loader but didn't provide a loader for ${e}`;
    return t[e]().then((o) => (o.default ? o.default : o));
  }
  return r.getTranslation(e, i);
}
function LL({
  mainLoader: n,
  path: e,
  data: t,
  fallbackPath: r,
  inlineLoader: i,
}) {
  return (r ? [e, r] : [e]).map((o) => {
    let a = _x({ path: o, mainLoader: n, inlineLoader: i, data: t });
    return Ke(a).pipe(xe((c) => ({ translation: c, lang: o })));
  });
}
var OL;
var NL = (() => {
    class n {
      loader;
      parser;
      missingHandler;
      interceptor;
      fallbackStrategy;
      langChanges$;
      translations = new Map();
      cache = new Map();
      firstFallbackLang;
      defaultLang = "";
      availableLangs = [];
      isResolvedMissingOnce = !1;
      lang;
      failedLangs = new Set();
      events = new rr();
      events$ = this.events.asObservable();
      config;
      constructor(t, r, i, s, o, a) {
        (this.loader = t),
          (this.parser = r),
          (this.missingHandler = i),
          (this.interceptor = s),
          (this.fallbackStrategy = a),
          this.loader || (this.loader = new B0(this.translations)),
          (OL = this),
          (this.config = JSON.parse(JSON.stringify(o))),
          this.setAvailableLangs(this.config.availableLangs || []),
          this.setFallbackLangForMissingTranslation(this.config),
          this.setDefaultLang(this.config.defaultLang),
          (this.lang = new hn(this.getDefaultLang())),
          (this.langChanges$ = this.lang.asObservable()),
          this.events$.pipe(ao()).subscribe((c) => {
            c.type === "translationLoadSuccess" &&
              c.wasFailure &&
              this.setActiveLang(c.payload.langName);
          });
      }
      getDefaultLang() {
        return this.defaultLang;
      }
      setDefaultLang(t) {
        this.defaultLang = t;
      }
      getActiveLang() {
        return this.lang.getValue();
      }
      setActiveLang(t) {
        return (
          this.parser.onLangChanged?.(t),
          this.lang.next(t),
          this.events.next({ type: "langChanged", payload: R0(t) }),
          this
        );
      }
      setAvailableLangs(t) {
        this.availableLangs = t;
      }
      getAvailableLangs() {
        return this.availableLangs;
      }
      load(t, r = {}) {
        let i = this.cache.get(t);
        if (i) return i;
        let s,
          o = this._isLangScoped(t),
          a;
        o && (a = il(t));
        let c = {
          path: t,
          mainLoader: this.loader,
          inlineLoader: r.inlineLoader,
          data: o ? { scope: a } : void 0,
        };
        if (this.useFallbackTranslation(t)) {
          let l = o ? `${a}/${this.firstFallbackLang}` : this.firstFallbackLang,
            h = LL($(v({}, c), { fallbackPath: l }));
          s = Yg(h);
        } else {
          let l = _x(c);
          s = Ke(l);
        }
        let u = s.pipe(
          YA(this.config.failedRetries),
          Oe((l) => {
            if (Array.isArray(l)) {
              l.forEach((h) => {
                this.handleSuccess(h.lang, h.translation),
                  h.lang !== t && this.cache.set(h.lang, oe({}));
              });
              return;
            }
            this.handleSuccess(t, l);
          }),
          _n(
            (l) => (
              this.config.prodMode ||
                console.error(`Error while trying to load "${t}"`, l),
              this.handleFailure(t, r)
            )
          ),
          fa(1)
        );
        return this.cache.set(t, u), u;
      }
      translate(t, r = {}, i = this.getActiveLang()) {
        if (!t) return t;
        let { scope: s, resolveLang: o } = this.resolveLangAndScope(i);
        if (Array.isArray(t))
          return t.map((u) => this.translate(s ? `${s}.${u}` : u, r, o));
        t = s ? `${s}.${t}` : t;
        let a = this.getTranslation(o),
          c = a[t];
        return c
          ? this.parser.transpile({
              value: c,
              params: r,
              translation: a,
              key: t,
            })
          : this._handleMissingKey(t, c, r);
      }
      selectTranslate(t, r, i, s = !1) {
        let o,
          a = (u, l) =>
            this.load(u, l).pipe(
              xe(() =>
                s ? this.translateObject(t, r, u) : this.translate(t, r, u)
              )
            );
        if (D0(i)) return this.langChanges$.pipe(ct((u) => a(u)));
        if (((i = Array.isArray(i) ? i[0] : i), Cx(i))) {
          let u = i;
          (i = u.scope), (o = Dx(u, u.scope));
        }
        if (((i = i), this.isLang(i) || this.isScopeWithLang(i))) return a(i);
        let c = i;
        return this.langChanges$.pipe(
          ct((u) => a(`${c}/${u}`, { inlineLoader: o }))
        );
      }
      isScopeWithLang(t) {
        return this.isLang(ls(t));
      }
      translateObject(t, r = {}, i = this.getActiveLang()) {
        if (Ma(t) || Array.isArray(t)) {
          let { resolveLang: o, scope: a } = this.resolveLangAndScope(i);
          if (Array.isArray(t))
            return t.map((l) =>
              this.translateObject(a ? `${a}.${l}` : l, r, o)
            );
          let c = this.getTranslation(o);
          t = a ? `${a}.${t}` : t;
          let u = vL(this.getObjectByKey(c, t));
          return EL(u)
            ? this.translate(t, r, i)
            : this.parser.transpile({
                value: u,
                params: r,
                translation: c,
                key: t,
              });
        }
        let s = [];
        for (let [o, a] of this.getEntries(t))
          s.push(this.translateObject(o, a, i));
        return s;
      }
      selectTranslateObject(t, r, i) {
        if (Ma(t) || Array.isArray(t)) return this.selectTranslate(t, r, i, !0);
        let [[s, o], ...a] = this.getEntries(t);
        return this.selectTranslateObject(s, o, i).pipe(
          xe((c) => {
            let u = [c];
            for (let [l, h] of a) u.push(this.translateObject(l, h, i));
            return u;
          })
        );
      }
      getTranslation(t) {
        if (t) {
          if (this.isLang(t)) return this.translations.get(t) || {};
          {
            let { scope: r, resolveLang: i } = this.resolveLangAndScope(t),
              s = this.translations.get(i) || {};
            return this.getObjectByKey(s, r);
          }
        }
        return this.translations;
      }
      selectTranslation(t) {
        let r = this.langChanges$;
        if (t) {
          let i = ls(t) !== t;
          this.isLang(t) || i
            ? (r = oe(t))
            : (r = this.langChanges$.pipe(xe((s) => `${t}/${s}`)));
        }
        return r.pipe(
          ct((i) => this.load(i).pipe(xe(() => this.getTranslation(i))))
        );
      }
      setTranslation(t, r = this.getActiveLang(), i = {}) {
        let o = v(v({}, { merge: !0, emitChange: !0 }), i),
          a = il(r),
          c = t;
        if (a) {
          let g = this.getMappedScope(a);
          c = xx({ [g]: t });
        }
        let u = a ? ls(r) : r,
          l = v(v({}, o.merge && this.getTranslation(u)), c),
          h = this.config.flatten.aot ? l : xx(l),
          f = this.interceptor.preSaveTranslation(h, u);
        this.translations.set(u, f),
          o.emitChange && this.setActiveLang(this.getActiveLang());
      }
      setTranslationKey(t, r, i = {}) {
        let s = i.lang || this.getActiveLang(),
          o = this.interceptor.preSaveTranslationKey(t, r, s),
          a = { [t]: o };
        this.setTranslation(a, s, $(v({}, i), { merge: !0 }));
      }
      setFallbackLangForMissingTranslation({ fallbackLang: t }) {
        let r = Array.isArray(t) ? t[0] : t;
        t && this.useFallbackTranslation(r) && (this.firstFallbackLang = r);
      }
      _handleMissingKey(t, r, i) {
        if (this.config.missingHandler.allowEmpty && r === "") return "";
        if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {
          this.isResolvedMissingOnce = !0;
          let s = this.translate(t, i, this.firstFallbackLang);
          return (this.isResolvedMissingOnce = !1), s;
        }
        return this.missingHandler.handle(t, this.getMissingHandlerData(), i);
      }
      _isLangScoped(t) {
        return this.getAvailableLangsIds().indexOf(t) === -1;
      }
      isLang(t) {
        return this.getAvailableLangsIds().indexOf(t) !== -1;
      }
      _loadDependencies(t, r) {
        let i = ls(t);
        return this._isLangScoped(t) && !this.isLoadedTranslation(i)
          ? dn([this.load(i), this.load(t, { inlineLoader: r })])
          : this.load(t, { inlineLoader: r });
      }
      _completeScopeWithLang(t) {
        return this._isLangScoped(t) && !this.isLang(ls(t))
          ? `${t}/${this.getActiveLang()}`
          : t;
      }
      _setScopeAlias(t, r) {
        this.config.scopeMapping || (this.config.scopeMapping = {}),
          (this.config.scopeMapping[t] = r);
      }
      ngOnDestroy() {
        this.cache.clear();
      }
      isLoadedTranslation(t) {
        return vx(this.getTranslation(t));
      }
      getAvailableLangsIds() {
        let t = this.getAvailableLangs()[0];
        return Ma(t)
          ? this.getAvailableLangs()
          : this.getAvailableLangs().map((r) => r.id);
      }
      getMissingHandlerData() {
        return $(v({}, this.config), {
          activeLang: this.getActiveLang(),
          availableLangs: this.availableLangs,
          defaultLang: this.defaultLang,
        });
      }
      useFallbackTranslation(t) {
        return (
          this.config.missingHandler.useFallbackTranslation &&
          t !== this.firstFallbackLang
        );
      }
      handleSuccess(t, r) {
        this.setTranslation(r, t, { emitChange: !1 }),
          this.events.next({
            wasFailure: !!this.failedLangs.size,
            type: "translationLoadSuccess",
            payload: R0(t),
          }),
          this.failedLangs.forEach((i) => this.cache.delete(i)),
          this.failedLangs.clear();
      }
      handleFailure(t, r) {
        D0(r.failedCounter) &&
          ((r.failedCounter = 0),
          r.fallbackLangs ||
            (r.fallbackLangs = this.fallbackStrategy.getNextLangs(t)));
        let i = t.split("/"),
          o = r.fallbackLangs[r.failedCounter];
        if ((this.failedLangs.add(t), this.cache.has(o)))
          return this.handleSuccess(o, this.getTranslation(o)), fn;
        let a = o === i[i.length - 1];
        if (!o || a) {
          let u = "Unable to load translation and all the fallback languages";
          throw (
            (i.length > 1 && (u += ", did you misspelled the scope name?"),
            new Error(u))
          );
        }
        let c = o;
        return (
          i.length > 1 && ((i[i.length - 1] = o), (c = i.join("/"))),
          r.failedCounter++,
          this.events.next({ type: "translationLoadFailure", payload: R0(t) }),
          this.load(c, r)
        );
      }
      getMappedScope(t) {
        let { scopeMapping: r = {}, scopes: i = { keepCasing: !1 } } =
          this.config;
        return r[t] || (i.keepCasing ? t : Ix(t));
      }
      resolveLangAndScope(t) {
        let r = t,
          i;
        if (this._isLangScoped(t)) {
          let s = ls(t),
            o = this.isLang(s);
          (r = o ? s : this.getActiveLang()),
            (i = this.getMappedScope(o ? il(t) : t));
        }
        return { scope: i, resolveLang: r };
      }
      getObjectByKey(t, r) {
        let i = {},
          s = `${r}.`;
        for (let o in t) o.startsWith(s) && (i[o.replace(s, "")] = t[o]);
        return i;
      }
      getEntries(t) {
        return t instanceof Map ? t.entries() : Object.entries(t);
      }
      static ɵfac = function (r) {
        return new (r || n)(le(Sx, 8), le(kx), le(Tx), le(Rx), le(Ua), le(Bx));
      };
      static ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
    }
    return n;
  })(),
  FL = (() => {
    class n {
      html;
      static ɵfac = function (r) {
        return new (r || n)();
      };
      static ɵcmp = da({
        type: n,
        selectors: [["ng-component"]],
        inputs: { html: "html" },
        standalone: !0,
        features: [ba],
        decls: 1,
        vars: 1,
        consts: [[1, "transloco-loader-template", 3, "innerHTML"]],
        template: function (r, i) {
          r & 1 && ya(0, "div", 0), r & 2 && vE("innerHTML", i.html, yE);
        },
        encapsulation: 2,
      });
    }
    return n;
  })(),
  P0 = class {
    view;
    vcr;
    constructor(e, t) {
      (this.view = e), (this.vcr = t);
    }
    attachView() {
      if (this.view instanceof ma) this.vcr.createEmbeddedView(this.view);
      else if (Ma(this.view)) {
        let e = this.vcr.createComponent(FL);
        (e.instance.html = this.view), e.hostView.detectChanges();
      } else this.vcr.createComponent(this.view);
    }
    detachView() {
      this.vcr.clear();
    }
  },
  ML = new Ae("TRANSLOCO_LANG"),
  UL = new Ae("TRANSLOCO_LOADING_TEMPLATE"),
  zL = new Ae("TRANSLOCO_SCOPE"),
  L0 = class {
    initialized = !1;
    resolve({ inline: e, provider: t, active: r }) {
      let i = r;
      if (this.initialized) return (i = r), i;
      if (t) {
        let [, s] = _0(t, "static");
        i = s;
      }
      if (e) {
        let [, s] = _0(e, "static");
        i = s;
      }
      return (this.initialized = !0), i;
    }
    resolveLangBasedOnScope(e) {
      return il(e) ? ls(e) : e;
    }
    resolveLangPath(e, t) {
      return t ? `${t}/${e}` : e;
    }
  },
  O0 = class {
    service;
    constructor(e) {
      this.service = e;
    }
    resolve(e) {
      let { inline: t, provider: r } = e;
      if (t) return t;
      if (r) {
        if (Cx(r)) {
          let {
            scope: i,
            alias: s = this.service.config.scopes.keepCasing ? i : Ix(i),
          } = r;
          return this.service._setScopeAlias(i, s), i;
        }
        return r;
      }
    }
  },
  xV = (() => {
    class n {
      destroyRef = M(gi);
      service = M(NL);
      tpl = M(ma, { optional: !0 });
      providerLang = M(ML, { optional: !0 });
      providerScope = M(zL, { optional: !0 });
      providedLoadingTpl = M(UL, { optional: !0 });
      cdr = M($r);
      host = M(mi);
      vcr = M(ns);
      renderer = M(yi);
      view;
      memo = new Map();
      key;
      params = {};
      inlineScope;
      inlineRead;
      prefix;
      inlineLang;
      inlineTpl;
      currentLang;
      loaderTplHandler;
      initialized = !1;
      path;
      langResolver = new L0();
      scopeResolver = new O0(this.service);
      strategy = this.tpl === null ? "attribute" : "structural";
      static ngTemplateContextGuard(t, r) {
        return !0;
      }
      ngOnInit() {
        let t = DL(this.service, this.providerLang || this.inlineLang);
        if (
          (this.service.langChanges$
            .pipe(
              ct((r) => {
                let i = this.langResolver.resolve({
                  inline: this.inlineLang,
                  provider: this.providerLang,
                  active: r,
                });
                return Array.isArray(this.providerScope)
                  ? Yg(this.providerScope.map((s) => this.resolveScope(i, s)))
                  : this.resolveScope(i, this.providerScope);
              }),
              _L(t),
              ao(this.destroyRef)
            )
            .subscribe(() => {
              (this.currentLang = this.langResolver.resolveLangBasedOnScope(
                this.path
              )),
                this.strategy === "attribute"
                  ? this.attributeStrategy()
                  : this.structuralStrategy(
                      this.currentLang,
                      this.prefix || this.inlineRead
                    ),
                this.cdr.markForCheck(),
                (this.initialized = !0);
            }),
          !this.initialized)
        ) {
          let r = this.resolveLoadingContent();
          r &&
            ((this.loaderTplHandler = new P0(r, this.vcr)),
            this.loaderTplHandler.attachView());
        }
      }
      ngOnChanges(t) {
        this.strategy === "attribute" &&
          Object.keys(t).some((i) => !t[i].firstChange) &&
          this.attributeStrategy();
      }
      attributeStrategy() {
        this.detachLoader(),
          this.renderer.setProperty(
            this.host.nativeElement,
            "innerText",
            this.service.translate(this.key, this.params, this.currentLang)
          );
      }
      structuralStrategy(t, r) {
        this.memo.clear();
        let i = this.getTranslateFn(t, r);
        this.view
          ? ((this.view.context.$implicit = i),
            (this.view.context.currentLang = this.currentLang))
          : (this.detachLoader(),
            (this.view = this.vcr.createEmbeddedView(this.tpl, {
              $implicit: i,
              currentLang: this.currentLang,
            })));
      }
      getTranslateFn(t, r) {
        return (i, s) => {
          let o = r ? `${r}.${i}` : i,
            a = s ? `${o}${JSON.stringify(s)}` : o;
          return (
            this.memo.has(a) ||
              this.memo.set(a, this.service.translate(o, s, t)),
            this.memo.get(a)
          );
        };
      }
      resolveLoadingContent() {
        return this.inlineTpl || this.providedLoadingTpl;
      }
      ngOnDestroy() {
        this.memo.clear();
      }
      detachLoader() {
        this.loaderTplHandler?.detachView();
      }
      resolveScope(t, r) {
        let i = this.scopeResolver.resolve({
          inline: this.inlineScope,
          provider: r,
        });
        this.path = this.langResolver.resolveLangPath(t, i);
        let s = Dx(r, i);
        return this.service._loadDependencies(this.path, s);
      }
      static ɵfac = function (r) {
        return new (r || n)();
      };
      static ɵdir = sr({
        type: n,
        selectors: [["", "transloco", ""]],
        inputs: {
          key: [0, "transloco", "key"],
          params: [0, "translocoParams", "params"],
          inlineScope: [0, "translocoScope", "inlineScope"],
          inlineRead: [0, "translocoRead", "inlineRead"],
          prefix: [0, "translocoPrefix", "prefix"],
          inlineLang: [0, "translocoLang", "inlineLang"],
          inlineTpl: [0, "translocoLoadingTpl", "inlineTpl"],
        },
        standalone: !0,
        features: [es],
      });
    }
    return n;
  })();
function SV(n) {
  let e = [HL(CL), $L(TL), GL(RL), VL(BL)];
  return n.config && e.push(jL(n.config)), n.loader && e.push(WL(n.loader)), e;
}
function jL(n) {
  return or([{ provide: Ua, useValue: IL(n) }]);
}
function WL(n) {
  return or([{ provide: Sx, useClass: n }]);
}
function HL(n) {
  return or([{ provide: kx, useClass: n, deps: [Ua] }]);
}
function VL(n) {
  return or([{ provide: Bx, useClass: n, deps: [Ua] }]);
}
function $L(n) {
  return or([{ provide: Tx, useClass: n }]);
}
function GL(n) {
  return or([{ provide: Rx, useClass: n }]);
}
var vV = new Ae("TRANSLOCO_TEST_LANGS - Available testing languages"),
  IV = new Ae("TRANSLOCO_TEST_OPTIONS - Testing options");
p();
p();
p();
var Px = "6.13.4";
p();
p();
p();
p();
p();
p();
p();
function KL(n, e, t) {
  let r = e.split("|").map((s) => s.trim());
  for (let s = 0; s < r.length; s++)
    switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof n === e) return;
    }
  let i = new Error(`invalid value for type ${e}`);
  throw (
    ((i.code = "INVALID_ARGUMENT"),
    (i.argument = `value.${t}`),
    (i.value = n),
    i)
  );
}
function It(n) {
  return d(this, null, function* () {
    let e = Object.keys(n);
    return (yield Promise.all(e.map((r) => Promise.resolve(n[r])))).reduce(
      (r, i, s) => ((r[e[s]] = i), r),
      {}
    );
  });
}
function ee(n, e, t) {
  for (let r in e) {
    let i = e[r],
      s = t ? t[r] : null;
    s && KL(i, s, r),
      Object.defineProperty(n, r, { enumerable: !0, value: i, writable: !1 });
  }
}
function za(n) {
  if (n == null) return "null";
  if (Array.isArray(n)) return "[ " + n.map(za).join(", ") + " ]";
  if (n instanceof Uint8Array) {
    let e = "0123456789abcdef",
      t = "0x";
    for (let r = 0; r < n.length; r++) (t += e[n[r] >> 4]), (t += e[n[r] & 15]);
    return t;
  }
  if (typeof n == "object" && typeof n.toJSON == "function")
    return za(n.toJSON());
  switch (typeof n) {
    case "boolean":
    case "symbol":
      return n.toString();
    case "bigint":
      return BigInt(n).toString();
    case "number":
      return n.toString();
    case "string":
      return JSON.stringify(n);
    case "object": {
      let e = Object.keys(n);
      return (
        e.sort(), "{ " + e.map((t) => `${za(t)}: ${za(n[t])}`).join(", ") + " }"
      );
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function ut(n, e) {
  return n && n.code === e;
}
function co(n) {
  return ut(n, "CALL_EXCEPTION");
}
function Ye(n, e, t) {
  let r = n;
  {
    let s = [];
    if (t) {
      if ("message" in t || "code" in t || "name" in t)
        throw new Error(`value will overwrite populated values: ${za(t)}`);
      for (let o in t) {
        if (o === "shortMessage") continue;
        let a = t[o];
        s.push(o + "=" + za(a));
      }
    }
    s.push(`code=${e}`),
      s.push(`version=${Px}`),
      s.length && (n += " (" + s.join(", ") + ")");
  }
  let i;
  switch (e) {
    case "INVALID_ARGUMENT":
      i = new TypeError(n);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      i = new RangeError(n);
      break;
    default:
      i = new Error(n);
  }
  return (
    ee(i, { code: e }),
    t && Object.assign(i, t),
    i.shortMessage == null && ee(i, { shortMessage: r }),
    i
  );
}
function R(n, e, t, r) {
  if (!n) throw Ye(e, t, r);
}
function x(n, e, t, r) {
  R(n, e, "INVALID_ARGUMENT", { argument: t, value: r });
}
function ja(n, e, t) {
  t == null && (t = ""),
    t && (t = ": " + t),
    R(n >= e, "missing arguemnt" + t, "MISSING_ARGUMENT", {
      count: n,
      expectedCount: e,
    }),
    R(n <= e, "too many arguments" + t, "UNEXPECTED_ARGUMENT", {
      count: n,
      expectedCount: e,
    });
}
var qL = ["NFD", "NFC", "NFKD", "NFKC"].reduce((n, e) => {
  try {
    if ("test".normalize(e) !== "test") throw new Error("bad");
    if (e === "NFD" && "\xE9".normalize("NFD") !== "e\u0301")
      throw new Error("broken");
    n.push(e);
  } catch {}
  return n;
}, []);
function xf(n) {
  R(
    qL.indexOf(n) >= 0,
    "platform missing String.prototype.normalize",
    "UNSUPPORTED_OPERATION",
    { operation: "String.prototype.normalize", info: { form: n } }
  );
}
function xr(n, e, t) {
  if ((t == null && (t = ""), n !== e)) {
    let r = t,
      i = "new";
    t && ((r += "."), (i += " " + t)),
      R(
        !1,
        `private constructor; use ${r}from* methods`,
        "UNSUPPORTED_OPERATION",
        { operation: i }
      );
  }
}
function Ox(n, e, t) {
  if (n instanceof Uint8Array) return t ? new Uint8Array(n) : n;
  if (typeof n == "string" && n.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    let r = new Uint8Array((n.length - 2) / 2),
      i = 2;
    for (let s = 0; s < r.length; s++)
      (r[s] = parseInt(n.substring(i, i + 2), 16)), (i += 2);
    return r;
  }
  x(!1, "invalid BytesLike value", e || "value", n);
}
function fe(n, e) {
  return Ox(n, e, !1);
}
function Ct(n, e) {
  return Ox(n, e, !0);
}
function De(n, e) {
  return !(
    typeof n != "string" ||
    !n.match(/^0x[0-9A-Fa-f]*$/) ||
    (typeof e == "number" && n.length !== 2 + 2 * e) ||
    (e === !0 && n.length % 2 !== 0)
  );
}
function hs(n) {
  return De(n, !0) || n instanceof Uint8Array;
}
var Lx = "0123456789abcdef";
function V(n) {
  let e = fe(n),
    t = "0x";
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    t += Lx[(i & 240) >> 4] + Lx[i & 15];
  }
  return t;
}
function Fe(n) {
  return "0x" + n.map((e) => V(e).substring(2)).join("");
}
function Sr(n) {
  return De(n, !0) ? (n.length - 2) / 2 : fe(n).length;
}
function at(n, e, t) {
  let r = fe(n);
  return (
    t != null &&
      t > r.length &&
      R(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: r,
        length: r.length,
        offset: t,
      }),
    V(r.slice(e ?? 0, t ?? r.length))
  );
}
function Nx(n, e, t) {
  let r = fe(n);
  R(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(r),
    length: e,
    offset: e + 1,
  });
  let i = new Uint8Array(e);
  return i.fill(0), t ? i.set(r, e - r.length) : i.set(r, 0), V(i);
}
function Ln(n, e) {
  return Nx(n, e, !0);
}
function Sf(n, e) {
  return Nx(n, e, !1);
}
p();
var vf = BigInt(0),
  vr = BigInt(1),
  Wa = 9007199254740991;
function fs(n, e) {
  let t = Va(n, "value"),
    r = BigInt(me(e, "width"));
  if (
    (R(t >> r === vf, "overflow", "NUMERIC_FAULT", {
      operation: "fromTwos",
      fault: "overflow",
      value: n,
    }),
    t >> (r - vr))
  ) {
    let i = (vr << r) - vr;
    return -((~t & i) + vr);
  }
  return t;
}
function Ha(n, e) {
  let t = Y(n, "value"),
    r = BigInt(me(e, "width")),
    i = vr << (r - vr);
  if (t < vf) {
    (t = -t),
      R(t <= i, "too low", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: n,
      });
    let s = (vr << r) - vr;
    return (~t & s) + vr;
  } else
    R(t < i, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: n,
    });
  return t;
}
function hr(n, e) {
  let t = Va(n, "value"),
    r = BigInt(me(e, "bits"));
  return t & ((vr << r) - vr);
}
function Y(n, e) {
  switch (typeof n) {
    case "bigint":
      return n;
    case "number":
      return (
        x(Number.isInteger(n), "underflow", e || "value", n),
        x(n >= -Wa && n <= Wa, "overflow", e || "value", n),
        BigInt(n)
      );
    case "string":
      try {
        if (n === "") throw new Error("empty string");
        return n[0] === "-" && n[1] !== "-"
          ? -BigInt(n.substring(1))
          : BigInt(n);
      } catch (t) {
        x(!1, `invalid BigNumberish string: ${t.message}`, e || "value", n);
      }
  }
  x(!1, "invalid BigNumberish value", e || "value", n);
}
function Va(n, e) {
  let t = Y(n, e);
  return (
    R(t >= vf, "unsigned value cannot be negative", "NUMERIC_FAULT", {
      fault: "overflow",
      operation: "getUint",
      value: n,
    }),
    t
  );
}
var Fx = "0123456789abcdef";
function Ci(n) {
  if (n instanceof Uint8Array) {
    let e = "0x0";
    for (let t of n) (e += Fx[t >> 4]), (e += Fx[t & 15]);
    return BigInt(e);
  }
  return Y(n);
}
function me(n, e) {
  switch (typeof n) {
    case "bigint":
      return x(n >= -Wa && n <= Wa, "overflow", e || "value", n), Number(n);
    case "number":
      return (
        x(Number.isInteger(n), "underflow", e || "value", n),
        x(n >= -Wa && n <= Wa, "overflow", e || "value", n),
        n
      );
    case "string":
      try {
        if (n === "") throw new Error("empty string");
        return me(BigInt(n), e);
      } catch (t) {
        x(!1, `invalid numeric string: ${t.message}`, e || "value", n);
      }
  }
  x(!1, "invalid numeric value", e || "value", n);
}
function If(n) {
  return me(Ci(n));
}
function vn(n, e) {
  let r = Va(n, "value").toString(16);
  if (e == null) r.length % 2 && (r = "0" + r);
  else {
    let i = me(e, "width");
    for (
      R(
        i * 2 >= r.length,
        `value exceeds width (${i} bytes)`,
        "NUMERIC_FAULT",
        { operation: "toBeHex", fault: "overflow", value: n }
      );
      r.length < i * 2;

    )
      r = "0" + r;
  }
  return "0x" + r;
}
function Rt(n) {
  let e = Va(n, "value");
  if (e === vf) return new Uint8Array([]);
  let t = e.toString(16);
  t.length % 2 && (t = "0" + t);
  let r = new Uint8Array(t.length / 2);
  for (let i = 0; i < r.length; i++) {
    let s = i * 2;
    r[i] = parseInt(t.substring(s, s + 2), 16);
  }
  return r;
}
function Ir(n) {
  let e = V(hs(n) ? n : Rt(n)).substring(2);
  for (; e.startsWith("0"); ) e = e.substring(1);
  return e === "" && (e = "0"), "0x" + e;
}
var Mx = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var KV = BigInt(0),
  Ux = BigInt(58);
function Cf(n) {
  let e = fe(n),
    t = Ci(e),
    r = "";
  for (; t; ) (r = Mx[Number(t % Ux)] + r), (t /= Ux);
  for (let i = 0; i < e.length && !e[i]; i++) r = Mx[0] + r;
  return r;
}
p();
function F0(n) {
  n = atob(n);
  let e = new Uint8Array(n.length);
  for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);
  return fe(e);
}
function M0(n) {
  let e = fe(n),
    t = "";
  for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
  return btoa(t);
}
p();
var ds = class {
  filter;
  emitter;
  #e;
  constructor(e, t, r) {
    (this.#e = t), ee(this, { emitter: e, filter: r });
  }
  removeListener() {
    return d(this, null, function* () {
      this.#e != null && (yield this.emitter.off(this.filter, this.#e));
    });
  }
};
p();
p();
function QL(n, e, t, r, i) {
  x(!1, `invalid codepoint at offset ${e}; ${n}`, "bytes", t);
}
function zx(n, e, t, r, i) {
  if (n === "BAD_PREFIX" || n === "UNEXPECTED_CONTINUE") {
    let s = 0;
    for (let o = e + 1; o < t.length && t[o] >> 6 === 2; o++) s++;
    return s;
  }
  return n === "OVERRUN" ? t.length - e - 1 : 0;
}
function JL(n, e, t, r, i) {
  return n === "OVERLONG"
    ? (x(
        typeof i == "number",
        "invalid bad code point for replacement",
        "badCodepoint",
        i
      ),
      r.push(i),
      0)
    : (r.push(65533), zx(n, e, t, r, i));
}
var U0 = Object.freeze({ error: QL, ignore: zx, replace: JL });
function YL(n, e) {
  e == null && (e = U0.error);
  let t = fe(n, "bytes"),
    r = [],
    i = 0;
  for (; i < t.length; ) {
    let s = t[i++];
    if (!(s >> 7)) {
      r.push(s);
      continue;
    }
    let o = null,
      a = null;
    if ((s & 224) === 192) (o = 1), (a = 127);
    else if ((s & 240) === 224) (o = 2), (a = 2047);
    else if ((s & 248) === 240) (o = 3), (a = 65535);
    else {
      (s & 192) === 128
        ? (i += e("UNEXPECTED_CONTINUE", i - 1, t, r))
        : (i += e("BAD_PREFIX", i - 1, t, r));
      continue;
    }
    if (i - 1 + o >= t.length) {
      i += e("OVERRUN", i - 1, t, r);
      continue;
    }
    let c = s & ((1 << (8 - o - 1)) - 1);
    for (let u = 0; u < o; u++) {
      let l = t[i];
      if ((l & 192) != 128) {
        (i += e("MISSING_CONTINUE", i, t, r)), (c = null);
        break;
      }
      (c = (c << 6) | (l & 63)), i++;
    }
    if (c !== null) {
      if (c > 1114111) {
        i += e("OUT_OF_RANGE", i - 1 - o, t, r, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        i += e("UTF16_SURROGATE", i - 1 - o, t, r, c);
        continue;
      }
      if (c <= a) {
        i += e("OVERLONG", i - 1 - o, t, r, c);
        continue;
      }
      r.push(c);
    }
  }
  return r;
}
function mn(n, e) {
  x(typeof n == "string", "invalid string value", "str", n),
    e != null && (xf(e), (n = n.normalize(e)));
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let i = n.charCodeAt(r);
    if (i < 128) t.push(i);
    else if (i < 2048) t.push((i >> 6) | 192), t.push((i & 63) | 128);
    else if ((i & 64512) == 55296) {
      r++;
      let s = n.charCodeAt(r);
      x(
        r < n.length && (s & 64512) === 56320,
        "invalid surrogate pair",
        "str",
        n
      );
      let o = 65536 + ((i & 1023) << 10) + (s & 1023);
      t.push((o >> 18) | 240),
        t.push(((o >> 12) & 63) | 128),
        t.push(((o >> 6) & 63) | 128),
        t.push((o & 63) | 128);
    } else
      t.push((i >> 12) | 224),
        t.push(((i >> 6) & 63) | 128),
        t.push((i & 63) | 128);
  }
  return new Uint8Array(t);
}
function ZL(n) {
  return n
    .map((e) =>
      e <= 65535
        ? String.fromCharCode(e)
        : ((e -= 65536),
          String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320))
    )
    .join("");
}
function ki(n, e) {
  return ZL(YL(n, e));
}
p();
function kf(n) {
  function e(t, r) {
    return d(this, null, function* () {
      R(
        r == null || !r.cancelled,
        "request cancelled before sending",
        "CANCELLED"
      );
      let i = t.url.split(":")[0].toLowerCase();
      R(
        i === "http" || i === "https",
        `unsupported protocol ${i}`,
        "UNSUPPORTED_OPERATION",
        { info: { protocol: i }, operation: "request" }
      ),
        R(
          i === "https" || !t.credentials || t.allowInsecureAuthentication,
          "insecure authorized connections unsupported",
          "UNSUPPORTED_OPERATION",
          { operation: "request" }
        );
      let s = null,
        o = new AbortController(),
        a = setTimeout(() => {
          (s = Ye("request timeout", "TIMEOUT")), o.abort();
        }, t.timeout);
      r &&
        r.addListener(() => {
          (s = Ye("request cancelled", "CANCELLED")), o.abort();
        });
      let c = {
          method: t.method,
          headers: new Headers(Array.from(t)),
          body: t.body || void 0,
          signal: o.signal,
        },
        u;
      try {
        u = yield fetch(t.url, c);
      } catch (g) {
        throw (clearTimeout(a), s || g);
      }
      clearTimeout(a);
      let l = {};
      u.headers.forEach((g, y) => {
        l[y.toLowerCase()] = g;
      });
      let h = yield u.arrayBuffer(),
        f = h == null ? null : new Uint8Array(h);
      return {
        statusCode: u.status,
        statusMessage: u.statusText,
        headers: l,
        body: f,
      };
    });
  }
  return e;
}
var c$ = kf({});
var XL = 12,
  eO = 250,
  jx = kf(),
  tO = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
  nO = new RegExp("^ipfs://(ipfs/)?(.*)$", "i"),
  z0 = !1;
function Hx(n, e) {
  return d(this, null, function* () {
    try {
      let t = n.match(tO);
      if (!t) throw new Error("invalid data");
      return new qr(
        200,
        "OK",
        { "content-type": t[1] || "text/plain" },
        t[2] ? F0(t[3]) : rO(t[3])
      );
    } catch {
      return new qr(
        599,
        "BAD REQUEST (invalid data: URI)",
        {},
        null,
        new Jn(n)
      );
    }
  });
}
function Vx(n) {
  function e(t, r) {
    return d(this, null, function* () {
      try {
        let i = t.match(nO);
        if (!i) throw new Error("invalid link");
        return new Jn(`${n}${i[2]}`);
      } catch {
        return new qr(
          599,
          "BAD REQUEST (invalid IPFS URI)",
          {},
          null,
          new Jn(t)
        );
      }
    });
  }
  return e;
}
var Tf = { data: Hx, ipfs: Vx("https://gateway.ipfs.io/ipfs/") },
  $x = new WeakMap(),
  sl = class {
    #e;
    #t;
    constructor(e) {
      (this.#e = []),
        (this.#t = !1),
        $x.set(e, () => {
          if (!this.#t) {
            this.#t = !0;
            for (let t of this.#e)
              setTimeout(() => {
                t();
              }, 0);
            this.#e = [];
          }
        });
    }
    addListener(e) {
      R(!this.#t, "singal already cancelled", "UNSUPPORTED_OPERATION", {
        operation: "fetchCancelSignal.addCancelListener",
      }),
        this.#e.push(e);
    }
    get cancelled() {
      return this.#t;
    }
    checkSignal() {
      R(!this.cancelled, "cancelled", "CANCELLED", {});
    }
  };
function Rf(n) {
  if (n == null) throw new Error("missing signal; should not happen");
  return n.checkSignal(), n;
}
var Jn = class n {
    #e;
    #t;
    #n;
    #r;
    #i;
    #o;
    #s;
    #a;
    #h;
    #u;
    #p;
    #g;
    #c;
    #l;
    #f;
    get url() {
      return this.#o;
    }
    set url(e) {
      this.#o = String(e);
    }
    get body() {
      return this.#s == null ? null : new Uint8Array(this.#s);
    }
    set body(e) {
      if (e == null) (this.#s = void 0), (this.#a = void 0);
      else if (typeof e == "string")
        (this.#s = mn(e)), (this.#a = "text/plain");
      else if (e instanceof Uint8Array)
        (this.#s = e), (this.#a = "application/octet-stream");
      else if (typeof e == "object")
        (this.#s = mn(JSON.stringify(e))), (this.#a = "application/json");
      else throw new Error("invalid body");
    }
    hasBody() {
      return this.#s != null;
    }
    get method() {
      return this.#r ? this.#r : this.hasBody() ? "POST" : "GET";
    }
    set method(e) {
      e == null && (e = ""), (this.#r = String(e).toUpperCase());
    }
    get headers() {
      let e = Object.assign({}, this.#n);
      return (
        this.#h && (e.authorization = `Basic ${M0(mn(this.#h))}`),
        this.allowGzip && (e["accept-encoding"] = "gzip"),
        e["content-type"] == null && this.#a && (e["content-type"] = this.#a),
        this.body && (e["content-length"] = String(this.body.length)),
        e
      );
    }
    getHeader(e) {
      return this.headers[e.toLowerCase()];
    }
    setHeader(e, t) {
      this.#n[String(e).toLowerCase()] = String(t);
    }
    clearHeaders() {
      this.#n = {};
    }
    [Symbol.iterator]() {
      let e = this.headers,
        t = Object.keys(e),
        r = 0;
      return {
        next: () => {
          if (r < t.length) {
            let i = t[r++];
            return { value: [i, e[i]], done: !1 };
          }
          return { value: void 0, done: !0 };
        },
      };
    }
    get credentials() {
      return this.#h || null;
    }
    setCredentials(e, t) {
      x(
        !e.match(/:/),
        "invalid basic authentication username",
        "username",
        "[REDACTED]"
      ),
        (this.#h = `${e}:${t}`);
    }
    get allowGzip() {
      return this.#t;
    }
    set allowGzip(e) {
      this.#t = !!e;
    }
    get allowInsecureAuthentication() {
      return !!this.#e;
    }
    set allowInsecureAuthentication(e) {
      this.#e = !!e;
    }
    get timeout() {
      return this.#i;
    }
    set timeout(e) {
      x(e >= 0, "timeout must be non-zero", "timeout", e), (this.#i = e);
    }
    get preflightFunc() {
      return this.#u || null;
    }
    set preflightFunc(e) {
      this.#u = e;
    }
    get processFunc() {
      return this.#p || null;
    }
    set processFunc(e) {
      this.#p = e;
    }
    get retryFunc() {
      return this.#g || null;
    }
    set retryFunc(e) {
      this.#g = e;
    }
    get getUrlFunc() {
      return this.#f || jx;
    }
    set getUrlFunc(e) {
      this.#f = e;
    }
    constructor(e) {
      (this.#o = String(e)),
        (this.#e = !1),
        (this.#t = !0),
        (this.#n = {}),
        (this.#r = ""),
        (this.#i = 3e5),
        (this.#l = { slotInterval: eO, maxAttempts: XL }),
        (this.#f = null);
    }
    toString() {
      return `<FetchRequest method=${JSON.stringify(
        this.method
      )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(
        this.headers
      )} body=${this.#s ? V(this.#s) : "null"}>`;
    }
    setThrottleParams(e) {
      e.slotInterval != null && (this.#l.slotInterval = e.slotInterval),
        e.maxAttempts != null && (this.#l.maxAttempts = e.maxAttempts);
    }
    #d(e, t, r, i, s) {
      return d(this, null, function* () {
        if (e >= this.#l.maxAttempts)
          return s.makeServerError("exceeded maximum retry limit");
        R(Wx() <= t, "timeout", "TIMEOUT", {
          operation: "request.send",
          reason: "timeout",
          request: i,
        }),
          r > 0 && (yield iO(r));
        let o = this.clone(),
          a = (o.url.split(":")[0] || "").toLowerCase();
        if (a in Tf) {
          let l = yield Tf[a](o.url, Rf(i.#c));
          if (l instanceof qr) {
            let h = l;
            if (this.processFunc) {
              Rf(i.#c);
              try {
                h = yield this.processFunc(o, h);
              } catch (f) {
                (f.throttle == null || typeof f.stall != "number") &&
                  h
                    .makeServerError("error in post-processing function", f)
                    .assertOk();
              }
            }
            return h;
          }
          o = l;
        }
        this.preflightFunc && (o = yield this.preflightFunc(o));
        let c = yield this.getUrlFunc(o, Rf(i.#c)),
          u = new qr(c.statusCode, c.statusMessage, c.headers, c.body, i);
        if (u.statusCode === 301 || u.statusCode === 302) {
          try {
            let l = u.headers.location || "";
            return o.redirect(l).#d(e + 1, t, 0, i, u);
          } catch {}
          return u;
        } else if (
          u.statusCode === 429 &&
          (this.retryFunc == null || (yield this.retryFunc(o, u, e)))
        ) {
          let l = u.headers["retry-after"],
            h =
              this.#l.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
          return (
            typeof l == "string" &&
              l.match(/^[1-9][0-9]*$/) &&
              (h = parseInt(l)),
            o.clone().#d(e + 1, t, h, i, u)
          );
        }
        if (this.processFunc) {
          Rf(i.#c);
          try {
            u = yield this.processFunc(o, u);
          } catch (l) {
            (l.throttle == null || typeof l.stall != "number") &&
              u
                .makeServerError("error in post-processing function", l)
                .assertOk();
            let h =
              this.#l.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
            return (
              l.stall >= 0 && (h = l.stall), o.clone().#d(e + 1, t, h, i, u)
            );
          }
        }
        return u;
      });
    }
    send() {
      return (
        R(this.#c == null, "request already sent", "UNSUPPORTED_OPERATION", {
          operation: "fetchRequest.send",
        }),
        (this.#c = new sl(this)),
        this.#d(0, Wx() + this.timeout, 0, this, new qr(0, "", {}, null, this))
      );
    }
    cancel() {
      R(this.#c != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
        operation: "fetchRequest.cancel",
      });
      let e = $x.get(this);
      if (!e) throw new Error("missing signal; should not happen");
      e();
    }
    redirect(e) {
      let t = this.url.split(":")[0].toLowerCase(),
        r = e.split(":")[0].toLowerCase();
      R(
        this.method === "GET" &&
          (t !== "https" || r !== "http") &&
          e.match(/^https?:/),
        "unsupported redirect",
        "UNSUPPORTED_OPERATION",
        {
          operation: `redirect(${this.method} ${JSON.stringify(
            this.url
          )} => ${JSON.stringify(e)})`,
        }
      );
      let i = new n(e);
      return (
        (i.method = "GET"),
        (i.allowGzip = this.allowGzip),
        (i.timeout = this.timeout),
        (i.#n = Object.assign({}, this.#n)),
        this.#s && (i.#s = new Uint8Array(this.#s)),
        (i.#a = this.#a),
        i
      );
    }
    clone() {
      let e = new n(this.url);
      return (
        (e.#r = this.#r),
        this.#s && (e.#s = this.#s),
        (e.#a = this.#a),
        (e.#n = Object.assign({}, this.#n)),
        (e.#h = this.#h),
        this.allowGzip && (e.allowGzip = !0),
        (e.timeout = this.timeout),
        this.allowInsecureAuthentication &&
          (e.allowInsecureAuthentication = !0),
        (e.#u = this.#u),
        (e.#p = this.#p),
        (e.#g = this.#g),
        (e.#l = Object.assign({}, this.#l)),
        (e.#f = this.#f),
        e
      );
    }
    static lockConfig() {
      z0 = !0;
    }
    static getGateway(e) {
      return Tf[e.toLowerCase()] || null;
    }
    static registerGateway(e, t) {
      if (((e = e.toLowerCase()), e === "http" || e === "https"))
        throw new Error(`cannot intercept ${e}; use registerGetUrl`);
      if (z0) throw new Error("gateways locked");
      Tf[e] = t;
    }
    static registerGetUrl(e) {
      if (z0) throw new Error("gateways locked");
      jx = e;
    }
    static createGetUrlFunc(e) {
      return kf(e);
    }
    static createDataGateway() {
      return Hx;
    }
    static createIpfsGatewayFunc(e) {
      return Vx(e);
    }
  },
  qr = class n {
    #e;
    #t;
    #n;
    #r;
    #i;
    #o;
    toString() {
      return `<FetchResponse status=${this.statusCode} body=${
        this.#r ? V(this.#r) : "null"
      }>`;
    }
    get statusCode() {
      return this.#e;
    }
    get statusMessage() {
      return this.#t;
    }
    get headers() {
      return Object.assign({}, this.#n);
    }
    get body() {
      return this.#r == null ? null : new Uint8Array(this.#r);
    }
    get bodyText() {
      try {
        return this.#r == null ? "" : ki(this.#r);
      } catch {
        R(
          !1,
          "response body is not valid UTF-8 data",
          "UNSUPPORTED_OPERATION",
          { operation: "bodyText", info: { response: this } }
        );
      }
    }
    get bodyJson() {
      try {
        return JSON.parse(this.bodyText);
      } catch {
        R(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
          operation: "bodyJson",
          info: { response: this },
        });
      }
    }
    [Symbol.iterator]() {
      let e = this.headers,
        t = Object.keys(e),
        r = 0;
      return {
        next: () => {
          if (r < t.length) {
            let i = t[r++];
            return { value: [i, e[i]], done: !1 };
          }
          return { value: void 0, done: !0 };
        },
      };
    }
    constructor(e, t, r, i, s) {
      (this.#e = e),
        (this.#t = t),
        (this.#n = Object.keys(r).reduce(
          (o, a) => ((o[a.toLowerCase()] = String(r[a])), o),
          {}
        )),
        (this.#r = i == null ? null : new Uint8Array(i)),
        (this.#i = s || null),
        (this.#o = { message: "" });
    }
    makeServerError(e, t) {
      let r;
      e
        ? (r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})`)
        : ((e = `${this.statusCode} ${this.statusMessage}`),
          (r = `CLIENT ESCALATED SERVER ERROR (${e})`));
      let i = new n(599, r, this.headers, this.body, this.#i || void 0);
      return (i.#o = { message: e, error: t }), i;
    }
    throwThrottleError(e, t) {
      t == null
        ? (t = -1)
        : x(Number.isInteger(t) && t >= 0, "invalid stall timeout", "stall", t);
      let r = new Error(e || "throttling requests");
      throw (ee(r, { stall: t, throttle: !0 }), r);
    }
    getHeader(e) {
      return this.headers[e.toLowerCase()];
    }
    hasBody() {
      return this.#r != null;
    }
    get request() {
      return this.#i;
    }
    ok() {
      return (
        this.#o.message === "" &&
        this.statusCode >= 200 &&
        this.statusCode < 300
      );
    }
    assertOk() {
      if (this.ok()) return;
      let { message: e, error: t } = this.#o;
      e === "" &&
        (e = `server response ${this.statusCode} ${this.statusMessage}`);
      let r = null;
      this.request && (r = this.request.url);
      let i = null;
      try {
        this.#r && (i = ki(this.#r));
      } catch {}
      R(!1, e, "SERVER_ERROR", {
        request: this.request || "unknown request",
        response: this,
        error: t,
        info: {
          requestUrl: r,
          responseBody: i,
          responseStatus: `${this.statusCode} ${this.statusMessage}`,
        },
      });
    }
  };
function Wx() {
  return new Date().getTime();
}
function rO(n) {
  return mn(
    n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) =>
      String.fromCharCode(parseInt(t, 16))
    )
  );
}
function iO(n) {
  return new Promise((e) => setTimeout(e, n));
}
p();
var sO = BigInt(-1),
  Cr = BigInt(0),
  Ga = BigInt(1),
  oO = BigInt(5),
  $a = {},
  Ka = "0000";
for (; Ka.length < 80; ) Ka += Ka;
function uo(n) {
  let e = Ka;
  for (; e.length < n; ) e += e;
  return BigInt("1" + e.substring(0, n));
}
function ol(n, e, t) {
  let r = BigInt(e.width);
  if (e.signed) {
    let i = Ga << (r - Ga);
    R(t == null || (n >= -i && n < i), "overflow", "NUMERIC_FAULT", {
      operation: t,
      fault: "overflow",
      value: n,
    }),
      n > Cr ? (n = fs(hr(n, r), r)) : (n = -fs(hr(-n, r), r));
  } else {
    let i = Ga << r;
    R(t == null || (n >= 0 && n < i), "overflow", "NUMERIC_FAULT", {
      operation: t,
      fault: "overflow",
      value: n,
    }),
      (n = ((n % i) + i) % i & (i - Ga));
  }
  return n;
}
function j0(n) {
  typeof n == "number" && (n = `fixed128x${n}`);
  let e = !0,
    t = 128,
    r = 18;
  if (typeof n == "string") {
    if (n !== "fixed")
      if (n === "ufixed") e = !1;
      else {
        let s = n.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        x(s, "invalid fixed format", "format", n),
          (e = s[1] !== "u"),
          (t = parseInt(s[2])),
          (r = parseInt(s[3]));
      }
  } else if (n) {
    let s = n,
      o = (a, c, u) =>
        s[a] == null
          ? u
          : (x(
              typeof s[a] === c,
              "invalid fixed format (" + a + " not " + c + ")",
              "format." + a,
              s[a]
            ),
            s[a]);
    (e = o("signed", "boolean", e)),
      (t = o("width", "number", t)),
      (r = o("decimals", "number", r));
  }
  x(
    t % 8 === 0,
    "invalid FixedNumber width (not byte aligned)",
    "format.width",
    t
  ),
    x(
      r <= 80,
      "invalid FixedNumber decimals (too large)",
      "format.decimals",
      r
    );
  let i = (e ? "" : "u") + "fixed" + String(t) + "x" + String(r);
  return { signed: e, width: t, decimals: r, name: i };
}
function aO(n, e) {
  let t = "";
  n < Cr && ((t = "-"), (n *= sO));
  let r = n.toString();
  if (e === 0) return t + r;
  for (; r.length <= e; ) r = Ka + r;
  let i = r.length - e;
  for (
    r = r.substring(0, i) + "." + r.substring(i);
    r[0] === "0" && r[1] !== ".";

  )
    r = r.substring(1);
  for (; r[r.length - 1] === "0" && r[r.length - 2] !== "."; )
    r = r.substring(0, r.length - 1);
  return t + r;
}
var qa = class n {
  format;
  #e;
  #t;
  #n;
  _value;
  constructor(e, t, r) {
    xr(e, $a, "FixedNumber"), (this.#t = t), (this.#e = r);
    let i = aO(t, r.decimals);
    ee(this, { format: r.name, _value: i }), (this.#n = uo(r.decimals));
  }
  get signed() {
    return this.#e.signed;
  }
  get width() {
    return this.#e.width;
  }
  get decimals() {
    return this.#e.decimals;
  }
  get value() {
    return this.#t;
  }
  #r(e) {
    x(
      this.format === e.format,
      "incompatible format; use fixedNumber.toFormat",
      "other",
      e
    );
  }
  #i(e, t) {
    return (e = ol(e, this.#e, t)), new n($a, e, this.#e);
  }
  #o(e, t) {
    return this.#r(e), this.#i(this.#t + e.#t, t);
  }
  addUnsafe(e) {
    return this.#o(e);
  }
  add(e) {
    return this.#o(e, "add");
  }
  #s(e, t) {
    return this.#r(e), this.#i(this.#t - e.#t, t);
  }
  subUnsafe(e) {
    return this.#s(e);
  }
  sub(e) {
    return this.#s(e, "sub");
  }
  #a(e, t) {
    return this.#r(e), this.#i((this.#t * e.#t) / this.#n, t);
  }
  mulUnsafe(e) {
    return this.#a(e);
  }
  mul(e) {
    return this.#a(e, "mul");
  }
  mulSignal(e) {
    this.#r(e);
    let t = this.#t * e.#t;
    return (
      R(
        t % this.#n === Cr,
        "precision lost during signalling mul",
        "NUMERIC_FAULT",
        { operation: "mulSignal", fault: "underflow", value: this }
      ),
      this.#i(t / this.#n, "mulSignal")
    );
  }
  #h(e, t) {
    return (
      R(e.#t !== Cr, "division by zero", "NUMERIC_FAULT", {
        operation: "div",
        fault: "divide-by-zero",
        value: this,
      }),
      this.#r(e),
      this.#i((this.#t * this.#n) / e.#t, t)
    );
  }
  divUnsafe(e) {
    return this.#h(e);
  }
  div(e) {
    return this.#h(e, "div");
  }
  divSignal(e) {
    R(e.#t !== Cr, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this,
    }),
      this.#r(e);
    let t = this.#t * this.#n;
    return (
      R(
        t % e.#t === Cr,
        "precision lost during signalling div",
        "NUMERIC_FAULT",
        { operation: "divSignal", fault: "underflow", value: this }
      ),
      this.#i(t / e.#t, "divSignal")
    );
  }
  cmp(e) {
    let t = this.value,
      r = e.value,
      i = this.decimals - e.decimals;
    return (
      i > 0 ? (r *= uo(i)) : i < 0 && (t *= uo(-i)), t < r ? -1 : t > r ? 1 : 0
    );
  }
  eq(e) {
    return this.cmp(e) === 0;
  }
  lt(e) {
    return this.cmp(e) < 0;
  }
  lte(e) {
    return this.cmp(e) <= 0;
  }
  gt(e) {
    return this.cmp(e) > 0;
  }
  gte(e) {
    return this.cmp(e) >= 0;
  }
  floor() {
    let e = this.#t;
    return (
      this.#t < Cr && (e -= this.#n - Ga),
      (e = (this.#t / this.#n) * this.#n),
      this.#i(e, "floor")
    );
  }
  ceiling() {
    let e = this.#t;
    return (
      this.#t > Cr && (e += this.#n - Ga),
      (e = (this.#t / this.#n) * this.#n),
      this.#i(e, "ceiling")
    );
  }
  round(e) {
    if ((e == null && (e = 0), e >= this.decimals)) return this;
    let t = this.decimals - e,
      r = oO * uo(t - 1),
      i = this.value + r,
      s = uo(t);
    return (i = (i / s) * s), ol(i, this.#e, "round"), new n($a, i, this.#e);
  }
  isZero() {
    return this.#t === Cr;
  }
  isNegative() {
    return this.#t < Cr;
  }
  toString() {
    return this._value;
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return n.fromString(this.toString(), e);
  }
  static fromValue(e, t, r) {
    let i = t == null ? 0 : me(t),
      s = j0(r),
      o = Y(e, "value"),
      a = i - s.decimals;
    if (a > 0) {
      let c = uo(a);
      R(o % c === Cr, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: e,
      }),
        (o /= c);
    } else a < 0 && (o *= uo(-a));
    return ol(o, s, "fromValue"), new n($a, o, s);
  }
  static fromString(e, t) {
    let r = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    x(
      r && r[2].length + r[3].length > 0,
      "invalid FixedNumber string value",
      "value",
      e
    );
    let i = j0(t),
      s = r[2] || "0",
      o = r[3] || "";
    for (; o.length < i.decimals; ) o += Ka;
    R(
      o.substring(i.decimals).match(/^0*$/),
      "too many decimals for format",
      "NUMERIC_FAULT",
      { operation: "fromString", fault: "underflow", value: e }
    ),
      (o = o.substring(0, i.decimals));
    let a = BigInt(r[1] + s + o);
    return ol(a, i, "fromString"), new n($a, a, i);
  }
  static fromBytes(e, t) {
    let r = Ci(fe(e, "value")),
      i = j0(t);
    return (
      i.signed && (r = fs(r, i.width)), ol(r, i, "fromBytes"), new n($a, r, i)
    );
  }
};
p();
function cO(n) {
  let e = n.toString(16);
  for (; e.length < 2; ) e = "0" + e;
  return "0x" + e;
}
function Gx(n, e, t) {
  let r = 0;
  for (let i = 0; i < t; i++) r = r * 256 + n[e + i];
  return r;
}
function Kx(n, e, t, r) {
  let i = [];
  for (; t < e + 1 + r; ) {
    let s = qx(n, t);
    i.push(s.result),
      (t += s.consumed),
      R(t <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
        buffer: n,
        length: r,
        offset: e,
      });
  }
  return { consumed: 1 + r, result: i };
}
function qx(n, e) {
  R(n.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: n,
    length: 0,
    offset: 1,
  });
  let t = (r) => {
    R(r <= n.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: n,
      length: n.length,
      offset: r,
    });
  };
  if (n[e] >= 248) {
    let r = n[e] - 247;
    t(e + 1 + r);
    let i = Gx(n, e + 1, r);
    return t(e + 1 + r + i), Kx(n, e, e + 1 + r, r + i);
  } else if (n[e] >= 192) {
    let r = n[e] - 192;
    return t(e + 1 + r), Kx(n, e, e + 1, r);
  } else if (n[e] >= 184) {
    let r = n[e] - 183;
    t(e + 1 + r);
    let i = Gx(n, e + 1, r);
    t(e + 1 + r + i);
    let s = V(n.slice(e + 1 + r, e + 1 + r + i));
    return { consumed: 1 + r + i, result: s };
  } else if (n[e] >= 128) {
    let r = n[e] - 128;
    t(e + 1 + r);
    let i = V(n.slice(e + 1, e + 1 + r));
    return { consumed: 1 + r, result: i };
  }
  return { consumed: 1, result: cO(n[e]) };
}
function lo(n) {
  let e = fe(n, "data"),
    t = qx(e, 0);
  return (
    x(t.consumed === e.length, "unexpected junk after rlp payload", "data", n),
    t.result
  );
}
p();
function Qx(n) {
  let e = [];
  for (; n; ) e.unshift(n & 255), (n >>= 8);
  return e;
}
function Yx(n) {
  if (Array.isArray(n)) {
    let r = [];
    if (
      (n.forEach(function (s) {
        r = r.concat(Yx(s));
      }),
      r.length <= 55)
    )
      return r.unshift(192 + r.length), r;
    let i = Qx(r.length);
    return i.unshift(247 + i.length), i.concat(r);
  }
  let e = Array.prototype.slice.call(fe(n, "object"));
  if (e.length === 1 && e[0] <= 127) return e;
  if (e.length <= 55) return e.unshift(128 + e.length), e;
  let t = Qx(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
var Jx = "0123456789abcdef";
function kr(n) {
  let e = "0x";
  for (let t of Yx(n)) (e += Jx[t >> 4]), (e += Jx[t & 15]);
  return e;
}
p();
var Zx = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
function W0(n, e) {
  let t = 18;
  if (typeof e == "string") {
    let r = Zx.indexOf(e);
    x(r >= 0, "invalid unit", "unit", e), (t = 3 * r);
  } else e != null && (t = me(e, "unit"));
  return qa.fromValue(n, t, { decimals: t, width: 512 }).toString();
}
function H0(n, e) {
  x(typeof n == "string", "value must be a string", "value", n);
  let t = 18;
  if (typeof e == "string") {
    let r = Zx.indexOf(e);
    x(r >= 0, "invalid unit", "unit", e), (t = 3 * r);
  } else e != null && (t = me(e, "unit"));
  return qa.fromString(n, { decimals: t, width: 512 }).value;
}
function Xx(n) {
  return W0(n, 18);
}
function eS(n) {
  return H0(n, 18);
}
p();
var rn = 32,
  V0 = new Uint8Array(rn),
  fO = ["then"],
  Bf = {},
  rS = new WeakMap();
function ho(n) {
  return rS.get(n);
}
function tS(n, e) {
  rS.set(n, e);
}
function al(n, e) {
  let t = new Error(
    `deferred error during ABI decoding triggered accessing ${n}`
  );
  throw ((t.error = e), t);
}
function $0(n, e, t) {
  return n.indexOf(null) >= 0
    ? e.map((r, i) => (r instanceof Ti ? $0(ho(r), r, t) : r))
    : n.reduce((r, i, s) => {
        let o = e.getValue(i);
        return (
          i in r || (t && o instanceof Ti && (o = $0(ho(o), o, t)), (r[i] = o)),
          r
        );
      }, {});
}
var Ti = class n extends Array {
  #e;
  constructor(...e) {
    let t = e[0],
      r = e[1],
      i = (e[2] || []).slice(),
      s = !0;
    t !== Bf && ((r = e), (i = []), (s = !1)),
      super(r.length),
      r.forEach((c, u) => {
        this[u] = c;
      });
    let o = i.reduce(
      (c, u) => (typeof u == "string" && c.set(u, (c.get(u) || 0) + 1), c),
      new Map()
    );
    if (
      (tS(
        this,
        Object.freeze(
          r.map((c, u) => {
            let l = i[u];
            return l != null && o.get(l) === 1 ? l : null;
          })
        )
      ),
      (this.#e = []),
      this.#e == null && this.#e,
      !s)
    )
      return;
    Object.freeze(this);
    let a = new Proxy(this, {
      get: (c, u, l) => {
        if (typeof u == "string") {
          if (u.match(/^[0-9]+$/)) {
            let f = me(u, "%index");
            if (f < 0 || f >= this.length)
              throw new RangeError("out of result range");
            let g = c[f];
            return g instanceof Error && al(`index ${f}`, g), g;
          }
          if (fO.indexOf(u) >= 0) return Reflect.get(c, u, l);
          let h = c[u];
          if (h instanceof Function)
            return function (...f) {
              return h.apply(this === l ? c : this, f);
            };
          if (!(u in c)) return c.getValue.apply(this === l ? c : this, [u]);
        }
        return Reflect.get(c, u, l);
      },
    });
    return tS(a, ho(this)), a;
  }
  toArray(e) {
    let t = [];
    return (
      this.forEach((r, i) => {
        r instanceof Error && al(`index ${i}`, r),
          e && r instanceof n && (r = r.toArray(e)),
          t.push(r);
      }),
      t
    );
  }
  toObject(e) {
    let t = ho(this);
    return t.reduce(
      (r, i, s) => (
        R(i != null, `value at index ${s} unnamed`, "UNSUPPORTED_OPERATION", {
          operation: "toObject()",
        }),
        $0(t, this, e)
      ),
      {}
    );
  }
  slice(e, t) {
    e == null && (e = 0),
      e < 0 && ((e += this.length), e < 0 && (e = 0)),
      t == null && (t = this.length),
      t < 0 && ((t += this.length), t < 0 && (t = 0)),
      t > this.length && (t = this.length);
    let r = ho(this),
      i = [],
      s = [];
    for (let o = e; o < t; o++) i.push(this[o]), s.push(r[o]);
    return new n(Bf, i, s);
  }
  filter(e, t) {
    let r = ho(this),
      i = [],
      s = [];
    for (let o = 0; o < this.length; o++) {
      let a = this[o];
      a instanceof Error && al(`index ${o}`, a),
        e.call(t, a, o, this) && (i.push(a), s.push(r[o]));
    }
    return new n(Bf, i, s);
  }
  map(e, t) {
    let r = [];
    for (let i = 0; i < this.length; i++) {
      let s = this[i];
      s instanceof Error && al(`index ${i}`, s), r.push(e.call(t, s, i, this));
    }
    return r;
  }
  getValue(e) {
    let t = ho(this).indexOf(e);
    if (t === -1) return;
    let r = this[t];
    return (
      r instanceof Error && al(`property ${JSON.stringify(e)}`, r.error), r
    );
  }
  static fromItems(e, t) {
    return new n(Bf, e, t);
  }
};
function nS(n) {
  let e = Rt(n);
  return (
    R(e.length <= rn, "value out-of-bounds", "BUFFER_OVERRUN", {
      buffer: e,
      length: rn,
      offset: e.length,
    }),
    e.length !== rn && (e = Ct(Fe([V0.slice(e.length % rn), e]))),
    e
  );
}
var _t = class {
    name;
    type;
    localName;
    dynamic;
    constructor(e, t, r, i) {
      ee(
        this,
        { name: e, type: t, localName: r, dynamic: i },
        {
          name: "string",
          type: "string",
          localName: "string",
          dynamic: "boolean",
        }
      );
    }
    _throwError(e, t) {
      x(!1, e, this.localName, t);
    }
  },
  fo = class {
    #e;
    #t;
    constructor() {
      (this.#e = []), (this.#t = 0);
    }
    get data() {
      return Fe(this.#e);
    }
    get length() {
      return this.#t;
    }
    #n(e) {
      return this.#e.push(e), (this.#t += e.length), e.length;
    }
    appendWriter(e) {
      return this.#n(Ct(e.data));
    }
    writeBytes(e) {
      let t = Ct(e),
        r = t.length % rn;
      return r && (t = Ct(Fe([t, V0.slice(r)]))), this.#n(t);
    }
    writeValue(e) {
      return this.#n(nS(e));
    }
    writeUpdatableValue() {
      let e = this.#e.length;
      return (
        this.#e.push(V0),
        (this.#t += rn),
        (t) => {
          this.#e[e] = nS(t);
        }
      );
    }
  },
  Df = class n {
    allowLoose;
    #e;
    #t;
    #n;
    #r;
    #i;
    constructor(e, t, r) {
      ee(this, { allowLoose: !!t }),
        (this.#e = Ct(e)),
        (this.#n = 0),
        (this.#r = null),
        (this.#i = r ?? 1024),
        (this.#t = 0);
    }
    get data() {
      return V(this.#e);
    }
    get dataLength() {
      return this.#e.length;
    }
    get consumed() {
      return this.#t;
    }
    get bytes() {
      return new Uint8Array(this.#e);
    }
    #o(e) {
      if (this.#r) return this.#r.#o(e);
      (this.#n += e),
        R(
          this.#i < 1 || this.#n <= this.#i * this.dataLength,
          `compressed ABI data exceeds inflation ratio of ${
            this.#i
          } ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`,
          "BUFFER_OVERRUN",
          {
            buffer: Ct(this.#e),
            offset: this.#t,
            length: e,
            info: { bytesRead: this.#n, dataLength: this.dataLength },
          }
        );
    }
    #s(e, t, r) {
      let i = Math.ceil(t / rn) * rn;
      return (
        this.#t + i > this.#e.length &&
          (this.allowLoose && r && this.#t + t <= this.#e.length
            ? (i = t)
            : R(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                buffer: Ct(this.#e),
                length: this.#e.length,
                offset: this.#t + i,
              })),
        this.#e.slice(this.#t, this.#t + i)
      );
    }
    subReader(e) {
      let t = new n(this.#e.slice(this.#t + e), this.allowLoose, this.#i);
      return (t.#r = this), t;
    }
    readBytes(e, t) {
      let r = this.#s(0, e, !!t);
      return this.#o(e), (this.#t += r.length), r.slice(0, e);
    }
    readValue() {
      return Ci(this.readBytes(rn));
    }
    readIndex() {
      return If(this.readBytes(rn));
    }
  };
p();
p();
p();
p();
p();
p();
var [dO, pO] = Ie.split(
    [
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817",
    ].map((n) => BigInt(n))
  ),
  ps = new Uint32Array(80),
  gs = new Uint32Array(80),
  G0 = class extends UE {
    constructor() {
      super(128, 64, 16, !1),
        (this.Ah = 1779033703),
        (this.Al = -205731576),
        (this.Bh = -1150833019),
        (this.Bl = -2067093701),
        (this.Ch = 1013904242),
        (this.Cl = -23791573),
        (this.Dh = -1521486534),
        (this.Dl = 1595750129),
        (this.Eh = 1359893119),
        (this.El = -1377402159),
        (this.Fh = -1694144372),
        (this.Fl = 725511199),
        (this.Gh = 528734635),
        (this.Gl = -79577749),
        (this.Hh = 1541459225),
        (this.Hl = 327033209);
    }
    get() {
      let {
        Ah: e,
        Al: t,
        Bh: r,
        Bl: i,
        Ch: s,
        Cl: o,
        Dh: a,
        Dl: c,
        Eh: u,
        El: l,
        Fh: h,
        Fl: f,
        Gh: g,
        Gl: y,
        Hh: w,
        Hl: m,
      } = this;
      return [e, t, r, i, s, o, a, c, u, l, h, f, g, y, w, m];
    }
    set(e, t, r, i, s, o, a, c, u, l, h, f, g, y, w, m) {
      (this.Ah = e | 0),
        (this.Al = t | 0),
        (this.Bh = r | 0),
        (this.Bl = i | 0),
        (this.Ch = s | 0),
        (this.Cl = o | 0),
        (this.Dh = a | 0),
        (this.Dl = c | 0),
        (this.Eh = u | 0),
        (this.El = l | 0),
        (this.Fh = h | 0),
        (this.Fl = f | 0),
        (this.Gh = g | 0),
        (this.Gl = y | 0),
        (this.Hh = w | 0),
        (this.Hl = m | 0);
    }
    process(e, t) {
      for (let E = 0; E < 16; E++, t += 4)
        (ps[E] = e.getUint32(t)), (gs[E] = e.getUint32((t += 4)));
      for (let E = 16; E < 80; E++) {
        let T = ps[E - 15] | 0,
          B = gs[E - 15] | 0,
          L = Ie.rotrSH(T, B, 1) ^ Ie.rotrSH(T, B, 8) ^ Ie.shrSH(T, B, 7),
          U = Ie.rotrSL(T, B, 1) ^ Ie.rotrSL(T, B, 8) ^ Ie.shrSL(T, B, 7),
          j = ps[E - 2] | 0,
          W = gs[E - 2] | 0,
          be = Ie.rotrSH(j, W, 19) ^ Ie.rotrBH(j, W, 61) ^ Ie.shrSH(j, W, 6),
          pe = Ie.rotrSL(j, W, 19) ^ Ie.rotrBL(j, W, 61) ^ Ie.shrSL(j, W, 6),
          ge = Ie.add4L(U, pe, gs[E - 7], gs[E - 16]),
          _e = Ie.add4H(ge, L, be, ps[E - 7], ps[E - 16]);
        (ps[E] = _e | 0), (gs[E] = ge | 0);
      }
      let {
        Ah: r,
        Al: i,
        Bh: s,
        Bl: o,
        Ch: a,
        Cl: c,
        Dh: u,
        Dl: l,
        Eh: h,
        El: f,
        Fh: g,
        Fl: y,
        Gh: w,
        Gl: m,
        Hh: b,
        Hl: I,
      } = this;
      for (let E = 0; E < 80; E++) {
        let T = Ie.rotrSH(h, f, 14) ^ Ie.rotrSH(h, f, 18) ^ Ie.rotrBH(h, f, 41),
          B = Ie.rotrSL(h, f, 14) ^ Ie.rotrSL(h, f, 18) ^ Ie.rotrBL(h, f, 41),
          L = (h & g) ^ (~h & w),
          U = (f & y) ^ (~f & m),
          j = Ie.add5L(I, B, U, pO[E], gs[E]),
          W = Ie.add5H(j, b, T, L, dO[E], ps[E]),
          be = j | 0,
          pe = Ie.rotrSH(r, i, 28) ^ Ie.rotrBH(r, i, 34) ^ Ie.rotrBH(r, i, 39),
          ge = Ie.rotrSL(r, i, 28) ^ Ie.rotrBL(r, i, 34) ^ Ie.rotrBL(r, i, 39),
          _e = (r & s) ^ (r & a) ^ (s & a),
          X = (i & o) ^ (i & c) ^ (o & c);
        (b = w | 0),
          (I = m | 0),
          (w = g | 0),
          (m = y | 0),
          (g = h | 0),
          (y = f | 0),
          ({ h, l: f } = Ie.add(u | 0, l | 0, W | 0, be | 0)),
          (u = a | 0),
          (l = c | 0),
          (a = s | 0),
          (c = o | 0),
          (s = r | 0),
          (o = i | 0);
        let q = Ie.add3L(be, ge, X);
        (r = Ie.add3H(q, W, pe, _e)), (i = q | 0);
      }
      ({ h: r, l: i } = Ie.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
        ({ h: s, l: o } = Ie.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
        ({ h: a, l: c } = Ie.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0)),
        ({ h: u, l } = Ie.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0)),
        ({ h, l: f } = Ie.add(this.Eh | 0, this.El | 0, h | 0, f | 0)),
        ({ h: g, l: y } = Ie.add(this.Fh | 0, this.Fl | 0, g | 0, y | 0)),
        ({ h: w, l: m } = Ie.add(this.Gh | 0, this.Gl | 0, w | 0, m | 0)),
        ({ h: b, l: I } = Ie.add(this.Hh | 0, this.Hl | 0, b | 0, I | 0)),
        this.set(r, i, s, o, a, c, u, l, h, f, g, y, w, m, b, I);
    }
    roundClean() {
      ps.fill(0), gs.fill(0);
    }
    destroy() {
      this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
var iS = FE(() => new G0());
function gO() {
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw new Error("unable to locate global object");
}
var sS = gO(),
  lG = sS.crypto || sS.msCrypto;
function K0(n) {
  switch (n) {
    case "sha256":
      return zE.create();
    case "sha512":
      return iS.create();
  }
  x(!1, "invalid hashing algorithm name", "algorithm", n);
}
p();
var oS = !1,
  aS = function (n) {
    return ME(n);
  },
  cS = aS;
function et(n) {
  let e = fe(n, "data");
  return V(cS(e));
}
et._ = aS;
et.lock = function () {
  oS = !0;
};
et.register = function (n) {
  if (oS) throw new TypeError("keccak256 is locked");
  cS = n;
};
Object.freeze(et);
p();
var uS = function (n) {
    return K0("sha256").update(n).digest();
  },
  lS = function (n) {
    return K0("sha512").update(n).digest();
  },
  hS = uS,
  fS = lS,
  dS = !1,
  pS = !1;
function ms(n) {
  let e = fe(n, "data");
  return V(hS(e));
}
ms._ = uS;
ms.lock = function () {
  dS = !0;
};
ms.register = function (n) {
  if (dS) throw new Error("sha256 is locked");
  hS = n;
};
Object.freeze(ms);
function _f(n) {
  let e = fe(n, "data");
  return V(fS(e));
}
_f._ = lS;
_f.lock = function () {
  pS = !0;
};
_f.register = function (n) {
  if (pS) throw new Error("sha512 is locked");
  fS = n;
};
Object.freeze(ms);
p();
p();
p();
p();
var Qr = "0x0000000000000000000000000000000000000000";
p();
var cl = "0x0000000000000000000000000000000000000000000000000000000000000000";
p();
var gS = BigInt(
    "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
  ),
  mS = BigInt("1000000000000000000"),
  yS = BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  ),
  wS =
    BigInt(
      "0x8000000000000000000000000000000000000000000000000000000000000000"
    ) * BigInt(-1),
  bS = BigInt(
    "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  );
var AS = BigInt(0),
  ES = BigInt(1),
  xS = BigInt(2),
  SS = BigInt(27),
  vS = BigInt(28),
  Pf = BigInt(35),
  Qa = {};
function IS(n) {
  return Ln(Rt(n), 32);
}
var In = class n {
  #e;
  #t;
  #n;
  #r;
  get r() {
    return this.#e;
  }
  set r(e) {
    x(Sr(e) === 32, "invalid r", "value", e), (this.#e = V(e));
  }
  get s() {
    return this.#t;
  }
  set s(e) {
    x(Sr(e) === 32, "invalid s", "value", e);
    let t = V(e);
    x(parseInt(t.substring(0, 3)) < 8, "non-canonical s", "value", t),
      (this.#t = t);
  }
  get v() {
    return this.#n;
  }
  set v(e) {
    let t = me(e, "value");
    x(t === 27 || t === 28, "invalid v", "v", e), (this.#n = t);
  }
  get networkV() {
    return this.#r;
  }
  get legacyChainId() {
    let e = this.networkV;
    return e == null ? null : n.getChainId(e);
  }
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  get yParityAndS() {
    let e = fe(this.s);
    return this.yParity && (e[0] |= 128), V(e);
  }
  get compactSerialized() {
    return Fe([this.r, this.yParityAndS]);
  }
  get serialized() {
    return Fe([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  constructor(e, t, r, i) {
    xr(e, Qa, "Signature"),
      (this.#e = t),
      (this.#t = r),
      (this.#n = i),
      (this.#r = null);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  clone() {
    let e = new n(Qa, this.r, this.s, this.v);
    return this.networkV && (e.#r = this.networkV), e;
  }
  toJSON() {
    let e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v,
    };
  }
  static getChainId(e) {
    let t = Y(e, "v");
    return t == SS || t == vS
      ? AS
      : (x(t >= Pf, "invalid EIP-155 v", "v", e), (t - Pf) / xS);
  }
  static getChainIdV(e, t) {
    return Y(e) * xS + BigInt(35 + t - 27);
  }
  static getNormalizedV(e) {
    let t = Y(e);
    return t === AS || t === SS
      ? 27
      : t === ES || t === vS
      ? 28
      : (x(t >= Pf, "invalid v", "v", e), t & ES ? 27 : 28);
  }
  static from(e) {
    function t(u, l) {
      x(u, l, "signature", e);
    }
    if (e == null) return new n(Qa, cl, cl, 27);
    if (typeof e == "string") {
      let u = fe(e, "signature");
      if (u.length === 64) {
        let l = V(u.slice(0, 32)),
          h = u.slice(32, 64),
          f = h[0] & 128 ? 28 : 27;
        return (h[0] &= 127), new n(Qa, l, V(h), f);
      }
      if (u.length === 65) {
        let l = V(u.slice(0, 32)),
          h = u.slice(32, 64);
        t((h[0] & 128) === 0, "non-canonical s");
        let f = n.getNormalizedV(u[64]);
        return new n(Qa, l, V(h), f);
      }
      t(!1, "invalid raw signature length");
    }
    if (e instanceof n) return e.clone();
    let r = e.r;
    t(r != null, "missing r");
    let i = IS(r),
      s = (function (u, l) {
        if (u != null) return IS(u);
        if (l != null) {
          t(De(l, 32), "invalid yParityAndS");
          let h = fe(l);
          return (h[0] &= 127), V(h);
        }
        t(!1, "missing s");
      })(e.s, e.yParityAndS);
    t((fe(s)[0] & 128) == 0, "non-canonical s");
    let { networkV: o, v: a } = (function (u, l, h) {
        if (u != null) {
          let f = Y(u);
          return { networkV: f >= Pf ? f : void 0, v: n.getNormalizedV(f) };
        }
        if (l != null)
          return (
            t(De(l, 32), "invalid yParityAndS"), { v: fe(l)[0] & 128 ? 28 : 27 }
          );
        if (h != null) {
          switch (me(h, "sig.yParity")) {
            case 0:
              return { v: 27 };
            case 1:
              return { v: 28 };
          }
          t(!1, "invalid yParity");
        }
        t(!1, "missing v");
      })(e.v, e.yParityAndS, e.yParity),
      c = new n(Qa, i, s, a);
    return (
      o && (c.#r = o),
      t(
        e.yParity == null || me(e.yParity, "sig.yParity") === c.yParity,
        "yParity mismatch"
      ),
      t(
        e.yParityAndS == null || e.yParityAndS === c.yParityAndS,
        "yParityAndS mismatch"
      ),
      c
    );
  }
};
var ys = class n {
  #e;
  constructor(e) {
    x(Sr(e) === 32, "invalid private key", "privateKey", "[REDACTED]"),
      (this.#e = V(e));
  }
  get privateKey() {
    return this.#e;
  }
  get publicKey() {
    return n.computePublicKey(this.#e);
  }
  get compressedPublicKey() {
    return n.computePublicKey(this.#e, !0);
  }
  sign(e) {
    x(Sr(e) === 32, "invalid digest length", "digest", e);
    let t = rs.sign(Ct(e), Ct(this.#e), { lowS: !0 });
    return In.from({ r: vn(t.r, 32), s: vn(t.s, 32), v: t.recovery ? 28 : 27 });
  }
  computeSharedSecret(e) {
    let t = n.computePublicKey(e);
    return V(rs.getSharedSecret(Ct(this.#e), fe(t), !1));
  }
  static computePublicKey(e, t) {
    let r = fe(e, "key");
    if (r.length === 32) {
      let s = rs.getPublicKey(r, !!t);
      return V(s);
    }
    if (r.length === 64) {
      let s = new Uint8Array(65);
      (s[0] = 4), s.set(r, 1), (r = s);
    }
    let i = rs.ProjectivePoint.fromHex(r);
    return V(i.toRawBytes(t));
  }
  static recoverPublicKey(e, t) {
    x(Sr(e) === 32, "invalid digest length", "digest", e);
    let r = In.from(t),
      i = rs.Signature.fromCompact(Ct(Fe([r.r, r.s])));
    i = i.addRecoveryBit(r.yParity);
    let s = i.recoverPublicKey(Ct(e));
    return (
      x(s != null, "invalid signautre for digest", "signature", t),
      "0x" + s.toHex(!1)
    );
  }
  static addPoints(e, t, r) {
    let i = rs.ProjectivePoint.fromHex(n.computePublicKey(e).substring(2)),
      s = rs.ProjectivePoint.fromHex(n.computePublicKey(t).substring(2));
    return "0x" + i.add(s).toHex(!!r);
  }
};
var mO = BigInt(0),
  yO = BigInt(36);
function CS(n) {
  n = n.toLowerCase();
  let e = n.substring(2).split(""),
    t = new Uint8Array(40);
  for (let i = 0; i < 40; i++) t[i] = e[i].charCodeAt(0);
  let r = fe(et(t));
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()),
      (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
var q0 = {};
for (let n = 0; n < 10; n++) q0[String(n)] = String(n);
for (let n = 0; n < 26; n++) q0[String.fromCharCode(65 + n)] = String(10 + n);
var kS = 15;
function wO(n) {
  (n = n.toUpperCase()), (n = n.substring(4) + n.substring(0, 2) + "00");
  let e = n
    .split("")
    .map((r) => q0[r])
    .join("");
  for (; e.length >= kS; ) {
    let r = e.substring(0, kS);
    e = (parseInt(r, 10) % 97) + e.substring(r.length);
  }
  let t = String(98 - (parseInt(e, 10) % 97));
  for (; t.length < 2; ) t = "0" + t;
  return t;
}
var bO = (function () {
  let n = {};
  for (let e = 0; e < 36; e++) {
    let t = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    n[t] = BigInt(e);
  }
  return n;
})();
function AO(n) {
  n = n.toLowerCase();
  let e = mO;
  for (let t = 0; t < n.length; t++) e = e * yO + bO[n[t]];
  return e;
}
function ke(n) {
  if (
    (x(typeof n == "string", "invalid address", "address", n),
    n.match(/^(0x)?[0-9a-fA-F]{40}$/))
  ) {
    n.startsWith("0x") || (n = "0x" + n);
    let e = CS(n);
    return (
      x(
        !n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === n,
        "bad address checksum",
        "address",
        n
      ),
      e
    );
  }
  if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    x(n.substring(2, 4) === wO(n), "bad icap checksum", "address", n);
    let e = AO(n.substring(4)).toString(16);
    for (; e.length < 40; ) e = "0" + e;
    return CS("0x" + e);
  }
  x(!1, "invalid address", "address", n);
}
p();
function ul(n) {
  let e = ke(n.from),
    r = Y(n.nonce, "tx.nonce").toString(16);
  return (
    r === "0" ? (r = "0x") : r.length % 2 ? (r = "0x0" + r) : (r = "0x" + r),
    ke(at(et(kr([e, r])), 12))
  );
}
p();
function Lf(n) {
  return n && typeof n.getAddress == "function";
}
function Q0(n, e) {
  return d(this, null, function* () {
    let t = yield e;
    return (
      (t == null || t === "0x0000000000000000000000000000000000000000") &&
        (R(typeof n != "string", "unconfigured name", "UNCONFIGURED_NAME", {
          value: n,
        }),
        x(
          !1,
          "invalid AddressLike value; did not resolve to a value address",
          "target",
          n
        )),
      ke(t)
    );
  });
}
function Pt(n, e) {
  if (typeof n == "string")
    return n.match(/^0x[0-9a-f]{40}$/i)
      ? ke(n)
      : (R(
          e != null,
          "ENS resolution requires a provider",
          "UNSUPPORTED_OPERATION",
          { operation: "resolveName" }
        ),
        Q0(n, e.resolveName(n)));
  if (Lf(n)) return Q0(n, n.getAddress());
  if (n && typeof n.then == "function") return Q0(n, n);
  x(!1, "unsupported addressable value", "target", n);
}
p();
var Tr = {};
function ie(n, e) {
  let t = !1;
  return (
    e < 0 && ((t = !0), (e *= -1)),
    new lt(Tr, `${t ? "" : "u"}int${e}`, n, { signed: t, width: e })
  );
}
function We(n, e) {
  return new lt(Tr, `bytes${e || ""}`, n, { size: e });
}
var TS = Symbol.for("_ethers_typed"),
  lt = class n {
    type;
    value;
    #e;
    _typedSymbol;
    constructor(e, t, r, i) {
      i == null && (i = null),
        xr(Tr, e, "Typed"),
        ee(this, { _typedSymbol: TS, type: t, value: r }),
        (this.#e = i),
        this.format();
    }
    format() {
      if (this.type === "array") throw new Error("");
      if (this.type === "dynamicArray") throw new Error("");
      return this.type === "tuple"
        ? `tuple(${this.value.map((e) => e.format()).join(",")})`
        : this.type;
    }
    defaultValue() {
      return 0;
    }
    minValue() {
      return 0;
    }
    maxValue() {
      return 0;
    }
    isBigInt() {
      return !!this.type.match(/^u?int[0-9]+$/);
    }
    isData() {
      return this.type.startsWith("bytes");
    }
    isString() {
      return this.type === "string";
    }
    get tupleName() {
      if (this.type !== "tuple") throw TypeError("not a tuple");
      return this.#e;
    }
    get arrayLength() {
      if (this.type !== "array") throw TypeError("not an array");
      return this.#e === !0 ? -1 : this.#e === !1 ? this.value.length : null;
    }
    static from(e, t) {
      return new n(Tr, e, t);
    }
    static uint8(e) {
      return ie(e, 8);
    }
    static uint16(e) {
      return ie(e, 16);
    }
    static uint24(e) {
      return ie(e, 24);
    }
    static uint32(e) {
      return ie(e, 32);
    }
    static uint40(e) {
      return ie(e, 40);
    }
    static uint48(e) {
      return ie(e, 48);
    }
    static uint56(e) {
      return ie(e, 56);
    }
    static uint64(e) {
      return ie(e, 64);
    }
    static uint72(e) {
      return ie(e, 72);
    }
    static uint80(e) {
      return ie(e, 80);
    }
    static uint88(e) {
      return ie(e, 88);
    }
    static uint96(e) {
      return ie(e, 96);
    }
    static uint104(e) {
      return ie(e, 104);
    }
    static uint112(e) {
      return ie(e, 112);
    }
    static uint120(e) {
      return ie(e, 120);
    }
    static uint128(e) {
      return ie(e, 128);
    }
    static uint136(e) {
      return ie(e, 136);
    }
    static uint144(e) {
      return ie(e, 144);
    }
    static uint152(e) {
      return ie(e, 152);
    }
    static uint160(e) {
      return ie(e, 160);
    }
    static uint168(e) {
      return ie(e, 168);
    }
    static uint176(e) {
      return ie(e, 176);
    }
    static uint184(e) {
      return ie(e, 184);
    }
    static uint192(e) {
      return ie(e, 192);
    }
    static uint200(e) {
      return ie(e, 200);
    }
    static uint208(e) {
      return ie(e, 208);
    }
    static uint216(e) {
      return ie(e, 216);
    }
    static uint224(e) {
      return ie(e, 224);
    }
    static uint232(e) {
      return ie(e, 232);
    }
    static uint240(e) {
      return ie(e, 240);
    }
    static uint248(e) {
      return ie(e, 248);
    }
    static uint256(e) {
      return ie(e, 256);
    }
    static uint(e) {
      return ie(e, 256);
    }
    static int8(e) {
      return ie(e, -8);
    }
    static int16(e) {
      return ie(e, -16);
    }
    static int24(e) {
      return ie(e, -24);
    }
    static int32(e) {
      return ie(e, -32);
    }
    static int40(e) {
      return ie(e, -40);
    }
    static int48(e) {
      return ie(e, -48);
    }
    static int56(e) {
      return ie(e, -56);
    }
    static int64(e) {
      return ie(e, -64);
    }
    static int72(e) {
      return ie(e, -72);
    }
    static int80(e) {
      return ie(e, -80);
    }
    static int88(e) {
      return ie(e, -88);
    }
    static int96(e) {
      return ie(e, -96);
    }
    static int104(e) {
      return ie(e, -104);
    }
    static int112(e) {
      return ie(e, -112);
    }
    static int120(e) {
      return ie(e, -120);
    }
    static int128(e) {
      return ie(e, -128);
    }
    static int136(e) {
      return ie(e, -136);
    }
    static int144(e) {
      return ie(e, -144);
    }
    static int152(e) {
      return ie(e, -152);
    }
    static int160(e) {
      return ie(e, -160);
    }
    static int168(e) {
      return ie(e, -168);
    }
    static int176(e) {
      return ie(e, -176);
    }
    static int184(e) {
      return ie(e, -184);
    }
    static int192(e) {
      return ie(e, -192);
    }
    static int200(e) {
      return ie(e, -200);
    }
    static int208(e) {
      return ie(e, -208);
    }
    static int216(e) {
      return ie(e, -216);
    }
    static int224(e) {
      return ie(e, -224);
    }
    static int232(e) {
      return ie(e, -232);
    }
    static int240(e) {
      return ie(e, -240);
    }
    static int248(e) {
      return ie(e, -248);
    }
    static int256(e) {
      return ie(e, -256);
    }
    static int(e) {
      return ie(e, -256);
    }
    static bytes1(e) {
      return We(e, 1);
    }
    static bytes2(e) {
      return We(e, 2);
    }
    static bytes3(e) {
      return We(e, 3);
    }
    static bytes4(e) {
      return We(e, 4);
    }
    static bytes5(e) {
      return We(e, 5);
    }
    static bytes6(e) {
      return We(e, 6);
    }
    static bytes7(e) {
      return We(e, 7);
    }
    static bytes8(e) {
      return We(e, 8);
    }
    static bytes9(e) {
      return We(e, 9);
    }
    static bytes10(e) {
      return We(e, 10);
    }
    static bytes11(e) {
      return We(e, 11);
    }
    static bytes12(e) {
      return We(e, 12);
    }
    static bytes13(e) {
      return We(e, 13);
    }
    static bytes14(e) {
      return We(e, 14);
    }
    static bytes15(e) {
      return We(e, 15);
    }
    static bytes16(e) {
      return We(e, 16);
    }
    static bytes17(e) {
      return We(e, 17);
    }
    static bytes18(e) {
      return We(e, 18);
    }
    static bytes19(e) {
      return We(e, 19);
    }
    static bytes20(e) {
      return We(e, 20);
    }
    static bytes21(e) {
      return We(e, 21);
    }
    static bytes22(e) {
      return We(e, 22);
    }
    static bytes23(e) {
      return We(e, 23);
    }
    static bytes24(e) {
      return We(e, 24);
    }
    static bytes25(e) {
      return We(e, 25);
    }
    static bytes26(e) {
      return We(e, 26);
    }
    static bytes27(e) {
      return We(e, 27);
    }
    static bytes28(e) {
      return We(e, 28);
    }
    static bytes29(e) {
      return We(e, 29);
    }
    static bytes30(e) {
      return We(e, 30);
    }
    static bytes31(e) {
      return We(e, 31);
    }
    static bytes32(e) {
      return We(e, 32);
    }
    static address(e) {
      return new n(Tr, "address", e);
    }
    static bool(e) {
      return new n(Tr, "bool", !!e);
    }
    static bytes(e) {
      return new n(Tr, "bytes", e);
    }
    static string(e) {
      return new n(Tr, "string", e);
    }
    static array(e, t) {
      throw new Error("not implemented yet");
    }
    static tuple(e, t) {
      throw new Error("not implemented yet");
    }
    static overrides(e) {
      return new n(Tr, "overrides", Object.assign({}, e));
    }
    static isTyped(e) {
      return (
        e &&
        typeof e == "object" &&
        "_typedSymbol" in e &&
        e._typedSymbol === TS
      );
    }
    static dereference(e, t) {
      if (n.isTyped(e)) {
        if (e.type !== t)
          throw new Error(`invalid type: expecetd ${t}, got ${e.type}`);
        return e.value;
      }
      return e;
    }
  };
var Of = class extends _t {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, t) {
    let r = lt.dereference(t, "string");
    try {
      r = ke(r);
    } catch (i) {
      return this._throwError(i.message, t);
    }
    return e.writeValue(r);
  }
  decode(e) {
    return ke(vn(e.readValue(), 20));
  }
};
p();
p();
var Nf = class extends _t {
  coder;
  constructor(e) {
    super(e.name, e.type, "_", e.dynamic), (this.coder = e);
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, t) {
    return this.coder.encode(e, t);
  }
  decode(e) {
    return this.coder.decode(e);
  }
};
function J0(n, e, t) {
  let r = [];
  if (Array.isArray(t)) r = t;
  else if (t && typeof t == "object") {
    let c = {};
    r = e.map((u) => {
      let l = u.localName;
      return (
        R(
          l,
          "cannot encode object for signature with missing names",
          "INVALID_ARGUMENT",
          { argument: "values", info: { coder: u }, value: t }
        ),
        R(
          !c[l],
          "cannot encode object for signature with duplicate names",
          "INVALID_ARGUMENT",
          { argument: "values", info: { coder: u }, value: t }
        ),
        (c[l] = !0),
        t[l]
      );
    });
  } else x(!1, "invalid tuple value", "tuple", t);
  x(e.length === r.length, "types/value length mismatch", "tuple", t);
  let i = new fo(),
    s = new fo(),
    o = [];
  e.forEach((c, u) => {
    let l = r[u];
    if (c.dynamic) {
      let h = s.length;
      c.encode(s, l);
      let f = i.writeUpdatableValue();
      o.push((g) => {
        f(g + h);
      });
    } else c.encode(i, l);
  }),
    o.forEach((c) => {
      c(i.length);
    });
  let a = n.appendWriter(i);
  return (a += n.appendWriter(s)), a;
}
function Y0(n, e) {
  let t = [],
    r = [],
    i = n.subReader(0);
  return (
    e.forEach((s) => {
      let o = null;
      if (s.dynamic) {
        let a = n.readIndex(),
          c = i.subReader(a);
        try {
          o = s.decode(c);
        } catch (u) {
          if (ut(u, "BUFFER_OVERRUN")) throw u;
          (o = u),
            (o.baseType = s.name),
            (o.name = s.localName),
            (o.type = s.type);
        }
      } else
        try {
          o = s.decode(n);
        } catch (a) {
          if (ut(a, "BUFFER_OVERRUN")) throw a;
          (o = a),
            (o.baseType = s.name),
            (o.name = s.localName),
            (o.type = s.type);
        }
      if (o == null) throw new Error("investigate");
      t.push(o), r.push(s.localName || null);
    }),
    Ti.fromItems(t, r)
  );
}
var Ff = class extends _t {
  coder;
  length;
  constructor(e, t, r) {
    let i = e.type + "[" + (t >= 0 ? t : "") + "]",
      s = t === -1 || e.dynamic;
    super("array", i, r, s), ee(this, { coder: e, length: t });
  }
  defaultValue() {
    let e = this.coder.defaultValue(),
      t = [];
    for (let r = 0; r < this.length; r++) t.push(e);
    return t;
  }
  encode(e, t) {
    let r = lt.dereference(t, "array");
    Array.isArray(r) || this._throwError("expected array value", r);
    let i = this.length;
    i === -1 && ((i = r.length), e.writeValue(r.length)),
      ja(
        r.length,
        i,
        "coder array" + (this.localName ? " " + this.localName : "")
      );
    let s = [];
    for (let o = 0; o < r.length; o++) s.push(this.coder);
    return J0(e, s, r);
  }
  decode(e) {
    let t = this.length;
    t === -1 &&
      ((t = e.readIndex()),
      R(t * rn <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
        buffer: e.bytes,
        offset: t * rn,
        length: e.dataLength,
      }));
    let r = [];
    for (let i = 0; i < t; i++) r.push(new Nf(this.coder));
    return Y0(e, r);
  }
};
p();
var Mf = class extends _t {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    let r = lt.dereference(t, "bool");
    return e.writeValue(r ? 1 : 0);
  }
  decode(e) {
    return !!e.readValue();
  }
};
p();
var ll = class extends _t {
    constructor(e, t) {
      super(e, e, t, !0);
    }
    defaultValue() {
      return "0x";
    }
    encode(e, t) {
      t = Ct(t);
      let r = e.writeValue(t.length);
      return (r += e.writeBytes(t)), r;
    }
    decode(e) {
      return e.readBytes(e.readIndex(), !0);
    }
  },
  Uf = class extends ll {
    constructor(e) {
      super("bytes", e);
    }
    decode(e) {
      return V(super.decode(e));
    }
  };
p();
var zf = class extends _t {
  size;
  constructor(e, t) {
    let r = "bytes" + String(e);
    super(r, r, t, !1), ee(this, { size: e }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
      0,
      2 + this.size * 2
    );
  }
  encode(e, t) {
    let r = Ct(lt.dereference(t, this.type));
    return (
      r.length !== this.size && this._throwError("incorrect data length", t),
      e.writeBytes(r)
    );
  }
  decode(e) {
    return V(e.readBytes(this.size));
  }
};
p();
var EO = new Uint8Array([]),
  jf = class extends _t {
    constructor(e) {
      super("null", "", e, !1);
    }
    defaultValue() {
      return null;
    }
    encode(e, t) {
      return t != null && this._throwError("not null", t), e.writeBytes(EO);
    }
    decode(e) {
      return e.readBytes(0), null;
    }
  };
p();
var xO = BigInt(0),
  SO = BigInt(1),
  vO = BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  ),
  Wf = class extends _t {
    size;
    signed;
    constructor(e, t, r) {
      let i = (t ? "int" : "uint") + e * 8;
      super(i, i, r, !1),
        ee(this, { size: e, signed: t }, { size: "number", signed: "boolean" });
    }
    defaultValue() {
      return 0;
    }
    encode(e, t) {
      let r = Y(lt.dereference(t, this.type)),
        i = hr(vO, rn * 8);
      if (this.signed) {
        let s = hr(i, this.size * 8 - 1);
        (r > s || r < -(s + SO)) && this._throwError("value out-of-bounds", t),
          (r = Ha(r, 8 * rn));
      } else
        (r < xO || r > hr(i, this.size * 8)) &&
          this._throwError("value out-of-bounds", t);
      return e.writeValue(r);
    }
    decode(e) {
      let t = hr(e.readValue(), this.size * 8);
      return this.signed && (t = fs(t, this.size * 8)), t;
    }
  };
p();
var Hf = class extends ll {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, t) {
    return super.encode(e, mn(lt.dereference(t, "string")));
  }
  decode(e) {
    return ki(super.decode(e));
  }
};
p();
var po = class extends _t {
  coders;
  constructor(e, t) {
    let r = !1,
      i = [];
    e.forEach((o) => {
      o.dynamic && (r = !0), i.push(o.type);
    });
    let s = "tuple(" + i.join(",") + ")";
    super("tuple", s, t, r), ee(this, { coders: Object.freeze(e.slice()) });
  }
  defaultValue() {
    let e = [];
    this.coders.forEach((r) => {
      e.push(r.defaultValue());
    });
    let t = this.coders.reduce((r, i) => {
      let s = i.localName;
      return s && (r[s] || (r[s] = 0), r[s]++), r;
    }, {});
    return (
      this.coders.forEach((r, i) => {
        let s = r.localName;
        !s ||
          t[s] !== 1 ||
          (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]));
      }),
      Object.freeze(e)
    );
  }
  encode(e, t) {
    let r = lt.dereference(t, "tuple");
    return J0(e, this.coders, r);
  }
  decode(e) {
    return Y0(e, this.coders);
  }
};
p();
p();
p();
function Rr(n) {
  return et(mn(n));
}
p();
p();
var IO =
    "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI",
  RS = new Map([
    [8217, "apostrophe"],
    [8260, "fraction slash"],
    [12539, "middle dot"],
  ]),
  BS = 4;
function CO(n) {
  let e = 0;
  function t() {
    return (n[e++] << 8) | n[e++];
  }
  let r = t(),
    i = 1,
    s = [0, 1];
  for (let B = 1; B < r; B++) s.push((i += t()));
  let o = t(),
    a = e;
  e += o;
  let c = 0,
    u = 0;
  function l() {
    return c == 0 && ((u = (u << 8) | n[e++]), (c = 8)), (u >> --c) & 1;
  }
  let h = 31,
    f = 2 ** h,
    g = f >>> 1,
    y = g >> 1,
    w = f - 1,
    m = 0;
  for (let B = 0; B < h; B++) m = (m << 1) | l();
  let b = [],
    I = 0,
    E = f;
  for (;;) {
    let B = Math.floor(((m - I + 1) * i - 1) / E),
      L = 0,
      U = r;
    for (; U - L > 1; ) {
      let be = (L + U) >>> 1;
      B < s[be] ? (U = be) : (L = be);
    }
    if (L == 0) break;
    b.push(L);
    let j = I + Math.floor((E * s[L]) / i),
      W = I + Math.floor((E * s[L + 1]) / i) - 1;
    for (; !((j ^ W) & g); )
      (m = ((m << 1) & w) | l()), (j = (j << 1) & w), (W = ((W << 1) & w) | 1);
    for (; j & ~W & y; )
      (m = (m & g) | ((m << 1) & (w >>> 1)) | l()),
        (j = (j << 1) ^ g),
        (W = ((W ^ g) << 1) | g | 1);
    (I = j), (E = 1 + W - j);
  }
  let T = r - 4;
  return b.map((B) => {
    switch (B - T) {
      case 3:
        return T + 65792 + ((n[a++] << 16) | (n[a++] << 8) | n[a++]);
      case 2:
        return T + 256 + ((n[a++] << 8) | n[a++]);
      case 1:
        return T + n[a++];
      default:
        return B - 1;
    }
  });
}
function kO(n) {
  let e = 0;
  return () => n[e++];
}
function LS(n) {
  return kO(CO(TO(n)));
}
function TO(n) {
  let e = [];
  [
    ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  ].forEach((i, s) => (e[i.charCodeAt(0)] = s));
  let t = n.length,
    r = new Uint8Array((6 * t) >> 3);
  for (let i = 0, s = 0, o = 0, a = 0; i < t; i++)
    (a = (a << 6) | e[n.charCodeAt(i)]),
      (o += 6),
      o >= 8 && (r[s++] = a >> (o -= 8));
  return r;
}
function RO(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function BO(n, e) {
  let t = Array(n);
  for (let r = 0, i = 0; r < n; r++) t[r] = i += RO(e());
  return t;
}
function dl(n, e = 0) {
  let t = [];
  for (;;) {
    let r = n(),
      i = n();
    if (!i) break;
    e += r;
    for (let s = 0; s < i; s++) t.push(e + s);
    e += i + 1;
  }
  return t;
}
function OS(n) {
  return pl(() => {
    let e = dl(n);
    if (e.length) return e;
  });
}
function NS(n) {
  let e = [];
  for (;;) {
    let t = n();
    if (t == 0) break;
    e.push(DO(t, n));
  }
  for (;;) {
    let t = n() - 1;
    if (t < 0) break;
    e.push(_O(t, n));
  }
  return e.flat();
}
function pl(n) {
  let e = [];
  for (;;) {
    let t = n(e.length);
    if (!t) break;
    e.push(t);
  }
  return e;
}
function FS(n, e, t) {
  let r = Array(n)
    .fill()
    .map(() => []);
  for (let i = 0; i < e; i++) BO(n, t).forEach((s, o) => r[o].push(s));
  return r;
}
function DO(n, e) {
  let t = 1 + e(),
    r = e(),
    i = pl(e);
  return FS(i.length, 1 + n, e).flatMap((o, a) => {
    let [c, ...u] = o;
    return Array(i[a])
      .fill()
      .map((l, h) => {
        let f = h * r;
        return [c + h * t, u.map((g) => g + f)];
      });
  });
}
function _O(n, e) {
  let t = 1 + e();
  return FS(t, 1 + n, e).map((i) => [i[0], i.slice(1)]);
}
function PO(n) {
  let e = [],
    t = dl(n);
  return i(r([]), []), e;
  function r(s) {
    let o = n(),
      a = pl(() => {
        let c = dl(n).map((u) => t[u]);
        if (c.length) return r(c);
      });
    return { S: o, B: a, Q: s };
  }
  function i({ S: s, B: o }, a, c) {
    if (!(s & 4 && c === a[a.length - 1])) {
      s & 2 && (c = a[a.length - 1]), s & 1 && e.push(a);
      for (let u of o) for (let l of u.Q) i(u, [...a, l], c);
    }
  }
}
function LO(n) {
  return n.toString(16).toUpperCase().padStart(2, "0");
}
function MS(n) {
  return `{${LO(n)}}`;
}
function OO(n) {
  let e = [];
  for (let t = 0, r = n.length; t < r; ) {
    let i = n.codePointAt(t);
    (t += i < 65536 ? 1 : 2), e.push(i);
  }
  return e;
}
function Za(n) {
  let t = n.length;
  if (t < 4096) return String.fromCodePoint(...n);
  let r = [];
  for (let i = 0; i < t; )
    r.push(String.fromCodePoint(...n.slice(i, (i += 4096))));
  return r.join("");
}
function NO(n, e) {
  let t = n.length,
    r = t - e.length;
  for (let i = 0; r == 0 && i < t; i++) r = n[i] - e[i];
  return r;
}
var FO =
    "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g",
  gl = 44032,
  $f = 4352,
  Gf = 4449,
  Kf = 4519,
  US = 19,
  zS = 21,
  Xa = 28,
  qf = zS * Xa,
  MO = US * qf,
  UO = gl + MO,
  zO = $f + US,
  jO = Gf + zS,
  WO = Kf + Xa;
function hl(n) {
  return (n >> 24) & 255;
}
function jS(n) {
  return n & 16777215;
}
var X0, DS, ey, Vf;
function HO() {
  let n = LS(FO);
  (X0 = new Map(OS(n).flatMap((e, t) => e.map((r) => [r, (t + 1) << 24])))),
    (DS = new Set(dl(n))),
    (ey = new Map()),
    (Vf = new Map());
  for (let [e, t] of NS(n)) {
    if (!DS.has(e) && t.length == 2) {
      let [r, i] = t,
        s = Vf.get(r);
      s || ((s = new Map()), Vf.set(r, s)), s.set(i, e);
    }
    ey.set(e, t.reverse());
  }
}
function WS(n) {
  return n >= gl && n < UO;
}
function VO(n, e) {
  if (n >= $f && n < zO && e >= Gf && e < jO)
    return gl + (n - $f) * qf + (e - Gf) * Xa;
  if (WS(n) && e > Kf && e < WO && (n - gl) % Xa == 0) return n + (e - Kf);
  {
    let t = Vf.get(n);
    return t && ((t = t.get(e)), t) ? t : -1;
  }
}
function HS(n) {
  X0 || HO();
  let e = [],
    t = [],
    r = !1;
  function i(s) {
    let o = X0.get(s);
    o && ((r = !0), (s |= o)), e.push(s);
  }
  for (let s of n)
    for (;;) {
      if (s < 128) e.push(s);
      else if (WS(s)) {
        let o = s - gl,
          a = (o / qf) | 0,
          c = ((o % qf) / Xa) | 0,
          u = o % Xa;
        i($f + a), i(Gf + c), u > 0 && i(Kf + u);
      } else {
        let o = ey.get(s);
        o ? t.push(...o) : i(s);
      }
      if (!t.length) break;
      s = t.pop();
    }
  if (r && e.length > 1) {
    let s = hl(e[0]);
    for (let o = 1; o < e.length; o++) {
      let a = hl(e[o]);
      if (a == 0 || s <= a) {
        s = a;
        continue;
      }
      let c = o - 1;
      for (;;) {
        let u = e[c + 1];
        if (((e[c + 1] = e[c]), (e[c] = u), !c || ((s = hl(e[--c])), s <= a)))
          break;
      }
      s = hl(e[o]);
    }
  }
  return e;
}
function $O(n) {
  let e = [],
    t = [],
    r = -1,
    i = 0;
  for (let s of n) {
    let o = hl(s),
      a = jS(s);
    if (r == -1) o == 0 ? (r = a) : e.push(a);
    else if (i > 0 && i >= o)
      o == 0 ? (e.push(r, ...t), (t.length = 0), (r = a)) : t.push(a), (i = o);
    else {
      let c = VO(r, a);
      c >= 0
        ? (r = c)
        : i == 0 && o == 0
        ? (e.push(r), (r = a))
        : (t.push(a), (i = o));
    }
  }
  return r >= 0 && e.push(r, ...t), e;
}
function VS(n) {
  return HS(n).map(jS);
}
function GO(n) {
  return $O(HS(n));
}
var _S = 45;
var $S = ".",
  GS = 65039,
  KS = 1,
  Qf = (n) => Array.from(n);
function ml(n, e) {
  return n.P.has(e) || n.Q.has(e);
}
var ty = class extends Array {
    get is_emoji() {
      return !0;
    }
  },
  ny,
  qS,
  mo,
  ry,
  QS,
  KO,
  Ya,
  Z0,
  Ja,
  go,
  PS,
  iy;
function sy() {
  if (ny) return;
  let n = LS(IO),
    e = () => dl(n),
    t = () => new Set(e()),
    r = (l, h) => h.forEach((f) => l.add(f));
  (ny = new Map(NS(n))),
    (qS = t()),
    (mo = e()),
    (ry = new Set(e().map((l) => mo[l]))),
    (mo = new Set(mo)),
    (QS = t()),
    (KO = t());
  let i = OS(n),
    s = n(),
    o = () => {
      let l = new Set();
      return e().forEach((h) => r(l, i[h])), r(l, e()), l;
    };
  (Ya = pl((l) => {
    let h = pl(n).map((f) => f + 96);
    if (h.length) {
      let f = l >= s;
      (h[0] -= 32), (h = Za(h)), f && (h = `Restricted[${h}]`);
      let g = o(),
        y = o(),
        w = !n();
      return { N: h, P: g, Q: y, M: w, R: f };
    }
  })),
    (Z0 = t()),
    (Ja = new Map());
  let a = e()
    .concat(Qf(Z0))
    .sort((l, h) => l - h);
  a.forEach((l, h) => {
    let f = n(),
      g = (a[h] = f ? a[h - f] : { V: [], M: new Map() });
    g.V.push(l), Z0.has(l) || Ja.set(l, g);
  });
  for (let { V: l, M: h } of new Set(Ja.values())) {
    let f = [];
    for (let y of l) {
      let w = Ya.filter((b) => ml(b, y)),
        m = f.find(({ G: b }) => w.some((I) => b.has(I)));
      m || ((m = { G: new Set(), V: [] }), f.push(m)), m.V.push(y), r(m.G, w);
    }
    let g = f.flatMap((y) => Qf(y.G));
    for (let { G: y, V: w } of f) {
      let m = new Set(g.filter((b) => !y.has(b)));
      for (let b of w) h.set(b, m);
    }
  }
  go = new Set();
  let c = new Set(),
    u = (l) => (go.has(l) ? c.add(l) : go.add(l));
  for (let l of Ya) {
    for (let h of l.P) u(h);
    for (let h of l.Q) u(h);
  }
  for (let l of go) !Ja.has(l) && !c.has(l) && Ja.set(l, KS);
  r(go, VS(go)),
    (PS = PO(n)
      .map((l) => ty.from(l))
      .sort(NO)),
    (iy = new Map());
  for (let l of PS) {
    let h = [iy];
    for (let f of l) {
      let g = h.map((y) => {
        let w = y.get(f);
        return w || ((w = new Map()), y.set(f, w)), w;
      });
      f === GS ? h.push(...g) : (h = g);
    }
    for (let f of h) f.V = l;
  }
}
function oy(n) {
  return (JS(n) ? "" : `${ay(Jf([n]))} `) + MS(n);
}
function ay(n) {
  return `"${n}"\u200E`;
}
function qO(n) {
  if (n.length >= 4 && n[2] == _S && n[3] == _S)
    throw new Error(`invalid label extension: "${Za(n.slice(0, 4))}"`);
}
function QO(n) {
  for (let t = n.lastIndexOf(95); t > 0; )
    if (n[--t] !== 95) throw new Error("underscore allowed only at start");
}
function JO(n) {
  let e = n[0],
    t = RS.get(e);
  if (t) throw fl(`leading ${t}`);
  let r = n.length,
    i = -1;
  for (let s = 1; s < r; s++) {
    e = n[s];
    let o = RS.get(e);
    if (o) {
      if (i == s) throw fl(`${t} + ${o}`);
      (i = s + 1), (t = o);
    }
  }
  if (i == r) throw fl(`trailing ${t}`);
}
function Jf(n, e = 1 / 0, t = MS) {
  let r = [];
  YO(n[0]) && r.push("\u25CC"),
    n.length > e && ((e >>= 1), (n = [...n.slice(0, e), 8230, ...n.slice(-e)]));
  let i = 0,
    s = n.length;
  for (let o = 0; o < s; o++) {
    let a = n[o];
    JS(a) && (r.push(Za(n.slice(i, o))), r.push(t(a)), (i = o + 1));
  }
  return r.push(Za(n.slice(i, s))), r.join("");
}
function YO(n) {
  return sy(), mo.has(n);
}
function JS(n) {
  return sy(), QS.has(n);
}
function YS(n) {
  return tN(ZO(n, GO, iN));
}
function ZO(n, e, t) {
  if (!n) return [];
  sy();
  let r = 0;
  return n.split($S).map((i) => {
    let s = OO(i),
      o = { input: s, offset: r };
    r += s.length + 1;
    try {
      let a = (o.tokens = rN(s, e, t)),
        c = a.length,
        u;
      if (!c) throw new Error("empty label");
      let l = (o.output = a.flat());
      if (
        (QO(l), !(o.emoji = c > 1 || a[0].is_emoji) && l.every((f) => f < 128))
      )
        qO(l), (u = "ASCII");
      else {
        let f = a.flatMap((g) => (g.is_emoji ? [] : g));
        if (!f.length) u = "Emoji";
        else {
          if (mo.has(l[0])) throw fl("leading combining mark");
          for (let w = 1; w < c; w++) {
            let m = a[w];
            if (!m.is_emoji && mo.has(m[0]))
              throw fl(
                `emoji + combining mark: "${Za(a[w - 1])} + ${Jf([m[0]])}"`
              );
          }
          JO(l);
          let g = Qf(new Set(f)),
            [y] = eN(g);
          nN(y, f), XO(y, g), (u = y.N);
        }
      }
      o.type = u;
    } catch (a) {
      o.error = a;
    }
    return o;
  });
}
function XO(n, e) {
  let t,
    r = [];
  for (let i of e) {
    let s = Ja.get(i);
    if (s === KS) return;
    if (s) {
      let o = s.M.get(i);
      if (((t = t ? t.filter((a) => o.has(a)) : Qf(o)), !t.length)) return;
    } else r.push(i);
  }
  if (t) {
    for (let i of t)
      if (r.every((s) => ml(i, s)))
        throw new Error(`whole-script confusable: ${n.N}/${i.N}`);
  }
}
function eN(n) {
  let e = Ya;
  for (let t of n) {
    let r = e.filter((i) => ml(i, t));
    if (!r.length) throw Ya.some((i) => ml(i, t)) ? XS(e[0], t) : ZS(t);
    if (((e = r), r.length == 1)) break;
  }
  return e;
}
function tN(n) {
  return n
    .map(({ input: e, error: t, output: r }) => {
      if (t) {
        let i = t.message;
        throw new Error(
          n.length == 1 ? i : `Invalid label ${ay(Jf(e, 63))}: ${i}`
        );
      }
      return Za(r);
    })
    .join($S);
}
function ZS(n) {
  return new Error(`disallowed character: ${oy(n)}`);
}
function XS(n, e) {
  let t = oy(e),
    r = Ya.find((i) => i.P.has(e));
  return r && (t = `${r.N} ${t}`), new Error(`illegal mixture: ${n.N} + ${t}`);
}
function fl(n) {
  return new Error(`illegal placement: ${n}`);
}
function nN(n, e) {
  for (let t of e) if (!ml(n, t)) throw XS(n, t);
  if (n.M) {
    let t = VS(e);
    for (let r = 1, i = t.length; r < i; r++)
      if (ry.has(t[r])) {
        let s = r + 1;
        for (let o; s < i && ry.has((o = t[s])); s++)
          for (let a = r; a < s; a++)
            if (t[a] == o)
              throw new Error(`duplicate non-spacing marks: ${oy(o)}`);
        if (s - r > BS)
          throw new Error(
            `excessive non-spacing marks: ${ay(Jf(t.slice(r - 1, s)))} (${
              s - r
            }/${BS})`
          );
        r = s;
      }
  }
}
function rN(n, e, t) {
  let r = [],
    i = [];
  for (n = n.slice().reverse(); n.length; ) {
    let s = sN(n);
    if (s) i.length && (r.push(e(i)), (i = [])), r.push(t(s));
    else {
      let o = n.pop();
      if (go.has(o)) i.push(o);
      else {
        let a = ny.get(o);
        if (a) i.push(...a);
        else if (!qS.has(o)) throw ZS(o);
      }
    }
  }
  return i.length && r.push(e(i)), r;
}
function iN(n) {
  return n.filter((e) => e != GS);
}
function sN(n, e) {
  let t = iy,
    r,
    i = n.length;
  for (; i && ((t = t.get(n[--i])), !!t); ) {
    let { V: s } = t;
    s && ((r = s), e && e.push(...n.slice(i).reverse()), (n.length = i));
  }
  return r;
}
var tv = new Uint8Array(32);
tv.fill(0);
function ev(n) {
  return x(n.length !== 0, "invalid ENS name; empty component", "comp", n), n;
}
function nv(n) {
  let e = mn(rv(n)),
    t = [];
  if (n.length === 0) return t;
  let r = 0;
  for (let i = 0; i < e.length; i++)
    e[i] === 46 && (t.push(ev(e.slice(r, i))), (r = i + 1));
  return (
    x(r < e.length, "invalid ENS name; empty component", "name", n),
    t.push(ev(e.slice(r))),
    t
  );
}
function rv(n) {
  try {
    if (n.length === 0) throw new Error("empty label");
    return YS(n);
  } catch (e) {
    x(!1, `invalid ENS name (${e.message})`, "name", n);
  }
}
function ec(n) {
  x(typeof n == "string", "invalid ENS name; not a string", "name", n),
    x(n.length, "invalid ENS name (empty label)", "name", n);
  let e = tv,
    t = nv(n);
  for (; t.length; ) e = et(Fe([e, et(t.pop())]));
  return V(e);
}
function cy(n, e) {
  let t = e ?? 63;
  return (
    x(t <= 255, "DNS encoded label cannot exceed 255", "length", t),
    V(
      Fe(
        nv(n).map((r) => {
          x(
            r.length <= t,
            `label ${JSON.stringify(n)} exceeds ${t} bytes`,
            "name",
            n
          );
          let i = new Uint8Array(r.length + 1);
          return i.set(r, 1), (i[0] = i.length - 1), i;
        })
      )
    ) + "00"
  );
}
p();
p();
function uy(n, e) {
  return {
    address: ke(n),
    storageKeys: e.map(
      (t, r) => (
        x(De(t, 32), "invalid slot", `storageKeys[${r}]`, t), t.toLowerCase()
      )
    ),
  };
}
function Yn(n) {
  if (Array.isArray(n))
    return n.map((t, r) =>
      Array.isArray(t)
        ? (x(t.length === 2, "invalid slot set", `value[${r}]`, t),
          uy(t[0], t[1]))
        : (x(
            t != null && typeof t == "object",
            "invalid address-slot set",
            "value",
            n
          ),
          uy(t.address, t.storageKeys))
    );
  x(n != null && typeof n == "object", "invalid access list", "value", n);
  let e = Object.keys(n).map((t) => {
    let r = n[t].reduce((i, s) => ((i[s] = !0), i), {});
    return uy(t, Object.keys(r).sort());
  });
  return e.sort((t, r) => t.address.localeCompare(r.address)), e;
}
p();
function oN(n) {
  let e;
  return (
    typeof n == "string" ? (e = ys.computePublicKey(n, !1)) : (e = n.publicKey),
    ke(et("0x" + e.substring(4)).substring(26))
  );
}
function iv(n, e) {
  return oN(ys.recoverPublicKey(n, e));
}
p();
var Gt = BigInt(0),
  aN = BigInt(2),
  cN = BigInt(27),
  uN = BigInt(28),
  lN = BigInt(35),
  hN = BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  ),
  ly = 4096 * 32;
function sv(n, e) {
  let t = n.toString(16);
  for (; t.length < 2; ) t = "0" + t;
  return (t += ms(e).substring(4)), "0x" + t;
}
function Yf(n) {
  return n === "0x" ? null : ke(n);
}
function hy(n, e) {
  try {
    return Yn(n);
  } catch (t) {
    x(!1, t.message, e, n);
  }
}
function yl(n, e) {
  return n === "0x" ? 0 : me(n, e);
}
function Bt(n, e) {
  if (n === "0x") return Gt;
  let t = Y(n, e);
  return x(t <= hN, "value exceeds uint size", e, t), t;
}
function pt(n, e) {
  let t = Y(n, "value"),
    r = Rt(t);
  return x(r.length <= 32, "value too large", `tx.${e}`, t), r;
}
function fy(n) {
  return Yn(n).map((e) => [e.address, e.storageKeys]);
}
function fN(n, e) {
  x(Array.isArray(n), `invalid ${e}`, "value", n);
  for (let t = 0; t < n.length; t++)
    x(De(n[t], 32), "invalid ${ param } hash", `value[${t}]`, n[t]);
  return n;
}
function dN(n) {
  let e = lo(n);
  x(
    Array.isArray(e) && (e.length === 9 || e.length === 6),
    "invalid field count for legacy transaction",
    "data",
    n
  );
  let t = {
    type: 0,
    nonce: yl(e[0], "nonce"),
    gasPrice: Bt(e[1], "gasPrice"),
    gasLimit: Bt(e[2], "gasLimit"),
    to: Yf(e[3]),
    value: Bt(e[4], "value"),
    data: V(e[5]),
    chainId: Gt,
  };
  if (e.length === 6) return t;
  let r = Bt(e[6], "v"),
    i = Bt(e[7], "r"),
    s = Bt(e[8], "s");
  if (i === Gt && s === Gt) t.chainId = r;
  else {
    let o = (r - lN) / aN;
    o < Gt && (o = Gt),
      (t.chainId = o),
      x(o !== Gt || r === cN || r === uN, "non-canonical legacy v", "v", e[6]),
      (t.signature = In.from({ r: Ln(e[7], 32), s: Ln(e[8], 32), v: r }));
  }
  return t;
}
function pN(n, e) {
  let t = [
      pt(n.nonce, "nonce"),
      pt(n.gasPrice || 0, "gasPrice"),
      pt(n.gasLimit, "gasLimit"),
      n.to || "0x",
      pt(n.value, "value"),
      n.data,
    ],
    r = Gt;
  if (n.chainId != Gt)
    (r = Y(n.chainId, "tx.chainId")),
      x(
        !e || e.networkV == null || e.legacyChainId === r,
        "tx.chainId/sig.v mismatch",
        "sig",
        e
      );
  else if (n.signature) {
    let s = n.signature.legacyChainId;
    s != null && (r = s);
  }
  if (!e) return r !== Gt && (t.push(Rt(r)), t.push("0x"), t.push("0x")), kr(t);
  let i = BigInt(27 + e.yParity);
  return (
    r !== Gt
      ? (i = In.getChainIdV(r, e.v))
      : BigInt(e.v) !== i && x(!1, "tx.chainId/sig.v mismatch", "sig", e),
    t.push(Rt(i)),
    t.push(Rt(e.r)),
    t.push(Rt(e.s)),
    kr(t)
  );
}
function dy(n, e) {
  let t;
  try {
    if (((t = yl(e[0], "yParity")), t !== 0 && t !== 1))
      throw new Error("bad yParity");
  } catch {
    x(!1, "invalid yParity", "yParity", e[0]);
  }
  let r = Ln(e[1], 32),
    i = Ln(e[2], 32),
    s = In.from({ r, s: i, yParity: t });
  n.signature = s;
}
function gN(n) {
  let e = lo(fe(n).slice(1));
  x(
    Array.isArray(e) && (e.length === 9 || e.length === 12),
    "invalid field count for transaction type: 2",
    "data",
    V(n)
  );
  let t = {
    type: 2,
    chainId: Bt(e[0], "chainId"),
    nonce: yl(e[1], "nonce"),
    maxPriorityFeePerGas: Bt(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Bt(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Bt(e[4], "gasLimit"),
    to: Yf(e[5]),
    value: Bt(e[6], "value"),
    data: V(e[7]),
    accessList: hy(e[8], "accessList"),
  };
  return e.length === 9 || dy(t, e.slice(9)), t;
}
function mN(n, e) {
  let t = [
    pt(n.chainId, "chainId"),
    pt(n.nonce, "nonce"),
    pt(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    pt(n.maxFeePerGas || 0, "maxFeePerGas"),
    pt(n.gasLimit, "gasLimit"),
    n.to || "0x",
    pt(n.value, "value"),
    n.data,
    fy(n.accessList || []),
  ];
  return (
    e && (t.push(pt(e.yParity, "yParity")), t.push(Rt(e.r)), t.push(Rt(e.s))),
    Fe(["0x02", kr(t)])
  );
}
function yN(n) {
  let e = lo(fe(n).slice(1));
  x(
    Array.isArray(e) && (e.length === 8 || e.length === 11),
    "invalid field count for transaction type: 1",
    "data",
    V(n)
  );
  let t = {
    type: 1,
    chainId: Bt(e[0], "chainId"),
    nonce: yl(e[1], "nonce"),
    gasPrice: Bt(e[2], "gasPrice"),
    gasLimit: Bt(e[3], "gasLimit"),
    to: Yf(e[4]),
    value: Bt(e[5], "value"),
    data: V(e[6]),
    accessList: hy(e[7], "accessList"),
  };
  return e.length === 8 || dy(t, e.slice(8)), t;
}
function wN(n, e) {
  let t = [
    pt(n.chainId, "chainId"),
    pt(n.nonce, "nonce"),
    pt(n.gasPrice || 0, "gasPrice"),
    pt(n.gasLimit, "gasLimit"),
    n.to || "0x",
    pt(n.value, "value"),
    n.data,
    fy(n.accessList || []),
  ];
  return (
    e &&
      (t.push(pt(e.yParity, "recoveryParam")),
      t.push(Rt(e.r)),
      t.push(Rt(e.s))),
    Fe(["0x01", kr(t)])
  );
}
function bN(n) {
  let e = lo(fe(n).slice(1)),
    t = "3",
    r = null;
  if (e.length === 4 && Array.isArray(e[0])) {
    t = "3 (network format)";
    let s = e[1],
      o = e[2],
      a = e[3];
    x(
      Array.isArray(s),
      "invalid network format: blobs not an array",
      "fields[1]",
      s
    ),
      x(
        Array.isArray(o),
        "invalid network format: commitments not an array",
        "fields[2]",
        o
      ),
      x(
        Array.isArray(a),
        "invalid network format: proofs not an array",
        "fields[3]",
        a
      ),
      x(
        s.length === o.length,
        "invalid network format: blobs/commitments length mismatch",
        "fields",
        e
      ),
      x(
        s.length === a.length,
        "invalid network format: blobs/proofs length mismatch",
        "fields",
        e
      ),
      (r = []);
    for (let c = 0; c < e[1].length; c++)
      r.push({ data: s[c], commitment: o[c], proof: a[c] });
    e = e[0];
  }
  x(
    Array.isArray(e) && (e.length === 11 || e.length === 14),
    `invalid field count for transaction type: ${t}`,
    "data",
    V(n)
  );
  let i = {
    type: 3,
    chainId: Bt(e[0], "chainId"),
    nonce: yl(e[1], "nonce"),
    maxPriorityFeePerGas: Bt(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Bt(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Bt(e[4], "gasLimit"),
    to: Yf(e[5]),
    value: Bt(e[6], "value"),
    data: V(e[7]),
    accessList: hy(e[8], "accessList"),
    maxFeePerBlobGas: Bt(e[9], "maxFeePerBlobGas"),
    blobVersionedHashes: e[10],
  };
  r && (i.blobs = r),
    x(i.to != null, `invalid address for transaction type: ${t}`, "data", n),
    x(
      Array.isArray(i.blobVersionedHashes),
      "invalid blobVersionedHashes: must be an array",
      "data",
      n
    );
  for (let s = 0; s < i.blobVersionedHashes.length; s++)
    x(
      De(i.blobVersionedHashes[s], 32),
      `invalid blobVersionedHash at index ${s}: must be length 32`,
      "data",
      n
    );
  return e.length === 11 || dy(i, e.slice(11)), i;
}
function AN(n, e, t) {
  let r = [
    pt(n.chainId, "chainId"),
    pt(n.nonce, "nonce"),
    pt(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    pt(n.maxFeePerGas || 0, "maxFeePerGas"),
    pt(n.gasLimit, "gasLimit"),
    n.to || Qr,
    pt(n.value, "value"),
    n.data,
    fy(n.accessList || []),
    pt(n.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    fN(n.blobVersionedHashes || [], "blobVersionedHashes"),
  ];
  return e &&
    (r.push(pt(e.yParity, "yParity")), r.push(Rt(e.r)), r.push(Rt(e.s)), t)
    ? Fe([
        "0x03",
        kr([
          r,
          t.map((i) => i.data),
          t.map((i) => i.commitment),
          t.map((i) => i.proof),
        ]),
      ])
    : Fe(["0x03", kr(r)]);
}
var yo = class n {
  #e;
  #t;
  #n;
  #r;
  #i;
  #o;
  #s;
  #a;
  #h;
  #u;
  #p;
  #g;
  #c;
  #l;
  #f;
  #d;
  get type() {
    return this.#e;
  }
  set type(e) {
    switch (e) {
      case null:
        this.#e = null;
        break;
      case 0:
      case "legacy":
        this.#e = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#e = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#e = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#e = 3;
        break;
      default:
        x(!1, "unsupported transaction type", "type", e);
    }
  }
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  get to() {
    let e = this.#t;
    return e == null && this.type === 3 ? Qr : e;
  }
  set to(e) {
    this.#t = e == null ? null : ke(e);
  }
  get nonce() {
    return this.#r;
  }
  set nonce(e) {
    this.#r = me(e, "value");
  }
  get gasLimit() {
    return this.#i;
  }
  set gasLimit(e) {
    this.#i = Y(e);
  }
  get gasPrice() {
    let e = this.#o;
    return e == null && (this.type === 0 || this.type === 1) ? Gt : e;
  }
  set gasPrice(e) {
    this.#o = e == null ? null : Y(e, "gasPrice");
  }
  get maxPriorityFeePerGas() {
    let e = this.#s;
    return e ?? (this.type === 2 || this.type === 3 ? Gt : null);
  }
  set maxPriorityFeePerGas(e) {
    this.#s = e == null ? null : Y(e, "maxPriorityFeePerGas");
  }
  get maxFeePerGas() {
    let e = this.#a;
    return e ?? (this.type === 2 || this.type === 3 ? Gt : null);
  }
  set maxFeePerGas(e) {
    this.#a = e == null ? null : Y(e, "maxFeePerGas");
  }
  get data() {
    return this.#n;
  }
  set data(e) {
    this.#n = V(e);
  }
  get value() {
    return this.#h;
  }
  set value(e) {
    this.#h = Y(e, "value");
  }
  get chainId() {
    return this.#u;
  }
  set chainId(e) {
    this.#u = Y(e);
  }
  get signature() {
    return this.#p || null;
  }
  set signature(e) {
    this.#p = e == null ? null : In.from(e);
  }
  get accessList() {
    let e = this.#g || null;
    return (
      e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null)
    );
  }
  set accessList(e) {
    this.#g = e == null ? null : Yn(e);
  }
  get maxFeePerBlobGas() {
    let e = this.#c;
    return e == null && this.type === 3 ? Gt : e;
  }
  set maxFeePerBlobGas(e) {
    this.#c = e == null ? null : Y(e, "maxFeePerBlobGas");
  }
  get blobVersionedHashes() {
    let e = this.#l;
    return e == null && this.type === 3 ? [] : e;
  }
  set blobVersionedHashes(e) {
    if (e != null) {
      x(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e),
        (e = e.slice());
      for (let t = 0; t < e.length; t++)
        x(De(e[t], 32), "invalid blobVersionedHash", `value[${t}]`, e[t]);
    }
    this.#l = e;
  }
  get blobs() {
    return this.#d == null ? null : this.#d.map((e) => Object.assign({}, e));
  }
  set blobs(e) {
    if (e == null) {
      this.#d = null;
      return;
    }
    let t = [],
      r = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (hs(s)) {
        R(
          this.#f,
          "adding a raw blob requires a KZG library",
          "UNSUPPORTED_OPERATION",
          { operation: "set blobs()" }
        );
        let o = fe(s);
        if (
          (x(o.length <= ly, "blob is too large", `blobs[${i}]`, s),
          o.length !== ly)
        ) {
          let u = new Uint8Array(ly);
          u.set(o), (o = u);
        }
        let a = this.#f.blobToKzgCommitment(o),
          c = V(this.#f.computeBlobKzgProof(o, a));
        t.push({ data: V(o), commitment: V(a), proof: c }), r.push(sv(1, a));
      } else {
        let o = V(s.commitment);
        t.push({ data: V(s.data), commitment: o, proof: V(s.proof) }),
          r.push(sv(1, o));
      }
    }
    (this.#d = t), (this.#l = r);
  }
  get kzg() {
    return this.#f;
  }
  set kzg(e) {
    this.#f = e;
  }
  constructor() {
    (this.#e = null),
      (this.#t = null),
      (this.#r = 0),
      (this.#i = Gt),
      (this.#o = null),
      (this.#s = null),
      (this.#a = null),
      (this.#n = "0x"),
      (this.#h = Gt),
      (this.#u = Gt),
      (this.#p = null),
      (this.#g = null),
      (this.#c = null),
      (this.#l = null),
      (this.#d = null),
      (this.#f = null);
  }
  get hash() {
    return this.signature == null ? null : et(this.#m(!0, !1));
  }
  get unsignedHash() {
    return et(this.unsignedSerialized);
  }
  get from() {
    return this.signature == null
      ? null
      : iv(this.unsignedHash, this.signature);
  }
  get fromPublicKey() {
    return this.signature == null
      ? null
      : ys.recoverPublicKey(this.unsignedHash, this.signature);
  }
  isSigned() {
    return this.signature != null;
  }
  #m(e, t) {
    R(
      !e || this.signature != null,
      "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
      "UNSUPPORTED_OPERATION",
      { operation: ".serialized" }
    );
    let r = e ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return pN(this, r);
      case 1:
        return wN(this, r);
      case 2:
        return mN(this, r);
      case 3:
        return AN(this, r, t ? this.blobs : null);
    }
    R(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
      operation: ".serialized",
    });
  }
  get serialized() {
    return this.#m(!0, !0);
  }
  get unsignedSerialized() {
    return this.#m(!1, !1);
  }
  inferType() {
    let e = this.inferTypes();
    return e.indexOf(2) >= 0 ? 2 : e.pop();
  }
  inferTypes() {
    let e = this.gasPrice != null,
      t = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null,
      r = this.accessList != null,
      i = this.#c != null || this.#l;
    this.maxFeePerGas != null &&
      this.maxPriorityFeePerGas != null &&
      R(
        this.maxFeePerGas >= this.maxPriorityFeePerGas,
        "priorityFee cannot be more than maxFee",
        "BAD_DATA",
        { value: this }
      ),
      R(
        !t || (this.type !== 0 && this.type !== 1),
        "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
        "BAD_DATA",
        { value: this }
      ),
      R(
        this.type !== 0 || !r,
        "legacy transaction cannot have accessList",
        "BAD_DATA",
        { value: this }
      );
    let s = [];
    return (
      this.type != null
        ? s.push(this.type)
        : t
        ? s.push(2)
        : e
        ? (s.push(1), r || s.push(0))
        : r
        ? (s.push(1), s.push(2))
        : ((i && this.to) || (s.push(0), s.push(1), s.push(2)), s.push(3)),
      s.sort(),
      s
    );
  }
  isLegacy() {
    return this.type === 0;
  }
  isBerlin() {
    return this.type === 1;
  }
  isLondon() {
    return this.type === 2;
  }
  isCancun() {
    return this.type === 3;
  }
  clone() {
    return n.from(this);
  }
  toJSON() {
    let e = (t) => (t == null ? null : t.toString());
    return {
      type: this.type,
      to: this.to,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList,
    };
  }
  static from(e) {
    if (e == null) return new n();
    if (typeof e == "string") {
      let r = fe(e);
      if (r[0] >= 127) return n.from(dN(r));
      switch (r[0]) {
        case 1:
          return n.from(yN(r));
        case 2:
          return n.from(gN(r));
        case 3:
          return n.from(bN(r));
      }
      R(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
        operation: "from",
      });
    }
    let t = new n();
    return (
      e.type != null && (t.type = e.type),
      e.to != null && (t.to = e.to),
      e.nonce != null && (t.nonce = e.nonce),
      e.gasLimit != null && (t.gasLimit = e.gasLimit),
      e.gasPrice != null && (t.gasPrice = e.gasPrice),
      e.maxPriorityFeePerGas != null &&
        (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas),
      e.maxFeePerGas != null && (t.maxFeePerGas = e.maxFeePerGas),
      e.maxFeePerBlobGas != null && (t.maxFeePerBlobGas = e.maxFeePerBlobGas),
      e.data != null && (t.data = e.data),
      e.value != null && (t.value = e.value),
      e.chainId != null && (t.chainId = e.chainId),
      e.signature != null && (t.signature = In.from(e.signature)),
      e.accessList != null && (t.accessList = e.accessList),
      e.blobVersionedHashes != null &&
        (t.blobVersionedHashes = e.blobVersionedHashes),
      e.kzg != null && (t.kzg = e.kzg),
      e.blobs != null && (t.blobs = e.blobs),
      e.hash != null &&
        (x(t.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e),
        x(t.hash === e.hash, "hash mismatch", "tx", e)),
      e.from != null &&
        (x(t.isSigned(), "unsigned transaction cannot define '.from'", "tx", e),
        x(
          t.from.toLowerCase() === (e.from || "").toLowerCase(),
          "from mismatch",
          "tx",
          e
        )),
      t
    );
  }
};
p();
var uv = new Uint8Array(32);
uv.fill(0);
var EN = BigInt(-1),
  lv = BigInt(0),
  hv = BigInt(1),
  xN = BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  );
function SN(n) {
  let e = fe(n),
    t = e.length % 32;
  return t ? Fe([e, uv.slice(t)]) : V(e);
}
var vN = vn(hv, 32),
  IN = vn(lv, 32),
  ov = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32",
  },
  py = ["name", "version", "chainId", "verifyingContract", "salt"];
function av(n) {
  return function (e) {
    return (
      x(
        typeof e == "string",
        `invalid domain value for ${JSON.stringify(n)}`,
        `domain.${n}`,
        e
      ),
      e
    );
  };
}
var CN = {
  name: av("name"),
  version: av("version"),
  chainId: function (n) {
    let e = Y(n, "domain.chainId");
    return (
      x(e >= 0, "invalid chain ID", "domain.chainId", n),
      Number.isSafeInteger(e) ? Number(e) : Ir(e)
    );
  },
  verifyingContract: function (n) {
    try {
      return ke(n).toLowerCase();
    } catch {}
    x(
      !1,
      'invalid domain value "verifyingContract"',
      "domain.verifyingContract",
      n
    );
  },
  salt: function (n) {
    let e = fe(n, "domain.salt");
    return (
      x(e.length === 32, 'invalid domain value "salt"', "domain.salt", n), V(e)
    );
  },
};
function gy(n) {
  {
    let e = n.match(/^(u?)int(\d+)$/);
    if (e) {
      let t = e[1] === "",
        r = parseInt(e[2]);
      x(
        r % 8 === 0 && r !== 0 && r <= 256 && e[2] === String(r),
        "invalid numeric width",
        "type",
        n
      );
      let i = hr(xN, t ? r - 1 : r),
        s = t ? (i + hv) * EN : lv;
      return function (o) {
        let a = Y(o, "value");
        return (
          x(a >= s && a <= i, `value out-of-bounds for ${n}`, "value", a),
          vn(t ? Ha(a, 256) : a, 32)
        );
      };
    }
  }
  {
    let e = n.match(/^bytes(\d+)$/);
    if (e) {
      let t = parseInt(e[1]);
      return (
        x(
          t !== 0 && t <= 32 && e[1] === String(t),
          "invalid bytes width",
          "type",
          n
        ),
        function (r) {
          let i = fe(r);
          return (
            x(i.length === t, `invalid length for ${n}`, "value", r), SN(r)
          );
        }
      );
    }
  }
  switch (n) {
    case "address":
      return function (e) {
        return Ln(ke(e), 32);
      };
    case "bool":
      return function (e) {
        return e ? vN : IN;
      };
    case "bytes":
      return function (e) {
        return et(e);
      };
    case "string":
      return function (e) {
        return Rr(e);
      };
  }
  return null;
}
function cv(n, e) {
  return `${n}(${e.map(({ name: t, type: r }) => r + " " + t).join(",")})`;
}
function Zf(n) {
  let e = n.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return e
    ? {
        base: e[1],
        index: e[2] + e[4],
        array: {
          base: e[1],
          prefix: e[1] + e[2],
          count: e[5] ? parseInt(e[5]) : -1,
        },
      }
    : { base: n };
}
var tc = class n {
  primaryType;
  #e;
  get types() {
    return JSON.parse(this.#e);
  }
  #t;
  #n;
  constructor(e) {
    (this.#t = new Map()), (this.#n = new Map());
    let t = new Map(),
      r = new Map(),
      i = new Map(),
      s = {};
    Object.keys(e).forEach((c) => {
      (s[c] = e[c].map(({ name: u, type: l }) => {
        let { base: h, index: f } = Zf(l);
        return (
          h === "int" && !e.int && (h = "int256"),
          h === "uint" && !e.uint && (h = "uint256"),
          { name: u, type: h + (f || "") }
        );
      })),
        t.set(c, new Set()),
        r.set(c, []),
        i.set(c, new Set());
    }),
      (this.#e = JSON.stringify(s));
    for (let c in s) {
      let u = new Set();
      for (let l of s[c]) {
        x(
          !u.has(l.name),
          `duplicate variable name ${JSON.stringify(
            l.name
          )} in ${JSON.stringify(c)}`,
          "types",
          e
        ),
          u.add(l.name);
        let h = Zf(l.type).base;
        x(
          h !== c,
          `circular type reference to ${JSON.stringify(h)}`,
          "types",
          e
        ),
          !gy(h) &&
            (x(r.has(h), `unknown type ${JSON.stringify(h)}`, "types", e),
            r.get(h).push(c),
            t.get(c).add(h));
      }
    }
    let o = Array.from(r.keys()).filter((c) => r.get(c).length === 0);
    x(o.length !== 0, "missing primary type", "types", e),
      x(
        o.length === 1,
        `ambiguous primary types or unused types: ${o
          .map((c) => JSON.stringify(c))
          .join(", ")}`,
        "types",
        e
      ),
      ee(this, { primaryType: o[0] });
    function a(c, u) {
      x(
        !u.has(c),
        `circular type reference to ${JSON.stringify(c)}`,
        "types",
        e
      ),
        u.add(c);
      for (let l of t.get(c))
        if (r.has(l)) {
          a(l, u);
          for (let h of u) i.get(h).add(l);
        }
      u.delete(c);
    }
    a(this.primaryType, new Set());
    for (let [c, u] of i) {
      let l = Array.from(u);
      l.sort(),
        this.#t.set(c, cv(c, s[c]) + l.map((h) => cv(h, s[h])).join(""));
    }
  }
  getEncoder(e) {
    let t = this.#n.get(e);
    return t || ((t = this.#r(e)), this.#n.set(e, t)), t;
  }
  #r(e) {
    {
      let i = gy(e);
      if (i) return i;
    }
    let t = Zf(e).array;
    if (t) {
      let i = t.prefix,
        s = this.getEncoder(i);
      return (o) => {
        x(
          t.count === -1 || t.count === o.length,
          `array length mismatch; expected length ${t.count}`,
          "value",
          o
        );
        let a = o.map(s);
        return this.#t.has(i) && (a = a.map(et)), et(Fe(a));
      };
    }
    let r = this.types[e];
    if (r) {
      let i = Rr(this.#t.get(e));
      return (s) => {
        let o = r.map(({ name: a, type: c }) => {
          let u = this.getEncoder(c)(s[a]);
          return this.#t.has(c) ? et(u) : u;
        });
        return o.unshift(i), Fe(o);
      };
    }
    x(!1, `unknown type: ${e}`, "type", e);
  }
  encodeType(e) {
    let t = this.#t.get(e);
    return x(t, `unknown type: ${JSON.stringify(e)}`, "name", e), t;
  }
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  hashStruct(e, t) {
    return et(this.encodeData(e, t));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, t, r) {
    if (gy(e)) return r(e, t);
    let i = Zf(e).array;
    if (i)
      return (
        x(
          i.count === -1 || i.count === t.length,
          `array length mismatch; expected length ${i.count}`,
          "value",
          t
        ),
        t.map((o) => this._visit(i.prefix, o, r))
      );
    let s = this.types[e];
    if (s)
      return s.reduce(
        (o, { name: a, type: c }) => ((o[a] = this._visit(c, t[a], r)), o),
        {}
      );
    x(!1, `unknown type: ${e}`, "type", e);
  }
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  static from(e) {
    return new n(e);
  }
  static getPrimaryType(e) {
    return n.from(e).primaryType;
  }
  static hashStruct(e, t, r) {
    return n.from(t).hashStruct(e, r);
  }
  static hashDomain(e) {
    let t = [];
    for (let r in e) {
      if (e[r] == null) continue;
      let i = ov[r];
      x(i, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e),
        t.push({ name: r, type: i });
    }
    return (
      t.sort((r, i) => py.indexOf(r.name) - py.indexOf(i.name)),
      n.hashStruct("EIP712Domain", { EIP712Domain: t }, e)
    );
  }
  static encode(e, t, r) {
    return Fe(["0x1901", n.hashDomain(e), n.from(t).hash(r)]);
  }
  static hash(e, t, r) {
    return et(n.encode(e, t, r));
  }
  static resolveNames(e, t, r, i) {
    return d(this, null, function* () {
      e = Object.assign({}, e);
      for (let a in e) e[a] == null && delete e[a];
      let s = {};
      e.verifyingContract &&
        !De(e.verifyingContract, 20) &&
        (s[e.verifyingContract] = "0x");
      let o = n.from(t);
      o.visit(r, (a, c) => (a === "address" && !De(c, 20) && (s[c] = "0x"), c));
      for (let a in s) s[a] = yield i(a);
      return (
        e.verifyingContract &&
          s[e.verifyingContract] &&
          (e.verifyingContract = s[e.verifyingContract]),
        (r = o.visit(r, (a, c) => (a === "address" && s[c] ? s[c] : c))),
        { domain: e, value: r }
      );
    });
  }
  static getPayload(e, t, r) {
    n.hashDomain(e);
    let i = {},
      s = [];
    py.forEach((c) => {
      let u = e[c];
      u != null && ((i[c] = CN[c](u)), s.push({ name: c, type: ov[c] }));
    });
    let o = n.from(t);
    t = o.types;
    let a = Object.assign({}, t);
    return (
      x(
        a.EIP712Domain == null,
        "types must not contain EIP712Domain type",
        "types.EIP712Domain",
        t
      ),
      (a.EIP712Domain = s),
      o.encode(r),
      {
        types: a,
        domain: i,
        primaryType: o.primaryType,
        message: o.visit(r, (c, u) => {
          if (c.match(/^bytes(\d*)/)) return V(fe(u));
          if (c.match(/^u?int/)) return Y(u).toString();
          switch (c) {
            case "address":
              return u.toLowerCase();
            case "bool":
              return !!u;
            case "string":
              return x(typeof u == "string", "invalid string", "value", u), u;
          }
          x(!1, "unsupported type", "type", c);
        }),
      }
    );
  }
};
function Cn(n) {
  let e = new Set();
  return n.forEach((t) => e.add(t)), Object.freeze(e);
}
var kN = "external public payable override",
  TN = Cn(kN.split(" ")),
  Ev = "constant external internal payable private public pure view override",
  RN = Cn(Ev.split(" ")),
  xv = "constructor error event fallback function receive struct",
  Sv = Cn(xv.split(" ")),
  vv = "calldata memory storage payable indexed",
  BN = Cn(vv.split(" ")),
  DN = "tuple returns",
  _N = [xv, vv, DN, Ev].join(" "),
  PN = Cn(_N.split(" ")),
  LN = {
    "(": "OPEN_PAREN",
    ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET",
    "]": "CLOSE_BRACKET",
    ",": "COMMA",
    "@": "AT",
  },
  ON = new RegExp("^(\\s*)"),
  NN = new RegExp("^([0-9]+)"),
  FN = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
  Iv = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
  Cv = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$"),
  Br = class n {
    #e;
    #t;
    get offset() {
      return this.#e;
    }
    get length() {
      return this.#t.length - this.#e;
    }
    constructor(e) {
      (this.#e = 0), (this.#t = e.slice());
    }
    clone() {
      return new n(this.#t);
    }
    reset() {
      this.#e = 0;
    }
    #n(e = 0, t = 0) {
      return new n(
        this.#t
          .slice(e, t)
          .map((r) =>
            Object.freeze(
              Object.assign({}, r, {
                match: r.match - e,
                linkBack: r.linkBack - e,
                linkNext: r.linkNext - e,
              })
            )
          )
      );
    }
    popKeyword(e) {
      let t = this.peek();
      if (t.type !== "KEYWORD" || !e.has(t.text))
        throw new Error(`expected keyword ${t.text}`);
      return this.pop().text;
    }
    popType(e) {
      if (this.peek().type !== e) {
        let t = this.peek();
        throw new Error(
          `expected ${e}; got ${t.type} ${JSON.stringify(t.text)}`
        );
      }
      return this.pop().text;
    }
    popParen() {
      let e = this.peek();
      if (e.type !== "OPEN_PAREN") throw new Error("bad start");
      let t = this.#n(this.#e + 1, e.match + 1);
      return (this.#e = e.match + 1), t;
    }
    popParams() {
      let e = this.peek();
      if (e.type !== "OPEN_PAREN") throw new Error("bad start");
      let t = [];
      for (; this.#e < e.match - 1; ) {
        let r = this.peek().linkNext;
        t.push(this.#n(this.#e + 1, r)), (this.#e = r);
      }
      return (this.#e = e.match + 1), t;
    }
    peek() {
      if (this.#e >= this.#t.length) throw new Error("out-of-bounds");
      return this.#t[this.#e];
    }
    peekKeyword(e) {
      let t = this.peekType("KEYWORD");
      return t != null && e.has(t) ? t : null;
    }
    peekType(e) {
      if (this.length === 0) return null;
      let t = this.peek();
      return t.type === e ? t.text : null;
    }
    pop() {
      let e = this.peek();
      return this.#e++, e;
    }
    toString() {
      let e = [];
      for (let t = this.#e; t < this.#t.length; t++) {
        let r = this.#t[t];
        e.push(`${r.type}:${r.text}`);
      }
      return `<TokenString ${e.join(" ")}>`;
    }
  };
function ws(n) {
  let e = [],
    t = (o) => {
      let a = s < n.length ? JSON.stringify(n[s]) : "$EOI";
      throw new Error(`invalid token ${a} at ${s}: ${o}`);
    },
    r = [],
    i = [],
    s = 0;
  for (; s < n.length; ) {
    let o = n.substring(s),
      a = o.match(ON);
    a && ((s += a[1].length), (o = n.substring(s)));
    let c = {
      depth: r.length,
      linkBack: -1,
      linkNext: -1,
      match: -1,
      type: "",
      text: "",
      offset: s,
      value: -1,
    };
    e.push(c);
    let u = LN[o[0]] || "";
    if (u) {
      if (((c.type = u), (c.text = o[0]), s++, u === "OPEN_PAREN"))
        r.push(e.length - 1), i.push(e.length - 1);
      else if (u == "CLOSE_PAREN")
        r.length === 0 && t("no matching open bracket"),
          (c.match = r.pop()),
          (e[c.match].match = e.length - 1),
          c.depth--,
          (c.linkBack = i.pop()),
          (e[c.linkBack].linkNext = e.length - 1);
      else if (u === "COMMA")
        (c.linkBack = i.pop()),
          (e[c.linkBack].linkNext = e.length - 1),
          i.push(e.length - 1);
      else if (u === "OPEN_BRACKET") c.type = "BRACKET";
      else if (u === "CLOSE_BRACKET") {
        let l = e.pop().text;
        if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
          let h = e.pop().text;
          (l = h + l), (e[e.length - 1].value = me(h));
        }
        if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        e[e.length - 1].text += l;
      }
      continue;
    }
    if (((a = o.match(FN)), a)) {
      if (((c.text = a[1]), (s += c.text.length), PN.has(c.text))) {
        c.type = "KEYWORD";
        continue;
      }
      if (c.text.match(Cv)) {
        c.type = "TYPE";
        continue;
      }
      c.type = "ID";
      continue;
    }
    if (((a = o.match(NN)), a)) {
      (c.text = a[1]), (c.type = "NUMBER"), (s += c.text.length);
      continue;
    }
    throw new Error(
      `unexpected token ${JSON.stringify(o[0])} at position ${s}`
    );
  }
  return new Br(e.map((o) => Object.freeze(o)));
}
function fv(n, e) {
  let t = [];
  for (let r in e.keys()) n.has(r) && t.push(r);
  if (t.length > 1) throw new Error(`conflicting types: ${t.join(", ")}`);
}
function ed(n, e) {
  if (e.peekKeyword(Sv)) {
    let t = e.pop().text;
    if (t !== n) throw new Error(`expected ${n}, got ${t}`);
  }
  return e.popType("ID");
}
function Bi(n, e) {
  let t = new Set();
  for (;;) {
    let r = n.peekType("KEYWORD");
    if (r == null || (e && !e.has(r))) break;
    if ((n.pop(), t.has(r)))
      throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
    t.add(r);
  }
  return Object.freeze(t);
}
function kv(n) {
  let e = Bi(n, RN);
  return (
    fv(e, Cn("constant payable nonpayable".split(" "))),
    fv(e, Cn("pure view payable nonpayable".split(" "))),
    e.has("view")
      ? "view"
      : e.has("pure")
      ? "pure"
      : e.has("payable")
      ? "payable"
      : e.has("nonpayable")
      ? "nonpayable"
      : e.has("constant")
      ? "view"
      : "nonpayable"
  );
}
function Ri(n, e) {
  return n.popParams().map((t) => Mt.from(t, e));
}
function Tv(n) {
  if (n.peekType("AT")) {
    if ((n.pop(), n.peekType("NUMBER"))) return Y(n.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function Eo(n) {
  if (n.length)
    throw new Error(`unexpected tokens at offset ${n.offset}: ${n.toString()}`);
}
var MN = new RegExp(/^(.*)\[([0-9]*)\]$/);
function dv(n) {
  let e = n.match(Cv);
  if ((x(e, "invalid type", "type", n), n === "uint")) return "uint256";
  if (n === "int") return "int256";
  if (e[2]) {
    let t = parseInt(e[2]);
    x(t !== 0 && t <= 32, "invalid bytes length", "type", n);
  } else if (e[3]) {
    let t = parseInt(e[3]);
    x(t !== 0 && t <= 256 && t % 8 === 0, "invalid numeric width", "type", n);
  }
  return n;
}
var xt = {},
  On = Symbol.for("_ethers_internal"),
  pv = "_ParamTypeInternal",
  gv = "_ErrorInternal",
  mv = "_EventInternal",
  yv = "_ConstructorInternal",
  wv = "_FallbackInternal",
  bv = "_FunctionInternal",
  Av = "_StructInternal",
  Mt = class n {
    name;
    type;
    baseType;
    indexed;
    components;
    arrayLength;
    arrayChildren;
    constructor(e, t, r, i, s, o, a, c) {
      if (
        (xr(e, xt, "ParamType"),
        Object.defineProperty(this, On, { value: pv }),
        o && (o = Object.freeze(o.slice())),
        i === "array")
      ) {
        if (a == null || c == null) throw new Error("");
      } else if (a != null || c != null) throw new Error("");
      if (i === "tuple") {
        if (o == null) throw new Error("");
      } else if (o != null) throw new Error("");
      ee(this, {
        name: t,
        type: r,
        baseType: i,
        indexed: s,
        components: o,
        arrayLength: a,
        arrayChildren: c,
      });
    }
    format(e) {
      if ((e == null && (e = "sighash"), e === "json")) {
        let r = this.name || "";
        if (this.isArray()) {
          let s = JSON.parse(this.arrayChildren.format("json"));
          return (
            (s.name = r),
            (s.type += `[${
              this.arrayLength < 0 ? "" : String(this.arrayLength)
            }]`),
            JSON.stringify(s)
          );
        }
        let i = {
          type: this.baseType === "tuple" ? "tuple" : this.type,
          name: r,
        };
        return (
          typeof this.indexed == "boolean" && (i.indexed = this.indexed),
          this.isTuple() &&
            (i.components = this.components.map((s) =>
              JSON.parse(s.format(e))
            )),
          JSON.stringify(i)
        );
      }
      let t = "";
      return (
        this.isArray()
          ? ((t += this.arrayChildren.format(e)),
            (t += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`))
          : this.isTuple()
          ? (t +=
              "(" +
              this.components
                .map((r) => r.format(e))
                .join(e === "full" ? ", " : ",") +
              ")")
          : (t += this.type),
        e !== "sighash" &&
          (this.indexed === !0 && (t += " indexed"),
          e === "full" && this.name && (t += " " + this.name)),
        t
      );
    }
    isArray() {
      return this.baseType === "array";
    }
    isTuple() {
      return this.baseType === "tuple";
    }
    isIndexable() {
      return this.indexed != null;
    }
    walk(e, t) {
      if (this.isArray()) {
        if (!Array.isArray(e)) throw new Error("invalid array value");
        if (this.arrayLength !== -1 && e.length !== this.arrayLength)
          throw new Error("array is wrong length");
        let r = this;
        return e.map((i) => r.arrayChildren.walk(i, t));
      }
      if (this.isTuple()) {
        if (!Array.isArray(e)) throw new Error("invalid tuple value");
        if (e.length !== this.components.length)
          throw new Error("array is wrong length");
        let r = this;
        return e.map((i, s) => r.components[s].walk(i, t));
      }
      return t(this.type, e);
    }
    #e(e, t, r, i) {
      if (this.isArray()) {
        if (!Array.isArray(t)) throw new Error("invalid array value");
        if (this.arrayLength !== -1 && t.length !== this.arrayLength)
          throw new Error("array is wrong length");
        let o = this.arrayChildren,
          a = t.slice();
        a.forEach((c, u) => {
          o.#e(e, c, r, (l) => {
            a[u] = l;
          });
        }),
          i(a);
        return;
      }
      if (this.isTuple()) {
        let o = this.components,
          a;
        if (Array.isArray(t)) a = t.slice();
        else {
          if (t == null || typeof t != "object")
            throw new Error("invalid tuple value");
          a = o.map((c) => {
            if (!c.name)
              throw new Error(
                "cannot use object value with unnamed components"
              );
            if (!(c.name in t))
              throw new Error(`missing value for component ${c.name}`);
            return t[c.name];
          });
        }
        if (a.length !== this.components.length)
          throw new Error("array is wrong length");
        a.forEach((c, u) => {
          o[u].#e(e, c, r, (l) => {
            a[u] = l;
          });
        }),
          i(a);
        return;
      }
      let s = r(this.type, t);
      s.then
        ? e.push(
            (function () {
              return d(this, null, function* () {
                i(yield s);
              });
            })()
          )
        : i(s);
    }
    walkAsync(e, t) {
      return d(this, null, function* () {
        let r = [],
          i = [e];
        return (
          this.#e(r, e, t, (s) => {
            i[0] = s;
          }),
          r.length && (yield Promise.all(r)),
          i[0]
        );
      });
    }
    static from(e, t) {
      if (n.isParamType(e)) return e;
      if (typeof e == "string")
        try {
          return n.from(ws(e), t);
        } catch {
          x(!1, "invalid param type", "obj", e);
        }
      else if (e instanceof Br) {
        let a = "",
          c = "",
          u = null;
        Bi(e, Cn(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN")
          ? ((c = "tuple"),
            (u = e.popParams().map((w) => n.from(w))),
            (a = `tuple(${u.map((w) => w.format()).join(",")})`))
          : ((a = dv(e.popType("TYPE"))), (c = a));
        let l = null,
          h = null;
        for (; e.length && e.peekType("BRACKET"); ) {
          let w = e.pop();
          (l = new n(xt, "", a, c, null, u, h, l)),
            (h = w.value),
            (a += w.text),
            (c = "array"),
            (u = null);
        }
        let f = null;
        if (Bi(e, BN).has("indexed")) {
          if (!t) throw new Error("");
          f = !0;
        }
        let y = e.peekType("ID") ? e.pop().text : "";
        if (e.length) throw new Error("leftover tokens");
        return new n(xt, y, a, c, f, u, h, l);
      }
      let r = e.name;
      x(
        !r || (typeof r == "string" && r.match(Iv)),
        "invalid name",
        "obj.name",
        r
      );
      let i = e.indexed;
      i != null &&
        (x(t, "parameter cannot be indexed", "obj.indexed", e.indexed),
        (i = !!i));
      let s = e.type,
        o = s.match(MN);
      if (o) {
        let a = parseInt(o[2] || "-1"),
          c = n.from({ type: o[1], components: e.components });
        return new n(xt, r || "", s, "array", i, null, a, c);
      }
      if (s === "tuple" || s.startsWith("tuple(") || s.startsWith("(")) {
        let a =
          e.components != null ? e.components.map((u) => n.from(u)) : null;
        return new n(xt, r || "", s, "tuple", i, a, null, null);
      }
      return (s = dv(e.type)), new n(xt, r || "", s, s, i, null, null, null);
    }
    static isParamType(e) {
      return e && e[On] === pv;
    }
  },
  xo = class n {
    type;
    inputs;
    constructor(e, t, r) {
      xr(e, xt, "Fragment"),
        (r = Object.freeze(r.slice())),
        ee(this, { type: t, inputs: r });
    }
    static from(e) {
      if (typeof e == "string") {
        try {
          n.from(JSON.parse(e));
        } catch {}
        return n.from(ws(e));
      }
      if (e instanceof Br)
        switch (e.peekKeyword(Sv)) {
          case "constructor":
            return bo.from(e);
          case "error":
            return fr.from(e);
          case "event":
            return wo.from(e);
          case "fallback":
          case "receive":
            return Xf.from(e);
          case "function":
            return Ao.from(e);
          case "struct":
            return wl.from(e);
        }
      else if (typeof e == "object") {
        switch (e.type) {
          case "constructor":
            return bo.from(e);
          case "error":
            return fr.from(e);
          case "event":
            return wo.from(e);
          case "fallback":
          case "receive":
            return Xf.from(e);
          case "function":
            return Ao.from(e);
          case "struct":
            return wl.from(e);
        }
        R(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
          operation: "Fragment.from",
        });
      }
      x(!1, "unsupported frgament object", "obj", e);
    }
    static isConstructor(e) {
      return bo.isFragment(e);
    }
    static isError(e) {
      return fr.isFragment(e);
    }
    static isEvent(e) {
      return wo.isFragment(e);
    }
    static isFunction(e) {
      return Ao.isFragment(e);
    }
    static isStruct(e) {
      return wl.isFragment(e);
    }
  },
  nc = class extends xo {
    name;
    constructor(e, t, r, i) {
      super(e, t, i),
        x(typeof r == "string" && r.match(Iv), "invalid identifier", "name", r),
        (i = Object.freeze(i.slice())),
        ee(this, { name: r });
    }
  };
function bl(n, e) {
  return "(" + e.map((t) => t.format(n)).join(n === "full" ? ", " : ",") + ")";
}
var fr = class n extends nc {
    constructor(e, t, r) {
      super(e, "error", t, r), Object.defineProperty(this, On, { value: gv });
    }
    get selector() {
      return Rr(this.format("sighash")).substring(0, 10);
    }
    format(e) {
      if ((e == null && (e = "sighash"), e === "json"))
        return JSON.stringify({
          type: "error",
          name: this.name,
          inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        });
      let t = [];
      return (
        e !== "sighash" && t.push("error"),
        t.push(this.name + bl(e, this.inputs)),
        t.join(" ")
      );
    }
    static from(e) {
      if (n.isFragment(e)) return e;
      if (typeof e == "string") return n.from(ws(e));
      if (e instanceof Br) {
        let t = ed("error", e),
          r = Ri(e);
        return Eo(e), new n(xt, t, r);
      }
      return new n(xt, e.name, e.inputs ? e.inputs.map(Mt.from) : []);
    }
    static isFragment(e) {
      return e && e[On] === gv;
    }
  },
  wo = class n extends nc {
    anonymous;
    constructor(e, t, r, i) {
      super(e, "event", t, r),
        Object.defineProperty(this, On, { value: mv }),
        ee(this, { anonymous: i });
    }
    get topicHash() {
      return Rr(this.format("sighash"));
    }
    format(e) {
      if ((e == null && (e = "sighash"), e === "json"))
        return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        });
      let t = [];
      return (
        e !== "sighash" && t.push("event"),
        t.push(this.name + bl(e, this.inputs)),
        e !== "sighash" && this.anonymous && t.push("anonymous"),
        t.join(" ")
      );
    }
    static getTopicHash(e, t) {
      return (
        (t = (t || []).map((i) => Mt.from(i))), new n(xt, e, t, !1).topicHash
      );
    }
    static from(e) {
      if (n.isFragment(e)) return e;
      if (typeof e == "string")
        try {
          return n.from(ws(e));
        } catch {
          x(!1, "invalid event fragment", "obj", e);
        }
      else if (e instanceof Br) {
        let t = ed("event", e),
          r = Ri(e, !0),
          i = !!Bi(e, Cn(["anonymous"])).has("anonymous");
        return Eo(e), new n(xt, t, r, i);
      }
      return new n(
        xt,
        e.name,
        e.inputs ? e.inputs.map((t) => Mt.from(t, !0)) : [],
        !!e.anonymous
      );
    }
    static isFragment(e) {
      return e && e[On] === mv;
    }
  },
  bo = class n extends xo {
    payable;
    gas;
    constructor(e, t, r, i, s) {
      super(e, t, r),
        Object.defineProperty(this, On, { value: yv }),
        ee(this, { payable: i, gas: s });
    }
    format(e) {
      if (
        (R(
          e != null && e !== "sighash",
          "cannot format a constructor for sighash",
          "UNSUPPORTED_OPERATION",
          { operation: "format(sighash)" }
        ),
        e === "json")
      )
        return JSON.stringify({
          type: "constructor",
          stateMutability: this.payable ? "payable" : "undefined",
          payable: this.payable,
          gas: this.gas != null ? this.gas : void 0,
          inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        });
      let t = [`constructor${bl(e, this.inputs)}`];
      return (
        this.payable && t.push("payable"),
        this.gas != null && t.push(`@${this.gas.toString()}`),
        t.join(" ")
      );
    }
    static from(e) {
      if (n.isFragment(e)) return e;
      if (typeof e == "string")
        try {
          return n.from(ws(e));
        } catch {
          x(!1, "invalid constuctor fragment", "obj", e);
        }
      else if (e instanceof Br) {
        Bi(e, Cn(["constructor"]));
        let t = Ri(e),
          r = !!Bi(e, TN).has("payable"),
          i = Tv(e);
        return Eo(e), new n(xt, "constructor", t, r, i);
      }
      return new n(
        xt,
        "constructor",
        e.inputs ? e.inputs.map(Mt.from) : [],
        !!e.payable,
        e.gas != null ? e.gas : null
      );
    }
    static isFragment(e) {
      return e && e[On] === yv;
    }
  },
  Xf = class n extends xo {
    payable;
    constructor(e, t, r) {
      super(e, "fallback", t),
        Object.defineProperty(this, On, { value: wv }),
        ee(this, { payable: r });
    }
    format(e) {
      let t = this.inputs.length === 0 ? "receive" : "fallback";
      if (e === "json") {
        let r = this.payable ? "payable" : "nonpayable";
        return JSON.stringify({ type: t, stateMutability: r });
      }
      return `${t}()${this.payable ? " payable" : ""}`;
    }
    static from(e) {
      if (n.isFragment(e)) return e;
      if (typeof e == "string")
        try {
          return n.from(ws(e));
        } catch {
          x(!1, "invalid fallback fragment", "obj", e);
        }
      else if (e instanceof Br) {
        let t = e.toString(),
          r = e.peekKeyword(Cn(["fallback", "receive"]));
        if (
          (x(r, "type must be fallback or receive", "obj", t),
          e.popKeyword(Cn(["fallback", "receive"])) === "receive")
        ) {
          let a = Ri(e);
          return (
            x(a.length === 0, "receive cannot have arguments", "obj.inputs", a),
            Bi(e, Cn(["payable"])),
            Eo(e),
            new n(xt, [], !0)
          );
        }
        let s = Ri(e);
        s.length
          ? x(
              s.length === 1 && s[0].type === "bytes",
              "invalid fallback inputs",
              "obj.inputs",
              s.map((a) => a.format("minimal")).join(", ")
            )
          : (s = [Mt.from("bytes")]);
        let o = kv(e);
        if (
          (x(
            o === "nonpayable" || o === "payable",
            "fallback cannot be constants",
            "obj.stateMutability",
            o
          ),
          Bi(e, Cn(["returns"])).has("returns"))
        ) {
          let a = Ri(e);
          x(
            a.length === 1 && a[0].type === "bytes",
            "invalid fallback outputs",
            "obj.outputs",
            a.map((c) => c.format("minimal")).join(", ")
          );
        }
        return Eo(e), new n(xt, s, o === "payable");
      }
      if (e.type === "receive") return new n(xt, [], !0);
      if (e.type === "fallback") {
        let t = [Mt.from("bytes")],
          r = e.stateMutability === "payable";
        return new n(xt, t, r);
      }
      x(!1, "invalid fallback description", "obj", e);
    }
    static isFragment(e) {
      return e && e[On] === wv;
    }
  },
  Ao = class n extends nc {
    constant;
    outputs;
    stateMutability;
    payable;
    gas;
    constructor(e, t, r, i, s, o) {
      super(e, "function", t, i),
        Object.defineProperty(this, On, { value: bv }),
        (s = Object.freeze(s.slice())),
        ee(this, {
          constant: r === "view" || r === "pure",
          gas: o,
          outputs: s,
          payable: r === "payable",
          stateMutability: r,
        });
    }
    get selector() {
      return Rr(this.format("sighash")).substring(0, 10);
    }
    format(e) {
      if ((e == null && (e = "sighash"), e === "json"))
        return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability:
            this.stateMutability !== "nonpayable"
              ? this.stateMutability
              : void 0,
          payable: this.payable,
          gas: this.gas != null ? this.gas : void 0,
          inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
          outputs: this.outputs.map((r) => JSON.parse(r.format(e))),
        });
      let t = [];
      return (
        e !== "sighash" && t.push("function"),
        t.push(this.name + bl(e, this.inputs)),
        e !== "sighash" &&
          (this.stateMutability !== "nonpayable" &&
            t.push(this.stateMutability),
          this.outputs &&
            this.outputs.length &&
            (t.push("returns"), t.push(bl(e, this.outputs))),
          this.gas != null && t.push(`@${this.gas.toString()}`)),
        t.join(" ")
      );
    }
    static getSelector(e, t) {
      return (
        (t = (t || []).map((i) => Mt.from(i))),
        new n(xt, e, "view", t, [], null).selector
      );
    }
    static from(e) {
      if (n.isFragment(e)) return e;
      if (typeof e == "string")
        try {
          return n.from(ws(e));
        } catch {
          x(!1, "invalid function fragment", "obj", e);
        }
      else if (e instanceof Br) {
        let r = ed("function", e),
          i = Ri(e),
          s = kv(e),
          o = [];
        Bi(e, Cn(["returns"])).has("returns") && (o = Ri(e));
        let a = Tv(e);
        return Eo(e), new n(xt, r, s, i, o, a);
      }
      let t = e.stateMutability;
      return (
        t == null &&
          ((t = "payable"),
          typeof e.constant == "boolean"
            ? ((t = "view"),
              e.constant ||
                ((t = "payable"),
                typeof e.payable == "boolean" &&
                  !e.payable &&
                  (t = "nonpayable")))
            : typeof e.payable == "boolean" &&
              !e.payable &&
              (t = "nonpayable")),
        new n(
          xt,
          e.name,
          t,
          e.inputs ? e.inputs.map(Mt.from) : [],
          e.outputs ? e.outputs.map(Mt.from) : [],
          e.gas != null ? e.gas : null
        )
      );
    }
    static isFragment(e) {
      return e && e[On] === bv;
    }
  },
  wl = class n extends nc {
    constructor(e, t, r) {
      super(e, "struct", t, r), Object.defineProperty(this, On, { value: Av });
    }
    format() {
      throw new Error("@TODO");
    }
    static from(e) {
      if (typeof e == "string")
        try {
          return n.from(ws(e));
        } catch {
          x(!1, "invalid struct fragment", "obj", e);
        }
      else if (e instanceof Br) {
        let t = ed("struct", e),
          r = Ri(e);
        return Eo(e), new n(xt, t, r);
      }
      return new n(xt, e.name, e.inputs ? e.inputs.map(Mt.from) : []);
    }
    static isFragment(e) {
      return e && e[On] === Av;
    }
  };
var Dr = new Map();
Dr.set(0, "GENERIC_PANIC");
Dr.set(1, "ASSERT_FALSE");
Dr.set(17, "OVERFLOW");
Dr.set(18, "DIVIDE_BY_ZERO");
Dr.set(33, "ENUM_RANGE_ERROR");
Dr.set(34, "BAD_STORAGE_DATA");
Dr.set(49, "STACK_UNDERFLOW");
Dr.set(50, "ARRAY_RANGE_ERROR");
Dr.set(65, "OUT_OF_MEMORY");
Dr.set(81, "UNINITIALIZED_FUNCTION_CALL");
var UN = new RegExp(/^bytes([0-9]*)$/),
  zN = new RegExp(/^(u?int)([0-9]*)$/),
  my = null,
  Rv = 1024;
function jN(n, e, t, r) {
  let i = "missing revert data",
    s = null,
    o = null,
    a = null;
  if (t) {
    i = "execution reverted";
    let u = fe(t);
    if (((t = V(t)), u.length === 0))
      (i += " (no data present; likely require(false) occurred"),
        (s = "require(false)");
    else if (u.length % 32 !== 4)
      i += " (could not decode reason; invalid data length)";
    else if (V(u.slice(0, 4)) === "0x08c379a0")
      try {
        (s = r.decode(["string"], u.slice(4))[0]),
          (a = { signature: "Error(string)", name: "Error", args: [s] }),
          (i += `: ${JSON.stringify(s)}`);
      } catch {
        i += " (could not decode reason; invalid string data)";
      }
    else if (V(u.slice(0, 4)) === "0x4e487b71")
      try {
        let l = Number(r.decode(["uint256"], u.slice(4))[0]);
        (a = { signature: "Panic(uint256)", name: "Panic", args: [l] }),
          (s = `Panic due to ${Dr.get(l) || "UNKNOWN"}(${l})`),
          (i += `: ${s}`);
      } catch {
        i += " (could not decode panic code)";
      }
    else i += " (unknown custom error)";
  }
  let c = { to: e.to ? ke(e.to) : null, data: e.data || "0x" };
  return (
    e.from && (c.from = ke(e.from)),
    Ye(i, "CALL_EXCEPTION", {
      action: n,
      data: t,
      reason: s,
      transaction: c,
      invocation: o,
      revert: a,
    })
  );
}
var bs = class n {
  #e(e) {
    if (e.isArray())
      return new Ff(this.#e(e.arrayChildren), e.arrayLength, e.name);
    if (e.isTuple())
      return new po(
        e.components.map((r) => this.#e(r)),
        e.name
      );
    switch (e.baseType) {
      case "address":
        return new Of(e.name);
      case "bool":
        return new Mf(e.name);
      case "string":
        return new Hf(e.name);
      case "bytes":
        return new Uf(e.name);
      case "":
        return new jf(e.name);
    }
    let t = e.type.match(zN);
    if (t) {
      let r = parseInt(t[2] || "256");
      return (
        x(
          r !== 0 && r <= 256 && r % 8 === 0,
          "invalid " + t[1] + " bit length",
          "param",
          e
        ),
        new Wf(r / 8, t[1] === "int", e.name)
      );
    }
    if (((t = e.type.match(UN)), t)) {
      let r = parseInt(t[1]);
      return (
        x(r !== 0 && r <= 32, "invalid bytes length", "param", e),
        new zf(r, e.name)
      );
    }
    x(!1, "invalid type", "type", e.type);
  }
  getDefaultValue(e) {
    let t = e.map((i) => this.#e(Mt.from(i)));
    return new po(t, "_").defaultValue();
  }
  encode(e, t) {
    ja(t.length, e.length, "types/values length mismatch");
    let r = e.map((o) => this.#e(Mt.from(o))),
      i = new po(r, "_"),
      s = new fo();
    return i.encode(s, t), s.data;
  }
  decode(e, t, r) {
    let i = e.map((o) => this.#e(Mt.from(o)));
    return new po(i, "_").decode(new Df(t, r, Rv));
  }
  static _setDefaultMaxInflation(e) {
    x(
      typeof e == "number" && Number.isInteger(e),
      "invalid defaultMaxInflation factor",
      "value",
      e
    ),
      (Rv = e);
  }
  static defaultAbiCoder() {
    return my == null && (my = new n()), my;
  }
  static getBuiltinCallException(e, t, r) {
    return jN(e, t, r, n.defaultAbiCoder());
  }
};
p();
var td = class {
    fragment;
    name;
    signature;
    topic;
    args;
    constructor(e, t, r) {
      let i = e.name,
        s = e.format();
      ee(this, { fragment: e, name: i, signature: s, topic: t, args: r });
    }
  },
  nd = class {
    fragment;
    name;
    args;
    signature;
    selector;
    value;
    constructor(e, t, r, i) {
      let s = e.name,
        o = e.format();
      ee(this, {
        fragment: e,
        name: s,
        args: r,
        signature: o,
        selector: t,
        value: i,
      });
    }
  },
  rd = class {
    fragment;
    name;
    args;
    signature;
    selector;
    constructor(e, t, r) {
      let i = e.name,
        s = e.format();
      ee(this, { fragment: e, name: i, args: r, signature: s, selector: t });
    }
  },
  Al = class {
    hash;
    _isIndexed;
    static isIndexed(e) {
      return !!(e && e._isIndexed);
    }
    constructor(e) {
      ee(this, { hash: e, _isIndexed: !0 });
    }
  },
  Bv = {
    0: "generic panic",
    1: "assert(false)",
    17: "arithmetic overflow",
    18: "division or modulo by zero",
    33: "enum overflow",
    34: "invalid encoded storage byte array accessed",
    49: "out-of-bounds array access; popping on an empty array",
    50: "out-of-bounds access of an array or bytesN",
    65: "out of memory",
    81: "uninitialized function",
  },
  Dv = {
    "0x08c379a0": {
      signature: "Error(string)",
      name: "Error",
      inputs: ["string"],
      reason: (n) => `reverted with reason string ${JSON.stringify(n)}`,
    },
    "0x4e487b71": {
      signature: "Panic(uint256)",
      name: "Panic",
      inputs: ["uint256"],
      reason: (n) => {
        let e = "unknown panic code";
        return (
          n >= 0 && n <= 255 && Bv[n.toString()] && (e = Bv[n.toString()]),
          `reverted with panic code 0x${n.toString(16)} (${e})`
        );
      },
    },
  },
  So = class n {
    fragments;
    deploy;
    fallback;
    receive;
    #e;
    #t;
    #n;
    #r;
    constructor(e) {
      let t = [];
      typeof e == "string" ? (t = JSON.parse(e)) : (t = e),
        (this.#n = new Map()),
        (this.#e = new Map()),
        (this.#t = new Map());
      let r = [];
      for (let o of t)
        try {
          r.push(xo.from(o));
        } catch (a) {
          console.log(
            `[Warning] Invalid Fragment ${JSON.stringify(o)}:`,
            a.message
          );
        }
      ee(this, { fragments: Object.freeze(r) });
      let i = null,
        s = !1;
      (this.#r = this.getAbiCoder()),
        this.fragments.forEach((o, a) => {
          let c;
          switch (o.type) {
            case "constructor":
              if (this.deploy) {
                console.log("duplicate definition - constructor");
                return;
              }
              ee(this, { deploy: o });
              return;
            case "fallback":
              o.inputs.length === 0
                ? (s = !0)
                : (x(
                    !i || o.payable !== i.payable,
                    "conflicting fallback fragments",
                    `fragments[${a}]`,
                    o
                  ),
                  (i = o),
                  (s = i.payable));
              return;
            case "function":
              c = this.#n;
              break;
            case "event":
              c = this.#t;
              break;
            case "error":
              c = this.#e;
              break;
            default:
              return;
          }
          let u = o.format();
          c.has(u) || c.set(u, o);
        }),
        this.deploy || ee(this, { deploy: bo.from("constructor()") }),
        ee(this, { fallback: i, receive: s });
    }
    format(e) {
      let t = e ? "minimal" : "full";
      return this.fragments.map((i) => i.format(t));
    }
    formatJson() {
      let e = this.fragments.map((t) => t.format("json"));
      return JSON.stringify(e.map((t) => JSON.parse(t)));
    }
    getAbiCoder() {
      return bs.defaultAbiCoder();
    }
    #i(e, t, r) {
      if (De(e)) {
        let s = e.toLowerCase();
        for (let o of this.#n.values()) if (s === o.selector) return o;
        return null;
      }
      if (e.indexOf("(") === -1) {
        let s = [];
        for (let [o, a] of this.#n) o.split("(")[0] === e && s.push(a);
        if (t) {
          let o = t.length > 0 ? t[t.length - 1] : null,
            a = t.length,
            c = !0;
          lt.isTyped(o) && o.type === "overrides" && ((c = !1), a--);
          for (let u = s.length - 1; u >= 0; u--) {
            let l = s[u].inputs.length;
            l !== a && (!c || l !== a - 1) && s.splice(u, 1);
          }
          for (let u = s.length - 1; u >= 0; u--) {
            let l = s[u].inputs;
            for (let h = 0; h < t.length; h++)
              if (lt.isTyped(t[h])) {
                if (h >= l.length) {
                  if (t[h].type === "overrides") continue;
                  s.splice(u, 1);
                  break;
                }
                if (t[h].type !== l[h].baseType) {
                  s.splice(u, 1);
                  break;
                }
              }
          }
        }
        if (s.length === 1 && t && t.length !== s[0].inputs.length) {
          let o = t[t.length - 1];
          (o == null || Array.isArray(o) || typeof o != "object") &&
            s.splice(0, 1);
        }
        if (s.length === 0) return null;
        if (s.length > 1 && r) {
          let o = s.map((a) => JSON.stringify(a.format())).join(", ");
          x(!1, `ambiguous function description (i.e. matches ${o})`, "key", e);
        }
        return s[0];
      }
      let i = this.#n.get(Ao.from(e).format());
      return i || null;
    }
    getFunctionName(e) {
      let t = this.#i(e, null, !1);
      return x(t, "no matching function", "key", e), t.name;
    }
    hasFunction(e) {
      return !!this.#i(e, null, !1);
    }
    getFunction(e, t) {
      return this.#i(e, t || null, !0);
    }
    forEachFunction(e) {
      let t = Array.from(this.#n.keys());
      t.sort((r, i) => r.localeCompare(i));
      for (let r = 0; r < t.length; r++) {
        let i = t[r];
        e(this.#n.get(i), r);
      }
    }
    #o(e, t, r) {
      if (De(e)) {
        let s = e.toLowerCase();
        for (let o of this.#t.values()) if (s === o.topicHash) return o;
        return null;
      }
      if (e.indexOf("(") === -1) {
        let s = [];
        for (let [o, a] of this.#t) o.split("(")[0] === e && s.push(a);
        if (t) {
          for (let o = s.length - 1; o >= 0; o--)
            s[o].inputs.length < t.length && s.splice(o, 1);
          for (let o = s.length - 1; o >= 0; o--) {
            let a = s[o].inputs;
            for (let c = 0; c < t.length; c++)
              if (lt.isTyped(t[c]) && t[c].type !== a[c].baseType) {
                s.splice(o, 1);
                break;
              }
          }
        }
        if (s.length === 0) return null;
        if (s.length > 1 && r) {
          let o = s.map((a) => JSON.stringify(a.format())).join(", ");
          x(!1, `ambiguous event description (i.e. matches ${o})`, "key", e);
        }
        return s[0];
      }
      let i = this.#t.get(wo.from(e).format());
      return i || null;
    }
    getEventName(e) {
      let t = this.#o(e, null, !1);
      return x(t, "no matching event", "key", e), t.name;
    }
    hasEvent(e) {
      return !!this.#o(e, null, !1);
    }
    getEvent(e, t) {
      return this.#o(e, t || null, !0);
    }
    forEachEvent(e) {
      let t = Array.from(this.#t.keys());
      t.sort((r, i) => r.localeCompare(i));
      for (let r = 0; r < t.length; r++) {
        let i = t[r];
        e(this.#t.get(i), r);
      }
    }
    getError(e, t) {
      if (De(e)) {
        let i = e.toLowerCase();
        if (Dv[i]) return fr.from(Dv[i].signature);
        for (let s of this.#e.values()) if (i === s.selector) return s;
        return null;
      }
      if (e.indexOf("(") === -1) {
        let i = [];
        for (let [s, o] of this.#e) s.split("(")[0] === e && i.push(o);
        if (i.length === 0)
          return e === "Error"
            ? fr.from("error Error(string)")
            : e === "Panic"
            ? fr.from("error Panic(uint256)")
            : null;
        if (i.length > 1) {
          let s = i.map((o) => JSON.stringify(o.format())).join(", ");
          x(!1, `ambiguous error description (i.e. ${s})`, "name", e);
        }
        return i[0];
      }
      if (((e = fr.from(e).format()), e === "Error(string)"))
        return fr.from("error Error(string)");
      if (e === "Panic(uint256)") return fr.from("error Panic(uint256)");
      let r = this.#e.get(e);
      return r || null;
    }
    forEachError(e) {
      let t = Array.from(this.#e.keys());
      t.sort((r, i) => r.localeCompare(i));
      for (let r = 0; r < t.length; r++) {
        let i = t[r];
        e(this.#e.get(i), r);
      }
    }
    _decodeParams(e, t) {
      return this.#r.decode(e, t);
    }
    _encodeParams(e, t) {
      return this.#r.encode(e, t);
    }
    encodeDeploy(e) {
      return this._encodeParams(this.deploy.inputs, e || []);
    }
    decodeErrorResult(e, t) {
      if (typeof e == "string") {
        let r = this.getError(e);
        x(r, "unknown error", "fragment", e), (e = r);
      }
      return (
        x(
          at(t, 0, 4) === e.selector,
          `data signature does not match error ${e.name}.`,
          "data",
          t
        ),
        this._decodeParams(e.inputs, at(t, 4))
      );
    }
    encodeErrorResult(e, t) {
      if (typeof e == "string") {
        let r = this.getError(e);
        x(r, "unknown error", "fragment", e), (e = r);
      }
      return Fe([e.selector, this._encodeParams(e.inputs, t || [])]);
    }
    decodeFunctionData(e, t) {
      if (typeof e == "string") {
        let r = this.getFunction(e);
        x(r, "unknown function", "fragment", e), (e = r);
      }
      return (
        x(
          at(t, 0, 4) === e.selector,
          `data signature does not match function ${e.name}.`,
          "data",
          t
        ),
        this._decodeParams(e.inputs, at(t, 4))
      );
    }
    encodeFunctionData(e, t) {
      if (typeof e == "string") {
        let r = this.getFunction(e);
        x(r, "unknown function", "fragment", e), (e = r);
      }
      return Fe([e.selector, this._encodeParams(e.inputs, t || [])]);
    }
    decodeFunctionResult(e, t) {
      if (typeof e == "string") {
        let s = this.getFunction(e);
        x(s, "unknown function", "fragment", e), (e = s);
      }
      let r = "invalid length for result data",
        i = Ct(t);
      if (i.length % 32 === 0)
        try {
          return this.#r.decode(e.outputs, i);
        } catch {
          r = "could not decode result data";
        }
      R(!1, r, "BAD_DATA", {
        value: V(i),
        info: { method: e.name, signature: e.format() },
      });
    }
    makeError(e, t) {
      let r = fe(e, "data"),
        i = bs.getBuiltinCallException("call", t, r);
      if (i.message.startsWith("execution reverted (unknown custom error)")) {
        let a = V(r.slice(0, 4)),
          c = this.getError(a);
        if (c)
          try {
            let u = this.#r.decode(c.inputs, r.slice(4));
            (i.revert = { name: c.name, signature: c.format(), args: u }),
              (i.reason = i.revert.signature),
              (i.message = `execution reverted: ${i.reason}`);
          } catch {
            i.message = "execution reverted (coult not decode custom error)";
          }
      }
      let o = this.parseTransaction(t);
      return (
        o &&
          (i.invocation = {
            method: o.name,
            signature: o.signature,
            args: o.args,
          }),
        i
      );
    }
    encodeFunctionResult(e, t) {
      if (typeof e == "string") {
        let r = this.getFunction(e);
        x(r, "unknown function", "fragment", e), (e = r);
      }
      return V(this.#r.encode(e.outputs, t || []));
    }
    encodeFilterTopics(e, t) {
      if (typeof e == "string") {
        let s = this.getEvent(e);
        x(s, "unknown event", "eventFragment", e), (e = s);
      }
      R(
        t.length <= e.inputs.length,
        `too many arguments for ${e.format()}`,
        "UNEXPECTED_ARGUMENT",
        { count: t.length, expectedCount: e.inputs.length }
      );
      let r = [];
      e.anonymous || r.push(e.topicHash);
      let i = (s, o) =>
        s.type === "string"
          ? Rr(o)
          : s.type === "bytes"
          ? et(V(o))
          : (s.type === "bool" && typeof o == "boolean"
              ? (o = o ? "0x01" : "0x00")
              : s.type.match(/^u?int/)
              ? (o = vn(o))
              : s.type.match(/^bytes/)
              ? (o = Sf(o, 32))
              : s.type === "address" && this.#r.encode(["address"], [o]),
            Ln(V(o), 32));
      for (
        t.forEach((s, o) => {
          let a = e.inputs[o];
          if (!a.indexed) {
            x(
              s == null,
              "cannot filter non-indexed parameters; must be null",
              "contract." + a.name,
              s
            );
            return;
          }
          s == null
            ? r.push(null)
            : a.baseType === "array" || a.baseType === "tuple"
            ? x(
                !1,
                "filtering with tuples or arrays not supported",
                "contract." + a.name,
                s
              )
            : Array.isArray(s)
            ? r.push(s.map((c) => i(a, c)))
            : r.push(i(a, s));
        });
        r.length && r[r.length - 1] === null;

      )
        r.pop();
      return r;
    }
    encodeEventLog(e, t) {
      if (typeof e == "string") {
        let o = this.getEvent(e);
        x(o, "unknown event", "eventFragment", e), (e = o);
      }
      let r = [],
        i = [],
        s = [];
      return (
        e.anonymous || r.push(e.topicHash),
        x(
          t.length === e.inputs.length,
          "event arguments/values mismatch",
          "values",
          t
        ),
        e.inputs.forEach((o, a) => {
          let c = t[a];
          if (o.indexed)
            if (o.type === "string") r.push(Rr(c));
            else if (o.type === "bytes") r.push(et(c));
            else {
              if (o.baseType === "tuple" || o.baseType === "array")
                throw new Error("not implemented");
              r.push(this.#r.encode([o.type], [c]));
            }
          else i.push(o), s.push(c);
        }),
        { data: this.#r.encode(i, s), topics: r }
      );
    }
    decodeEventLog(e, t, r) {
      if (typeof e == "string") {
        let g = this.getEvent(e);
        x(g, "unknown event", "eventFragment", e), (e = g);
      }
      if (r != null && !e.anonymous) {
        let g = e.topicHash;
        x(
          De(r[0], 32) && r[0].toLowerCase() === g,
          "fragment/topic mismatch",
          "topics[0]",
          r[0]
        ),
          (r = r.slice(1));
      }
      let i = [],
        s = [],
        o = [];
      e.inputs.forEach((g, y) => {
        g.indexed
          ? g.type === "string" ||
            g.type === "bytes" ||
            g.baseType === "tuple" ||
            g.baseType === "array"
            ? (i.push(Mt.from({ type: "bytes32", name: g.name })), o.push(!0))
            : (i.push(g), o.push(!1))
          : (s.push(g), o.push(!1));
      });
      let a = r != null ? this.#r.decode(i, Fe(r)) : null,
        c = this.#r.decode(s, t, !0),
        u = [],
        l = [],
        h = 0,
        f = 0;
      return (
        e.inputs.forEach((g, y) => {
          let w = null;
          if (g.indexed)
            if (a == null) w = new Al(null);
            else if (o[y]) w = new Al(a[f++]);
            else
              try {
                w = a[f++];
              } catch (m) {
                w = m;
              }
          else
            try {
              w = c[h++];
            } catch (m) {
              w = m;
            }
          u.push(w), l.push(g.name || null);
        }),
        Ti.fromItems(u, l)
      );
    }
    parseTransaction(e) {
      let t = fe(e.data, "tx.data"),
        r = Y(e.value != null ? e.value : 0, "tx.value"),
        i = this.getFunction(V(t.slice(0, 4)));
      if (!i) return null;
      let s = this.#r.decode(i.inputs, t.slice(4));
      return new nd(i, i.selector, s, r);
    }
    parseCallResult(e) {
      throw new Error("@TODO");
    }
    parseLog(e) {
      let t = this.getEvent(e.topics[0]);
      return !t || t.anonymous
        ? null
        : new td(t, t.topicHash, this.decodeEventLog(t, e.data, e.topics));
    }
    parseError(e) {
      let t = V(e),
        r = this.getError(at(t, 0, 4));
      if (!r) return null;
      let i = this.#r.decode(r.inputs, at(t, 4));
      return new rd(r, r.selector, i);
    }
    static from(e) {
      return e instanceof n
        ? e
        : typeof e == "string"
        ? new n(JSON.parse(e))
        : typeof e.formatJson == "function"
        ? new n(e.formatJson())
        : typeof e.format == "function"
        ? new n(e.format("json"))
        : new n(e);
    }
  };
p();
p();
p();
var _v = BigInt(0);
function rc(n) {
  return n ?? null;
}
function Dt(n) {
  return n == null ? null : n.toString();
}
var ic = class {
  gasPrice;
  maxFeePerGas;
  maxPriorityFeePerGas;
  constructor(e, t, r) {
    ee(this, {
      gasPrice: rc(e),
      maxFeePerGas: rc(t),
      maxPriorityFeePerGas: rc(r),
    });
  }
  toJSON() {
    let { gasPrice: e, maxFeePerGas: t, maxPriorityFeePerGas: r } = this;
    return {
      _type: "FeeData",
      gasPrice: Dt(e),
      maxFeePerGas: Dt(t),
      maxPriorityFeePerGas: Dt(r),
    };
  }
};
function Es(n) {
  let e = {};
  n.to && (e.to = n.to),
    n.from && (e.from = n.from),
    n.data && (e.data = V(n.data));
  let t =
    "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(
      /,/
    );
  for (let i of t)
    !(i in n) || n[i] == null || (e[i] = Y(n[i], `request.${i}`));
  let r = "type,nonce".split(/,/);
  for (let i of r)
    !(i in n) || n[i] == null || (e[i] = me(n[i], `request.${i}`));
  return (
    n.accessList && (e.accessList = Yn(n.accessList)),
    "blockTag" in n && (e.blockTag = n.blockTag),
    "enableCcipRead" in n && (e.enableCcipRead = !!n.enableCcipRead),
    "customData" in n && (e.customData = n.customData),
    "blobVersionedHashes" in n &&
      n.blobVersionedHashes &&
      (e.blobVersionedHashes = n.blobVersionedHashes.slice()),
    "kzg" in n && (e.kzg = n.kzg),
    "blobs" in n &&
      n.blobs &&
      (e.blobs = n.blobs.map((i) => (hs(i) ? V(i) : Object.assign({}, i)))),
    e
  );
}
var El = class {
    provider;
    number;
    hash;
    timestamp;
    parentHash;
    parentBeaconBlockRoot;
    nonce;
    difficulty;
    gasLimit;
    gasUsed;
    stateRoot;
    receiptsRoot;
    blobGasUsed;
    excessBlobGas;
    miner;
    prevRandao;
    extraData;
    baseFeePerGas;
    #e;
    constructor(e, t) {
      (this.#e = e.transactions.map((r) =>
        typeof r != "string" ? new As(r, t) : r
      )),
        ee(this, {
          provider: t,
          hash: rc(e.hash),
          number: e.number,
          timestamp: e.timestamp,
          parentHash: e.parentHash,
          parentBeaconBlockRoot: e.parentBeaconBlockRoot,
          nonce: e.nonce,
          difficulty: e.difficulty,
          gasLimit: e.gasLimit,
          gasUsed: e.gasUsed,
          blobGasUsed: e.blobGasUsed,
          excessBlobGas: e.excessBlobGas,
          miner: e.miner,
          prevRandao: rc(e.prevRandao),
          extraData: e.extraData,
          baseFeePerGas: rc(e.baseFeePerGas),
          stateRoot: e.stateRoot,
          receiptsRoot: e.receiptsRoot,
        });
    }
    get transactions() {
      return this.#e.map((e) => (typeof e == "string" ? e : e.hash));
    }
    get prefetchedTransactions() {
      let e = this.#e.slice();
      return e.length === 0
        ? []
        : (R(
            typeof e[0] == "object",
            "transactions were not prefetched with block request",
            "UNSUPPORTED_OPERATION",
            { operation: "transactionResponses()" }
          ),
          e);
    }
    toJSON() {
      let {
        baseFeePerGas: e,
        difficulty: t,
        extraData: r,
        gasLimit: i,
        gasUsed: s,
        hash: o,
        miner: a,
        prevRandao: c,
        nonce: u,
        number: l,
        parentHash: h,
        parentBeaconBlockRoot: f,
        stateRoot: g,
        receiptsRoot: y,
        timestamp: w,
        transactions: m,
      } = this;
      return {
        _type: "Block",
        baseFeePerGas: Dt(e),
        difficulty: Dt(t),
        extraData: r,
        gasLimit: Dt(i),
        gasUsed: Dt(s),
        blobGasUsed: Dt(this.blobGasUsed),
        excessBlobGas: Dt(this.excessBlobGas),
        hash: o,
        miner: a,
        prevRandao: c,
        nonce: u,
        number: l,
        parentHash: h,
        timestamp: w,
        parentBeaconBlockRoot: f,
        stateRoot: g,
        receiptsRoot: y,
        transactions: m,
      };
    }
    [Symbol.iterator]() {
      let e = 0,
        t = this.transactions;
      return {
        next: () =>
          e < this.length
            ? { value: t[e++], done: !1 }
            : { value: void 0, done: !0 },
      };
    }
    get length() {
      return this.#e.length;
    }
    get date() {
      return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
    }
    getTransaction(e) {
      return d(this, null, function* () {
        let t;
        if (typeof e == "number") t = this.#e[e];
        else {
          let r = e.toLowerCase();
          for (let i of this.#e)
            if (typeof i == "string") {
              if (i !== r) continue;
              t = i;
              break;
            } else {
              if (i.hash === r) continue;
              t = i;
              break;
            }
        }
        if (t == null) throw new Error("no such tx");
        return typeof t == "string" ? yield this.provider.getTransaction(t) : t;
      });
    }
    getPrefetchedTransaction(e) {
      let t = this.prefetchedTransactions;
      if (typeof e == "number") return t[e];
      e = e.toLowerCase();
      for (let r of t) if (r.hash === e) return r;
      x(!1, "no matching transaction", "indexOrHash", e);
    }
    isMined() {
      return !!this.hash;
    }
    isLondon() {
      return !!this.baseFeePerGas;
    }
    orphanedEvent() {
      if (!this.isMined()) throw new Error("");
      return HN(this);
    }
  },
  _r = class {
    provider;
    transactionHash;
    blockHash;
    blockNumber;
    removed;
    address;
    data;
    topics;
    index;
    transactionIndex;
    constructor(e, t) {
      this.provider = t;
      let r = Object.freeze(e.topics.slice());
      ee(this, {
        transactionHash: e.transactionHash,
        blockHash: e.blockHash,
        blockNumber: e.blockNumber,
        removed: e.removed,
        address: e.address,
        data: e.data,
        topics: r,
        index: e.index,
        transactionIndex: e.transactionIndex,
      });
    }
    toJSON() {
      let {
        address: e,
        blockHash: t,
        blockNumber: r,
        data: i,
        index: s,
        removed: o,
        topics: a,
        transactionHash: c,
        transactionIndex: u,
      } = this;
      return {
        _type: "log",
        address: e,
        blockHash: t,
        blockNumber: r,
        data: i,
        index: s,
        removed: o,
        topics: a,
        transactionHash: c,
        transactionIndex: u,
      };
    }
    getBlock() {
      return d(this, null, function* () {
        let e = yield this.provider.getBlock(this.blockHash);
        return R(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
      });
    }
    getTransaction() {
      return d(this, null, function* () {
        let e = yield this.provider.getTransaction(this.transactionHash);
        return R(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
      });
    }
    getTransactionReceipt() {
      return d(this, null, function* () {
        let e = yield this.provider.getTransactionReceipt(this.transactionHash);
        return (
          R(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e
        );
      });
    }
    removedEvent() {
      return VN(this);
    }
  },
  vo = class {
    provider;
    to;
    from;
    contractAddress;
    hash;
    index;
    blockHash;
    blockNumber;
    logsBloom;
    gasUsed;
    blobGasUsed;
    cumulativeGasUsed;
    gasPrice;
    blobGasPrice;
    type;
    status;
    root;
    #e;
    constructor(e, t) {
      this.#e = Object.freeze(e.logs.map((i) => new _r(i, t)));
      let r = _v;
      e.effectiveGasPrice != null
        ? (r = e.effectiveGasPrice)
        : e.gasPrice != null && (r = e.gasPrice),
        ee(this, {
          provider: t,
          to: e.to,
          from: e.from,
          contractAddress: e.contractAddress,
          hash: e.hash,
          index: e.index,
          blockHash: e.blockHash,
          blockNumber: e.blockNumber,
          logsBloom: e.logsBloom,
          gasUsed: e.gasUsed,
          cumulativeGasUsed: e.cumulativeGasUsed,
          blobGasUsed: e.blobGasUsed,
          gasPrice: r,
          blobGasPrice: e.blobGasPrice,
          type: e.type,
          status: e.status,
          root: e.root,
        });
    }
    get logs() {
      return this.#e;
    }
    toJSON() {
      let {
        to: e,
        from: t,
        contractAddress: r,
        hash: i,
        index: s,
        blockHash: o,
        blockNumber: a,
        logsBloom: c,
        logs: u,
        status: l,
        root: h,
      } = this;
      return {
        _type: "TransactionReceipt",
        blockHash: o,
        blockNumber: a,
        contractAddress: r,
        cumulativeGasUsed: Dt(this.cumulativeGasUsed),
        from: t,
        gasPrice: Dt(this.gasPrice),
        blobGasUsed: Dt(this.blobGasUsed),
        blobGasPrice: Dt(this.blobGasPrice),
        gasUsed: Dt(this.gasUsed),
        hash: i,
        index: s,
        logs: u,
        logsBloom: c,
        root: h,
        status: l,
        to: e,
      };
    }
    get length() {
      return this.logs.length;
    }
    [Symbol.iterator]() {
      let e = 0;
      return {
        next: () =>
          e < this.length
            ? { value: this.logs[e++], done: !1 }
            : { value: void 0, done: !0 },
      };
    }
    get fee() {
      return this.gasUsed * this.gasPrice;
    }
    getBlock() {
      return d(this, null, function* () {
        let e = yield this.provider.getBlock(this.blockHash);
        if (e == null) throw new Error("TODO");
        return e;
      });
    }
    getTransaction() {
      return d(this, null, function* () {
        let e = yield this.provider.getTransaction(this.hash);
        if (e == null) throw new Error("TODO");
        return e;
      });
    }
    getResult() {
      return d(this, null, function* () {
        return yield this.provider.getTransactionResult(this.hash);
      });
    }
    confirmations() {
      return d(this, null, function* () {
        return (yield this.provider.getBlockNumber()) - this.blockNumber + 1;
      });
    }
    removedEvent() {
      return Lv(this);
    }
    reorderedEvent(e) {
      return (
        R(
          !e || e.isMined(),
          "unmined 'other' transction cannot be orphaned",
          "UNSUPPORTED_OPERATION",
          { operation: "reorderedEvent(other)" }
        ),
        Pv(this, e)
      );
    }
  },
  As = class n {
    provider;
    blockNumber;
    blockHash;
    index;
    hash;
    type;
    to;
    from;
    nonce;
    gasLimit;
    gasPrice;
    maxPriorityFeePerGas;
    maxFeePerGas;
    maxFeePerBlobGas;
    data;
    value;
    chainId;
    signature;
    accessList;
    blobVersionedHashes;
    #e;
    constructor(e, t) {
      (this.provider = t),
        (this.blockNumber = e.blockNumber != null ? e.blockNumber : null),
        (this.blockHash = e.blockHash != null ? e.blockHash : null),
        (this.hash = e.hash),
        (this.index = e.index),
        (this.type = e.type),
        (this.from = e.from),
        (this.to = e.to || null),
        (this.gasLimit = e.gasLimit),
        (this.nonce = e.nonce),
        (this.data = e.data),
        (this.value = e.value),
        (this.gasPrice = e.gasPrice),
        (this.maxPriorityFeePerGas =
          e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null),
        (this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null),
        (this.maxFeePerBlobGas =
          e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null),
        (this.chainId = e.chainId),
        (this.signature = e.signature),
        (this.accessList = e.accessList != null ? e.accessList : null),
        (this.blobVersionedHashes =
          e.blobVersionedHashes != null ? e.blobVersionedHashes : null),
        (this.#e = -1);
    }
    toJSON() {
      let {
        blockNumber: e,
        blockHash: t,
        index: r,
        hash: i,
        type: s,
        to: o,
        from: a,
        nonce: c,
        data: u,
        signature: l,
        accessList: h,
        blobVersionedHashes: f,
      } = this;
      return {
        _type: "TransactionResponse",
        accessList: h,
        blockNumber: e,
        blockHash: t,
        blobVersionedHashes: f,
        chainId: Dt(this.chainId),
        data: u,
        from: a,
        gasLimit: Dt(this.gasLimit),
        gasPrice: Dt(this.gasPrice),
        hash: i,
        maxFeePerGas: Dt(this.maxFeePerGas),
        maxPriorityFeePerGas: Dt(this.maxPriorityFeePerGas),
        maxFeePerBlobGas: Dt(this.maxFeePerBlobGas),
        nonce: c,
        signature: l,
        to: o,
        index: r,
        type: s,
        value: Dt(this.value),
      };
    }
    getBlock() {
      return d(this, null, function* () {
        let e = this.blockNumber;
        if (e == null) {
          let r = yield this.getTransaction();
          r && (e = r.blockNumber);
        }
        if (e == null) return null;
        let t = this.provider.getBlock(e);
        if (t == null) throw new Error("TODO");
        return t;
      });
    }
    getTransaction() {
      return d(this, null, function* () {
        return this.provider.getTransaction(this.hash);
      });
    }
    confirmations() {
      return d(this, null, function* () {
        if (this.blockNumber == null) {
          let { tx: t, blockNumber: r } = yield It({
            tx: this.getTransaction(),
            blockNumber: this.provider.getBlockNumber(),
          });
          return t == null || t.blockNumber == null ? 0 : r - t.blockNumber + 1;
        }
        return (yield this.provider.getBlockNumber()) - this.blockNumber + 1;
      });
    }
    wait(e, t) {
      return d(this, null, function* () {
        let r = e ?? 1,
          i = t ?? 0,
          s = this.#e,
          o = -1,
          a = s === -1,
          c = () =>
            d(this, null, function* () {
              if (a) return null;
              let { blockNumber: f, nonce: g } = yield It({
                blockNumber: this.provider.getBlockNumber(),
                nonce: this.provider.getTransactionCount(this.from),
              });
              if (g < this.nonce) {
                s = f;
                return;
              }
              if (a) return null;
              let y = yield this.getTransaction();
              if (!(y && y.blockNumber != null))
                for (
                  o === -1 && ((o = s - 3), o < this.#e && (o = this.#e));
                  o <= f;

                ) {
                  if (a) return null;
                  let w = yield this.provider.getBlock(o, !0);
                  if (w == null) return;
                  for (let m of w) if (m === this.hash) return;
                  for (let m = 0; m < w.length; m++) {
                    let b = yield w.getTransaction(m);
                    if (b.from === this.from && b.nonce === this.nonce) {
                      if (a) return null;
                      let I = yield this.provider.getTransactionReceipt(b.hash);
                      if (I == null || f - I.blockNumber + 1 < r) return;
                      let E = "replaced";
                      b.data === this.data &&
                      b.to === this.to &&
                      b.value === this.value
                        ? (E = "repriced")
                        : b.data === "0x" &&
                          b.from === b.to &&
                          b.value === _v &&
                          (E = "cancelled"),
                        R(
                          !1,
                          "transaction was replaced",
                          "TRANSACTION_REPLACED",
                          {
                            cancelled: E === "replaced" || E === "cancelled",
                            reason: E,
                            replacement: b.replaceableTransaction(s),
                            hash: b.hash,
                            receipt: I,
                          }
                        );
                    }
                  }
                  o++;
                }
            }),
          u = (f) => {
            if (f == null || f.status !== 0) return f;
            R(!1, "transaction execution reverted", "CALL_EXCEPTION", {
              action: "sendTransaction",
              data: null,
              reason: null,
              invocation: null,
              revert: null,
              transaction: { to: f.to, from: f.from, data: "" },
              receipt: f,
            });
          },
          l = yield this.provider.getTransactionReceipt(this.hash);
        if (r === 0) return u(l);
        if (l) {
          if ((yield l.confirmations()) >= r) return u(l);
        } else if ((yield c(), r === 0)) return null;
        return yield new Promise((f, g) => {
          let y = [],
            w = () => {
              y.forEach((b) => b());
            };
          if (
            (y.push(() => {
              a = !0;
            }),
            i > 0)
          ) {
            let b = setTimeout(() => {
              w(), g(Ye("wait for transaction timeout", "TIMEOUT"));
            }, i);
            y.push(() => {
              clearTimeout(b);
            });
          }
          let m = (b) =>
            d(this, null, function* () {
              if ((yield b.confirmations()) >= r) {
                w();
                try {
                  f(u(b));
                } catch (I) {
                  g(I);
                }
              }
            });
          if (
            (y.push(() => {
              this.provider.off(this.hash, m);
            }),
            this.provider.on(this.hash, m),
            s >= 0)
          ) {
            let b = () =>
              d(this, null, function* () {
                try {
                  yield c();
                } catch (I) {
                  if (ut(I, "TRANSACTION_REPLACED")) {
                    w(), g(I);
                    return;
                  }
                }
                a || this.provider.once("block", b);
              });
            y.push(() => {
              this.provider.off("block", b);
            }),
              this.provider.once("block", b);
          }
        });
      });
    }
    isMined() {
      return this.blockHash != null;
    }
    isLegacy() {
      return this.type === 0;
    }
    isBerlin() {
      return this.type === 1;
    }
    isLondon() {
      return this.type === 2;
    }
    isCancun() {
      return this.type === 3;
    }
    removedEvent() {
      return (
        R(
          this.isMined(),
          "unmined transaction canot be orphaned",
          "UNSUPPORTED_OPERATION",
          { operation: "removeEvent()" }
        ),
        Lv(this)
      );
    }
    reorderedEvent(e) {
      return (
        R(
          this.isMined(),
          "unmined transaction canot be orphaned",
          "UNSUPPORTED_OPERATION",
          { operation: "removeEvent()" }
        ),
        R(
          !e || e.isMined(),
          "unmined 'other' transaction canot be orphaned",
          "UNSUPPORTED_OPERATION",
          { operation: "removeEvent()" }
        ),
        Pv(this, e)
      );
    }
    replaceableTransaction(e) {
      x(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
      let t = new n(this, this.provider);
      return (t.#e = e), t;
    }
  };
function HN(n) {
  return { orphan: "drop-block", hash: n.hash, number: n.number };
}
function Pv(n, e) {
  return { orphan: "reorder-transaction", tx: n, other: e };
}
function Lv(n) {
  return { orphan: "drop-transaction", tx: n };
}
function VN(n) {
  return {
    orphan: "drop-log",
    log: {
      transactionHash: n.transactionHash,
      blockHash: n.blockHash,
      blockNumber: n.blockNumber,
      address: n.address,
      data: n.data,
      topics: Object.freeze(n.topics.slice()),
      index: n.index,
    },
  };
}
p();
var Io = class extends _r {
    interface;
    fragment;
    args;
    constructor(e, t, r) {
      super(e, e.provider);
      let i = t.decodeEventLog(r, e.data, e.topics);
      ee(this, { args: i, fragment: r, interface: t });
    }
    get eventName() {
      return this.fragment.name;
    }
    get eventSignature() {
      return this.fragment.format();
    }
  },
  sc = class extends _r {
    error;
    constructor(e, t) {
      super(e, e.provider), ee(this, { error: t });
    }
  },
  id = class extends vo {
    #e;
    constructor(e, t, r) {
      super(r, t), (this.#e = e);
    }
    get logs() {
      return super.logs.map((e) => {
        let t = e.topics.length ? this.#e.getEvent(e.topics[0]) : null;
        if (t)
          try {
            return new Io(e, this.#e, t);
          } catch (r) {
            return new sc(e, r);
          }
        return e;
      });
    }
  },
  Co = class n extends As {
    #e;
    constructor(e, t, r) {
      super(r, t), (this.#e = e);
    }
    wait(e, t) {
      return d(this, null, function* () {
        let r = yield Js(n.prototype, this, "wait").call(this, e, t);
        return r == null ? null : new id(this.#e, this.provider, r);
      });
    }
  },
  oc = class extends ds {
    log;
    constructor(e, t, r, i) {
      super(e, t, r), ee(this, { log: i });
    }
    getBlock() {
      return d(this, null, function* () {
        return yield this.log.getBlock();
      });
    }
    getTransaction() {
      return d(this, null, function* () {
        return yield this.log.getTransaction();
      });
    }
    getTransactionReceipt() {
      return d(this, null, function* () {
        return yield this.log.getTransactionReceipt();
      });
    }
  },
  xl = class extends oc {
    constructor(e, t, r, i, s) {
      super(e, t, r, new Io(s, e.interface, i));
      let o = e.interface.decodeEventLog(i, this.log.data, this.log.topics);
      ee(this, { args: o, fragment: i });
    }
    get eventName() {
      return this.fragment.name;
    }
    get eventSignature() {
      return this.fragment.format();
    }
  };
var Ov = BigInt(0);
function Fv(n) {
  return n && typeof n.call == "function";
}
function Mv(n) {
  return n && typeof n.estimateGas == "function";
}
function ad(n) {
  return n && typeof n.resolveName == "function";
}
function Uv(n) {
  return n && typeof n.sendTransaction == "function";
}
function zv(n) {
  if (n != null) {
    if (ad(n)) return n;
    if (n.provider) return n.provider;
  }
}
var yy = class {
  #e;
  fragment;
  constructor(e, t, r) {
    if ((ee(this, { fragment: t }), t.inputs.length < r.length))
      throw new Error("too many arguments");
    let i = To(e.runner, "resolveName"),
      s = ad(i) ? i : null;
    this.#e = (function () {
      return d(this, null, function* () {
        let o = yield Promise.all(
          t.inputs.map((a, c) =>
            r[c] == null
              ? null
              : a.walkAsync(r[c], (l, h) =>
                  l === "address"
                    ? Array.isArray(h)
                      ? Promise.all(h.map((f) => Pt(f, s)))
                      : Pt(h, s)
                    : h
                )
          )
        );
        return e.interface.encodeFilterTopics(t, o);
      });
    })();
  }
  getTopicFilter() {
    return this.#e;
  }
};
function To(n, e) {
  return n == null
    ? null
    : typeof n[e] == "function"
    ? n
    : n.provider && typeof n.provider[e] == "function"
    ? n.provider
    : null;
}
function ko(n) {
  return n == null ? null : n.provider || null;
}
function cd(n, e) {
  return d(this, null, function* () {
    let t = lt.dereference(n, "overrides");
    x(typeof t == "object", "invalid overrides parameter", "overrides", n);
    let r = Es(t);
    return (
      x(
        r.to == null || (e || []).indexOf("to") >= 0,
        "cannot override to",
        "overrides.to",
        r.to
      ),
      x(
        r.data == null || (e || []).indexOf("data") >= 0,
        "cannot override data",
        "overrides.data",
        r.data
      ),
      r.from && (r.from = r.from),
      r
    );
  });
}
function Ay(n, e, t) {
  return d(this, null, function* () {
    let r = To(n, "resolveName"),
      i = ad(r) ? r : null;
    return yield Promise.all(
      e.map((s, o) =>
        s.walkAsync(
          t[o],
          (a, c) => ((c = lt.dereference(c, a)), a === "address" ? Pt(c, i) : c)
        )
      )
    );
  });
}
function $N(n) {
  let e = function (o) {
      return d(this, null, function* () {
        let a = yield cd(o, ["data"]);
        (a.to = yield n.getAddress()),
          a.from && (a.from = yield Pt(a.from, zv(n.runner)));
        let c = n.interface,
          u = Y(a.value || Ov, "overrides.value") === Ov,
          l = (a.data || "0x") === "0x";
        c.fallback &&
          !c.fallback.payable &&
          c.receive &&
          !l &&
          !u &&
          x(
            !1,
            "cannot send data to receive or send value to non-payable fallback",
            "overrides",
            o
          ),
          x(
            c.fallback || l,
            "cannot send data to receive-only contract",
            "overrides.data",
            a.data
          );
        let h = c.receive || (c.fallback && c.fallback.payable);
        return (
          x(
            h || u,
            "cannot send value to non-payable fallback",
            "overrides.value",
            a.value
          ),
          x(
            c.fallback || l,
            "cannot send data to receive-only contract",
            "overrides.data",
            a.data
          ),
          a
        );
      });
    },
    t = function (o) {
      return d(this, null, function* () {
        let a = To(n.runner, "call");
        R(
          Fv(a),
          "contract runner does not support calling",
          "UNSUPPORTED_OPERATION",
          { operation: "call" }
        );
        let c = yield e(o);
        try {
          return yield a.call(c);
        } catch (u) {
          throw co(u) && u.data ? n.interface.makeError(u.data, c) : u;
        }
      });
    },
    r = function (o) {
      return d(this, null, function* () {
        let a = n.runner;
        R(
          Uv(a),
          "contract runner does not support sending transactions",
          "UNSUPPORTED_OPERATION",
          { operation: "sendTransaction" }
        );
        let c = yield a.sendTransaction(yield e(o)),
          u = ko(n.runner);
        return new Co(n.interface, u, c);
      });
    },
    i = function (o) {
      return d(this, null, function* () {
        let a = To(n.runner, "estimateGas");
        return (
          R(
            Mv(a),
            "contract runner does not support gas estimation",
            "UNSUPPORTED_OPERATION",
            { operation: "estimateGas" }
          ),
          yield a.estimateGas(yield e(o))
        );
      });
    },
    s = (o) =>
      d(this, null, function* () {
        return yield r(o);
      });
  return (
    ee(s, {
      _contract: n,
      estimateGas: i,
      populateTransaction: e,
      send: r,
      staticCall: t,
    }),
    s
  );
}
function GN(n, e) {
  let t = function (...u) {
      let l = n.interface.getFunction(e, u);
      return (
        R(l, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key: e, args: u },
        }),
        l
      );
    },
    r = function (...u) {
      return d(this, null, function* () {
        let l = t(...u),
          h = {};
        if (
          (l.inputs.length + 1 === u.length &&
            ((h = yield cd(u.pop())),
            h.from && (h.from = yield Pt(h.from, zv(n.runner)))),
          l.inputs.length !== u.length)
        )
          throw new Error(
            "internal error: fragment inputs doesn't match arguments; should not happen"
          );
        let f = yield Ay(n.runner, l.inputs, u);
        return Object.assign(
          {},
          h,
          yield It({
            to: n.getAddress(),
            data: n.interface.encodeFunctionData(l, f),
          })
        );
      });
    },
    i = function (...u) {
      return d(this, null, function* () {
        let l = yield a(...u);
        return l.length === 1 ? l[0] : l;
      });
    },
    s = function (...u) {
      return d(this, null, function* () {
        let l = n.runner;
        R(
          Uv(l),
          "contract runner does not support sending transactions",
          "UNSUPPORTED_OPERATION",
          { operation: "sendTransaction" }
        );
        let h = yield l.sendTransaction(yield r(...u)),
          f = ko(n.runner);
        return new Co(n.interface, f, h);
      });
    },
    o = function (...u) {
      return d(this, null, function* () {
        let l = To(n.runner, "estimateGas");
        return (
          R(
            Mv(l),
            "contract runner does not support gas estimation",
            "UNSUPPORTED_OPERATION",
            { operation: "estimateGas" }
          ),
          yield l.estimateGas(yield r(...u))
        );
      });
    },
    a = function (...u) {
      return d(this, null, function* () {
        let l = To(n.runner, "call");
        R(
          Fv(l),
          "contract runner does not support calling",
          "UNSUPPORTED_OPERATION",
          { operation: "call" }
        );
        let h = yield r(...u),
          f = "0x";
        try {
          f = yield l.call(h);
        } catch (y) {
          throw co(y) && y.data ? n.interface.makeError(y.data, h) : y;
        }
        let g = t(...u);
        return n.interface.decodeFunctionResult(g, f);
      });
    },
    c = (...u) =>
      d(this, null, function* () {
        return t(...u).constant ? yield i(...u) : yield s(...u);
      });
  return (
    ee(c, {
      name: n.interface.getFunctionName(e),
      _contract: n,
      _key: e,
      getFragment: t,
      estimateGas: o,
      populateTransaction: r,
      send: s,
      staticCall: i,
      staticCallResult: a,
    }),
    Object.defineProperty(c, "fragment", {
      configurable: !1,
      enumerable: !0,
      get: () => {
        let u = n.interface.getFunction(e);
        return (
          R(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key: e },
          }),
          u
        );
      },
    }),
    c
  );
}
function KN(n, e) {
  let t = function (...i) {
      let s = n.interface.getEvent(e, i);
      return (
        R(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key: e, args: i },
        }),
        s
      );
    },
    r = function (...i) {
      return new yy(n, t(...i), i);
    };
  return (
    ee(r, {
      name: n.interface.getEventName(e),
      _contract: n,
      _key: e,
      getFragment: t,
    }),
    Object.defineProperty(r, "fragment", {
      configurable: !1,
      enumerable: !0,
      get: () => {
        let i = n.interface.getEvent(e);
        return (
          R(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key: e },
          }),
          i
        );
      },
    }),
    r
  );
}
var od = Symbol.for("_ethersInternal_contract"),
  jv = new WeakMap();
function qN(n, e) {
  jv.set(n[od], e);
}
function Zn(n) {
  return jv.get(n[od]);
}
function QN(n) {
  return (
    n &&
    typeof n == "object" &&
    "getTopicFilter" in n &&
    typeof n.getTopicFilter == "function" &&
    n.fragment
  );
}
function Ey(n, e) {
  return d(this, null, function* () {
    let t,
      r = null;
    if (Array.isArray(e)) {
      let s = function (o) {
        if (De(o, 32)) return o;
        let a = n.interface.getEvent(o);
        return x(a, "unknown fragment", "name", o), a.topicHash;
      };
      t = e.map((o) => (o == null ? null : Array.isArray(o) ? o.map(s) : s(o)));
    } else e === "*" ? (t = [null]) : typeof e == "string" ? (De(e, 32) ? (t = [e]) : ((r = n.interface.getEvent(e)), x(r, "unknown fragment", "event", e), (t = [r.topicHash]))) : QN(e) ? (t = yield e.getTopicFilter()) : "fragment" in e ? ((r = e.fragment), (t = [r.topicHash])) : x(!1, "unknown event name", "event", e);
    t = t.map((s) => {
      if (s == null) return null;
      if (Array.isArray(s)) {
        let o = Array.from(new Set(s.map((a) => a.toLowerCase())).values());
        return o.length === 1 ? o[0] : (o.sort(), o);
      }
      return s.toLowerCase();
    });
    let i = t
      .map((s) => (s == null ? "null" : Array.isArray(s) ? s.join("|") : s))
      .join("&");
    return { fragment: r, tag: i, topics: t };
  });
}
function Sl(n, e) {
  return d(this, null, function* () {
    let { subs: t } = Zn(n);
    return t.get((yield Ey(n, e)).tag) || null;
  });
}
function Nv(n, e, t) {
  return d(this, null, function* () {
    let r = ko(n.runner);
    R(
      r,
      "contract runner does not support subscribing",
      "UNSUPPORTED_OPERATION",
      { operation: e }
    );
    let { fragment: i, tag: s, topics: o } = yield Ey(n, t),
      { addr: a, subs: c } = Zn(n),
      u = c.get(s);
    if (!u) {
      let h = { address: a || n, topics: o },
        f = (m) => {
          let b = i;
          if (b == null)
            try {
              b = n.interface.getEvent(m.topics[0]);
            } catch {}
          if (b) {
            let I = b,
              E = i ? n.interface.decodeEventLog(i, m.data, m.topics) : [];
            by(n, t, E, (T) => new xl(n, T, t, I, m));
          } else by(n, t, [], (I) => new oc(n, I, t, m));
        },
        g = [];
      (u = {
        tag: s,
        listeners: [],
        start: () => {
          g.length || g.push(r.on(h, f));
        },
        stop: () =>
          d(this, null, function* () {
            if (g.length == 0) return;
            let m = g;
            (g = []), yield Promise.all(m), r.off(h, f);
          }),
      }),
        c.set(s, u);
    }
    return u;
  });
}
var wy = Promise.resolve();
function JN(n, e, t, r) {
  return d(this, null, function* () {
    yield wy;
    let i = yield Sl(n, e);
    if (!i) return !1;
    let s = i.listeners.length;
    return (
      (i.listeners = i.listeners.filter(({ listener: o, once: a }) => {
        let c = Array.from(t);
        r && c.push(r(a ? null : o));
        try {
          o.call(n, ...c);
        } catch {}
        return !a;
      })),
      i.listeners.length === 0 && (i.stop(), Zn(n).subs.delete(i.tag)),
      s > 0
    );
  });
}
function by(n, e, t, r) {
  return d(this, null, function* () {
    try {
      yield wy;
    } catch {}
    let i = JN(n, e, t, r);
    return (wy = i), yield i;
  });
}
var sd = ["then"],
  xs = class n {
    target;
    interface;
    runner;
    filters;
    [od];
    fallback;
    constructor(e, t, r, i) {
      x(
        typeof e == "string" || Lf(e),
        "invalid value for Contract target",
        "target",
        e
      ),
        r == null && (r = null);
      let s = So.from(t);
      ee(this, { target: e, runner: r, interface: s }),
        Object.defineProperty(this, od, { value: {} });
      let o,
        a = null,
        c = null;
      if (i) {
        let h = ko(r);
        c = new Co(this.interface, h, i);
      }
      let u = new Map();
      if (typeof e == "string")
        if (De(e)) (a = e), (o = Promise.resolve(e));
        else {
          let h = To(r, "resolveName");
          if (!ad(h))
            throw Ye(
              "contract runner does not support name resolution",
              "UNSUPPORTED_OPERATION",
              { operation: "resolveName" }
            );
          o = h.resolveName(e).then((f) => {
            if (f == null)
              throw Ye(
                "an ENS name used for a contract target must be correctly configured",
                "UNCONFIGURED_NAME",
                { value: e }
              );
            return (Zn(this).addr = f), f;
          });
        }
      else
        o = e.getAddress().then((h) => {
          if (h == null) throw new Error("TODO");
          return (Zn(this).addr = h), h;
        });
      qN(this, { addrPromise: o, addr: a, deployTx: c, subs: u });
      let l = new Proxy(
        {},
        {
          get: (h, f, g) => {
            if (typeof f == "symbol" || sd.indexOf(f) >= 0)
              return Reflect.get(h, f, g);
            try {
              return this.getEvent(f);
            } catch (y) {
              if (!ut(y, "INVALID_ARGUMENT") || y.argument !== "key") throw y;
            }
          },
          has: (h, f) =>
            sd.indexOf(f) >= 0
              ? Reflect.has(h, f)
              : Reflect.has(h, f) || this.interface.hasEvent(String(f)),
        }
      );
      return (
        ee(this, { filters: l }),
        ee(this, { fallback: s.receive || s.fallback ? $N(this) : null }),
        new Proxy(this, {
          get: (h, f, g) => {
            if (typeof f == "symbol" || f in h || sd.indexOf(f) >= 0)
              return Reflect.get(h, f, g);
            try {
              return h.getFunction(f);
            } catch (y) {
              if (!ut(y, "INVALID_ARGUMENT") || y.argument !== "key") throw y;
            }
          },
          has: (h, f) =>
            typeof f == "symbol" || f in h || sd.indexOf(f) >= 0
              ? Reflect.has(h, f)
              : h.interface.hasFunction(f),
        })
      );
    }
    connect(e) {
      return new n(this.target, this.interface, e);
    }
    attach(e) {
      return new n(e, this.interface, this.runner);
    }
    getAddress() {
      return d(this, null, function* () {
        return yield Zn(this).addrPromise;
      });
    }
    getDeployedCode() {
      return d(this, null, function* () {
        let e = ko(this.runner);
        R(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
          operation: "getDeployedCode",
        });
        let t = yield e.getCode(yield this.getAddress());
        return t === "0x" ? null : t;
      });
    }
    waitForDeployment() {
      return d(this, null, function* () {
        let e = this.deploymentTransaction();
        if (e) return yield e.wait(), this;
        if ((yield this.getDeployedCode()) != null) return this;
        let r = ko(this.runner);
        return (
          R(
            r != null,
            "contract runner does not support .provider",
            "UNSUPPORTED_OPERATION",
            { operation: "waitForDeployment" }
          ),
          new Promise((i, s) => {
            let o = () =>
              d(this, null, function* () {
                try {
                  if ((yield this.getDeployedCode()) != null) return i(this);
                  r.once("block", o);
                } catch (a) {
                  s(a);
                }
              });
            o();
          })
        );
      });
    }
    deploymentTransaction() {
      return Zn(this).deployTx;
    }
    getFunction(e) {
      return typeof e != "string" && (e = e.format()), GN(this, e);
    }
    getEvent(e) {
      return typeof e != "string" && (e = e.format()), KN(this, e);
    }
    queryTransaction(e) {
      return d(this, null, function* () {
        throw new Error("@TODO");
      });
    }
    queryFilter(e, t, r) {
      return d(this, null, function* () {
        t == null && (t = 0), r == null && (r = "latest");
        let { addr: i, addrPromise: s } = Zn(this),
          o = i || (yield s),
          { fragment: a, topics: c } = yield Ey(this, e),
          u = { address: o, topics: c, fromBlock: t, toBlock: r },
          l = ko(this.runner);
        return (
          R(
            l,
            "contract runner does not have a provider",
            "UNSUPPORTED_OPERATION",
            { operation: "queryFilter" }
          ),
          (yield l.getLogs(u)).map((h) => {
            let f = a;
            if (f == null)
              try {
                f = this.interface.getEvent(h.topics[0]);
              } catch {}
            if (f)
              try {
                return new Io(h, this.interface, f);
              } catch (g) {
                return new sc(h, g);
              }
            return new _r(h, l);
          })
        );
      });
    }
    on(e, t) {
      return d(this, null, function* () {
        let r = yield Nv(this, "on", e);
        return r.listeners.push({ listener: t, once: !1 }), r.start(), this;
      });
    }
    once(e, t) {
      return d(this, null, function* () {
        let r = yield Nv(this, "once", e);
        return r.listeners.push({ listener: t, once: !0 }), r.start(), this;
      });
    }
    emit(e, ...t) {
      return d(this, null, function* () {
        return yield by(this, e, t, null);
      });
    }
    listenerCount(e) {
      return d(this, null, function* () {
        if (e) {
          let i = yield Sl(this, e);
          return i ? i.listeners.length : 0;
        }
        let { subs: t } = Zn(this),
          r = 0;
        for (let { listeners: i } of t.values()) r += i.length;
        return r;
      });
    }
    listeners(e) {
      return d(this, null, function* () {
        if (e) {
          let i = yield Sl(this, e);
          return i ? i.listeners.map(({ listener: s }) => s) : [];
        }
        let { subs: t } = Zn(this),
          r = [];
        for (let { listeners: i } of t.values())
          r = r.concat(i.map(({ listener: s }) => s));
        return r;
      });
    }
    off(e, t) {
      return d(this, null, function* () {
        let r = yield Sl(this, e);
        if (!r) return this;
        if (t) {
          let i = r.listeners.map(({ listener: s }) => s).indexOf(t);
          i >= 0 && r.listeners.splice(i, 1);
        }
        return (
          (t == null || r.listeners.length === 0) &&
            (r.stop(), Zn(this).subs.delete(r.tag)),
          this
        );
      });
    }
    removeAllListeners(e) {
      return d(this, null, function* () {
        if (e) {
          let t = yield Sl(this, e);
          if (!t) return this;
          t.stop(), Zn(this).subs.delete(t.tag);
        } else {
          let { subs: t } = Zn(this);
          for (let { tag: r, stop: i } of t.values()) i(), t.delete(r);
        }
        return this;
      });
    }
    addListener(e, t) {
      return d(this, null, function* () {
        return yield this.on(e, t);
      });
    }
    removeListener(e, t) {
      return d(this, null, function* () {
        return yield this.off(e, t);
      });
    }
    static buildClass(e) {
      class t extends n {
        constructor(i, s = null) {
          super(i, e, s);
        }
      }
      return t;
    }
    static from(e, t, r) {
      return r == null && (r = null), new this(e, t, r);
    }
  };
function YN() {
  return xs;
}
var Pr = class extends YN() {};
p();
var ud = class n {
  interface;
  bytecode;
  runner;
  constructor(e, t, r) {
    let i = So.from(e);
    t instanceof Uint8Array
      ? (t = V(fe(t)))
      : (typeof t == "object" && (t = t.object),
        t.startsWith("0x") || (t = "0x" + t),
        (t = V(fe(t)))),
      ee(this, { bytecode: t, interface: i, runner: r || null });
  }
  attach(e) {
    return new xs(e, this.interface, this.runner);
  }
  getDeployTransaction(...e) {
    return d(this, null, function* () {
      let t = {},
        r = this.interface.deploy;
      if (
        (r.inputs.length + 1 === e.length && (t = yield cd(e.pop())),
        r.inputs.length !== e.length)
      )
        throw new Error("incorrect number of arguments to constructor");
      let i = yield Ay(this.runner, r.inputs, e),
        s = Fe([this.bytecode, this.interface.encodeDeploy(i)]);
      return Object.assign({}, t, { data: s });
    });
  }
  deploy(...e) {
    return d(this, null, function* () {
      let t = yield this.getDeployTransaction(...e);
      R(
        this.runner && typeof this.runner.sendTransaction == "function",
        "factory runner does not support sending transactions",
        "UNSUPPORTED_OPERATION",
        { operation: "sendTransaction" }
      );
      let r = yield this.runner.sendTransaction(t),
        i = ul(r);
      return new xs(i, this.interface, this.runner, r);
    });
  }
  connect(e) {
    return new n(this.interface, this.bytecode, e);
  }
  static fromSolidity(e, t) {
    x(e != null, "bad compiler output", "output", e),
      typeof e == "string" && (e = JSON.parse(e));
    let r = e.abi,
      i = "";
    return (
      e.bytecode
        ? (i = e.bytecode)
        : e.evm && e.evm.bytecode && (i = e.evm.bytecode),
      new this(r, i, t)
    );
  }
};
p();
p();
p();
function xy(n) {
  return (
    n.match(/^ipfs:\/\/ipfs\//i)
      ? (n = n.substring(12))
      : n.match(/^ipfs:\/\//i)
      ? (n = n.substring(7))
      : x(!1, "unsupported IPFS format", "link", n),
    `https://gateway.ipfs.io/ipfs/${n}`
  );
}
var ld = class {
  name;
  constructor(e) {
    ee(this, { name: e });
  }
  connect(e) {
    return this;
  }
  supportsCoinType(e) {
    return !1;
  }
  encodeAddress(e, t) {
    return d(this, null, function* () {
      throw new Error("unsupported coin");
    });
  }
  decodeAddress(e, t) {
    return d(this, null, function* () {
      throw new Error("unsupported coin");
    });
  }
};
var Hv = new RegExp("^(ipfs)://(.*)$", "i"),
  Wv = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    Hv,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
  ],
  ac = class n {
    provider;
    address;
    name;
    #e;
    #t;
    constructor(e, t, r) {
      ee(this, { provider: e, address: t, name: r }),
        (this.#e = null),
        (this.#t = new Pr(
          t,
          [
            "function supportsInterface(bytes4) view returns (bool)",
            "function resolve(bytes, bytes) view returns (bytes)",
            "function addr(bytes32) view returns (address)",
            "function addr(bytes32, uint) view returns (bytes)",
            "function text(bytes32, string) view returns (string)",
            "function contenthash(bytes32) view returns (bytes)",
          ],
          e
        ));
    }
    supportsWildcard() {
      return d(this, null, function* () {
        return (
          this.#e == null &&
            (this.#e = d(this, null, function* () {
              try {
                return yield this.#t.supportsInterface("0x9061b923");
              } catch (e) {
                if (ut(e, "CALL_EXCEPTION")) return !1;
                throw ((this.#e = null), e);
              }
            })),
          yield this.#e
        );
      });
    }
    #n(e, t) {
      return d(this, null, function* () {
        t = (t || []).slice();
        let r = this.#t.interface;
        t.unshift(ec(this.name));
        let i = null;
        (yield this.supportsWildcard()) &&
          ((i = r.getFunction(e)),
          R(i, "missing fragment", "UNKNOWN_ERROR", { info: { funcName: e } }),
          (t = [cy(this.name, 255), r.encodeFunctionData(i, t)]),
          (e = "resolve(bytes,bytes)")),
          t.push({ enableCcipRead: !0 });
        try {
          let s = yield this.#t[e](...t);
          return i ? r.decodeFunctionResult(i, s)[0] : s;
        } catch (s) {
          if (!ut(s, "CALL_EXCEPTION")) throw s;
        }
        return null;
      });
    }
    getAddress(e) {
      return d(this, null, function* () {
        if ((e == null && (e = 60), e === 60))
          try {
            let s = yield this.#n("addr(bytes32)");
            return s == null || s === Qr ? null : s;
          } catch (s) {
            if (ut(s, "CALL_EXCEPTION")) return null;
            throw s;
          }
        if (e >= 0 && e < 2147483648) {
          let s = e + 2147483648,
            o = yield this.#n("addr(bytes32,uint)", [s]);
          if (De(o, 20)) return ke(o);
        }
        let t = null;
        for (let s of this.provider.plugins)
          if (s instanceof ld && s.supportsCoinType(e)) {
            t = s;
            break;
          }
        if (t == null) return null;
        let r = yield this.#n("addr(bytes32,uint)", [e]);
        if (r == null || r === "0x") return null;
        let i = yield t.decodeAddress(e, r);
        if (i != null) return i;
        R(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
          operation: `getAddress(${e})`,
          info: { coinType: e, data: r },
        });
      });
    }
    getText(e) {
      return d(this, null, function* () {
        let t = yield this.#n("text(bytes32,string)", [e]);
        return t == null || t === "0x" ? null : t;
      });
    }
    getContentHash() {
      return d(this, null, function* () {
        let e = yield this.#n("contenthash(bytes32)");
        if (e == null || e === "0x") return null;
        let t = e.match(
          /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
        );
        if (t) {
          let i = t[1] === "e3010170" ? "ipfs" : "ipns",
            s = parseInt(t[4], 16);
          if (t[5].length === s * 2) return `${i}://${Cf("0x" + t[2])}`;
        }
        let r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (r && r[1].length === 64) return `bzz://${r[1]}`;
        R(
          !1,
          "invalid or unsupported content hash data",
          "UNSUPPORTED_OPERATION",
          { operation: "getContentHash()", info: { data: e } }
        );
      });
    }
    getAvatar() {
      return d(this, null, function* () {
        return (yield this._getAvatar()).url;
      });
    }
    _getAvatar() {
      return d(this, null, function* () {
        let e = [{ type: "name", value: this.name }];
        try {
          let t = yield this.getText("avatar");
          if (t == null)
            return (
              e.push({ type: "!avatar", value: "" }), { url: null, linkage: e }
            );
          e.push({ type: "avatar", value: t });
          for (let r = 0; r < Wv.length; r++) {
            let i = t.match(Wv[r]);
            if (i == null) continue;
            let s = i[1].toLowerCase();
            switch (s) {
              case "https":
              case "data":
                return (
                  e.push({ type: "url", value: t }), { linkage: e, url: t }
                );
              case "ipfs": {
                let o = xy(t);
                return (
                  e.push({ type: "ipfs", value: t }),
                  e.push({ type: "url", value: o }),
                  { linkage: e, url: o }
                );
              }
              case "erc721":
              case "erc1155": {
                let o = s === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
                e.push({ type: s, value: t });
                let a = yield this.getAddress();
                if (a == null)
                  return (
                    e.push({ type: "!owner", value: "" }),
                    { url: null, linkage: e }
                  );
                let c = (i[2] || "").split("/");
                if (c.length !== 2)
                  return (
                    e.push({ type: `!${s}caip`, value: i[2] || "" }),
                    { url: null, linkage: e }
                  );
                let u = c[1],
                  l = new Pr(
                    c[0],
                    [
                      "function tokenURI(uint) view returns (string)",
                      "function ownerOf(uint) view returns (address)",
                      "function uri(uint) view returns (string)",
                      "function balanceOf(address, uint256) view returns (uint)",
                    ],
                    this.provider
                  );
                if (s === "erc721") {
                  let w = yield l.ownerOf(u);
                  if (a !== w)
                    return (
                      e.push({ type: "!owner", value: w }),
                      { url: null, linkage: e }
                    );
                  e.push({ type: "owner", value: w });
                } else if (s === "erc1155") {
                  let w = yield l.balanceOf(a, u);
                  if (!w)
                    return (
                      e.push({ type: "!balance", value: "0" }),
                      { url: null, linkage: e }
                    );
                  e.push({ type: "balance", value: w.toString() });
                }
                let h = yield l[o](u);
                if (h == null || h === "0x")
                  return (
                    e.push({ type: "!metadata-url", value: "" }),
                    { url: null, linkage: e }
                  );
                e.push({ type: "metadata-url-base", value: h }),
                  s === "erc1155" &&
                    ((h = h.replace("{id}", vn(u, 32).substring(2))),
                    e.push({ type: "metadata-url-expanded", value: h })),
                  h.match(/^ipfs:/i) && (h = xy(h)),
                  e.push({ type: "metadata-url", value: h });
                let f = {},
                  g = yield new Jn(h).send();
                g.assertOk();
                try {
                  f = g.bodyJson;
                } catch {
                  try {
                    e.push({ type: "!metadata", value: g.bodyText });
                  } catch {
                    let b = g.body;
                    return (
                      b && e.push({ type: "!metadata", value: V(b) }),
                      { url: null, linkage: e }
                    );
                  }
                  return { url: null, linkage: e };
                }
                if (!f)
                  return (
                    e.push({ type: "!metadata", value: "" }),
                    { url: null, linkage: e }
                  );
                e.push({ type: "metadata", value: JSON.stringify(f) });
                let y = f.image;
                if (typeof y != "string")
                  return (
                    e.push({ type: "!imageUrl", value: "" }),
                    { url: null, linkage: e }
                  );
                if (!y.match(/^(https:\/\/|data:)/i)) {
                  if (y.match(Hv) == null)
                    return (
                      e.push({ type: "!imageUrl-ipfs", value: y }),
                      { url: null, linkage: e }
                    );
                  e.push({ type: "imageUrl-ipfs", value: y }), (y = xy(y));
                }
                return (
                  e.push({ type: "url", value: y }), { linkage: e, url: y }
                );
              }
            }
          }
        } catch {}
        return { linkage: e, url: null };
      });
    }
    static getEnsAddress(e) {
      return d(this, null, function* () {
        let t = yield e.getNetwork(),
          r = t.getPlugin("org.ethers.plugins.network.Ens");
        return (
          R(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
            operation: "getEnsAddress",
            info: { network: t },
          }),
          r.address
        );
      });
    }
    static #r(e, t) {
      return d(this, null, function* () {
        let r = yield n.getEnsAddress(e);
        try {
          let s = yield new Pr(
            r,
            ["function resolver(bytes32) view returns (address)"],
            e
          ).resolver(ec(t), { enableCcipRead: !0 });
          return s === Qr ? null : s;
        } catch (i) {
          throw i;
        }
        return null;
      });
    }
    static fromName(e, t) {
      return d(this, null, function* () {
        let r = t;
        for (;;) {
          if (r === "" || r === "." || (t !== "eth" && r === "eth"))
            return null;
          let i = yield n.#r(e, r);
          if (i != null) {
            let s = new n(e, i, t);
            return r !== t && !(yield s.supportsWildcard()) ? null : s;
          }
          r = r.split(".").slice(1).join(".");
        }
      });
    }
  };
p();
var Vv = BigInt(0);
function Me(n, e) {
  return function (t) {
    return t == null ? e : n(t);
  };
}
function hd(n, e) {
  return (t) => {
    if (e && t == null) return null;
    if (!Array.isArray(t)) throw new Error("not an array");
    return t.map((r) => n(r));
  };
}
function vl(n, e) {
  return (t) => {
    let r = {};
    for (let i in n) {
      let s = i;
      if (e && i in e && !(s in t)) {
        for (let o of e[i])
          if (o in t) {
            s = o;
            break;
          }
      }
      try {
        let o = n[i](t[s]);
        o !== void 0 && (r[i] = o);
      } catch (o) {
        let a = o instanceof Error ? o.message : "not-an-error";
        R(!1, `invalid value for value.${i} (${a})`, "BAD_DATA", { value: t });
      }
    }
    return r;
  };
}
function ZN(n) {
  switch (n) {
    case !0:
    case "true":
      return !0;
    case !1:
    case "false":
      return !1;
  }
  x(!1, `invalid boolean; ${JSON.stringify(n)}`, "value", n);
}
function cc(n) {
  return x(De(n, !0), "invalid data", "value", n), n;
}
function sn(n) {
  return x(De(n, 32), "invalid hash", "value", n), n;
}
var XN = vl(
  {
    address: ke,
    blockHash: sn,
    blockNumber: me,
    data: cc,
    index: me,
    removed: Me(ZN, !1),
    topics: hd(sn),
    transactionHash: sn,
    transactionIndex: me,
  },
  { index: ["logIndex"] }
);
function $v(n) {
  return XN(n);
}
var e8 = vl(
  {
    hash: Me(sn),
    parentHash: sn,
    parentBeaconBlockRoot: Me(sn, null),
    number: me,
    timestamp: me,
    nonce: Me(cc),
    difficulty: Y,
    gasLimit: Y,
    gasUsed: Y,
    stateRoot: Me(sn, null),
    receiptsRoot: Me(sn, null),
    blobGasUsed: Me(Y, null),
    excessBlobGas: Me(Y, null),
    miner: Me(ke),
    prevRandao: Me(sn, null),
    extraData: cc,
    baseFeePerGas: Me(Y),
  },
  { prevRandao: ["mixHash"] }
);
function Gv(n) {
  let e = e8(n);
  return (
    (e.transactions = n.transactions.map((t) =>
      typeof t == "string" ? t : Sy(t)
    )),
    e
  );
}
var t8 = vl(
  {
    transactionIndex: me,
    blockNumber: me,
    transactionHash: sn,
    address: ke,
    topics: hd(sn),
    data: cc,
    index: me,
    blockHash: sn,
  },
  { index: ["logIndex"] }
);
function n8(n) {
  return t8(n);
}
var r8 = vl(
  {
    to: Me(ke, null),
    from: Me(ke, null),
    contractAddress: Me(ke, null),
    index: me,
    root: Me(V),
    gasUsed: Y,
    blobGasUsed: Me(Y, null),
    logsBloom: Me(cc),
    blockHash: sn,
    hash: sn,
    logs: hd(n8),
    blockNumber: me,
    cumulativeGasUsed: Y,
    effectiveGasPrice: Me(Y),
    blobGasPrice: Me(Y, null),
    status: Me(me),
    type: Me(me, 0),
  },
  {
    effectiveGasPrice: ["gasPrice"],
    hash: ["transactionHash"],
    index: ["transactionIndex"],
  }
);
function Kv(n) {
  return r8(n);
}
function Sy(n) {
  n.to &&
    Y(n.to) === Vv &&
    (n.to = "0x0000000000000000000000000000000000000000");
  let e = vl(
    {
      hash: sn,
      index: Me(me, void 0),
      type: (t) => (t === "0x" || t == null ? 0 : me(t)),
      accessList: Me(Yn, null),
      blobVersionedHashes: Me(hd(sn, !0), null),
      blockHash: Me(sn, null),
      blockNumber: Me(me, null),
      transactionIndex: Me(me, null),
      from: ke,
      gasPrice: Me(Y),
      maxPriorityFeePerGas: Me(Y),
      maxFeePerGas: Me(Y),
      maxFeePerBlobGas: Me(Y, null),
      gasLimit: Y,
      to: Me(ke, null),
      value: Y,
      nonce: me,
      data: cc,
      creates: Me(ke, null),
      chainId: Me(Y, null),
    },
    { data: ["input"], gasLimit: ["gas"], index: ["transactionIndex"] }
  )(n);
  if (
    (e.to == null && e.creates == null && (e.creates = ul(e)),
    (n.type === 1 || n.type === 2) &&
      n.accessList == null &&
      (e.accessList = []),
    n.signature
      ? (e.signature = In.from(n.signature))
      : (e.signature = In.from(n)),
    e.chainId == null)
  ) {
    let t = e.signature.legacyChainId;
    t != null && (e.chainId = t);
  }
  return e.blockHash && Y(e.blockHash) === Vv && (e.blockHash = null), e;
}
p();
p();
var i8 = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  uc = class n {
    name;
    constructor(e) {
      ee(this, { name: e });
    }
    clone() {
      return new n(this.name);
    }
  },
  lc = class n extends uc {
    effectiveBlock;
    txBase;
    txCreate;
    txDataZero;
    txDataNonzero;
    txAccessListStorageKey;
    txAccessListAddress;
    constructor(e, t) {
      e == null && (e = 0),
        super(`org.ethers.network.plugins.GasCost#${e || 0}`);
      let r = { effectiveBlock: e };
      function i(s, o) {
        let a = (t || {})[s];
        a == null && (a = o),
          x(typeof a == "number", `invalud value for ${s}`, "costs", t),
          (r[s] = a);
      }
      i("txBase", 21e3),
        i("txCreate", 32e3),
        i("txDataZero", 4),
        i("txDataNonzero", 16),
        i("txAccessListStorageKey", 1900),
        i("txAccessListAddress", 2400),
        ee(this, r);
    }
    clone() {
      return new n(this.effectiveBlock, this);
    }
  },
  hc = class n extends uc {
    address;
    targetNetwork;
    constructor(e, t) {
      super("org.ethers.plugins.network.Ens"),
        ee(this, { address: e || i8, targetNetwork: t ?? 1 });
    }
    clone() {
      return new n(this.address, this.targetNetwork);
    }
  };
var Il = class extends uc {
  #e;
  #t;
  get url() {
    return this.#e;
  }
  get processFunc() {
    return this.#t;
  }
  constructor(e, t) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin"),
      (this.#e = e),
      (this.#t = t);
  }
  clone() {
    return this;
  }
};
var vy = new Map(),
  Xn = class n {
    #e;
    #t;
    #n;
    constructor(e, t) {
      (this.#e = e), (this.#t = Y(t)), (this.#n = new Map());
    }
    toJSON() {
      return { name: this.name, chainId: String(this.chainId) };
    }
    get name() {
      return this.#e;
    }
    set name(e) {
      this.#e = e;
    }
    get chainId() {
      return this.#t;
    }
    set chainId(e) {
      this.#t = Y(e, "chainId");
    }
    matches(e) {
      if (e == null) return !1;
      if (typeof e == "string") {
        try {
          return this.chainId === Y(e);
        } catch {}
        return this.name === e;
      }
      if (typeof e == "number" || typeof e == "bigint") {
        try {
          return this.chainId === Y(e);
        } catch {}
        return !1;
      }
      if (typeof e == "object") {
        if (e.chainId != null) {
          try {
            return this.chainId === Y(e.chainId);
          } catch {}
          return !1;
        }
        return e.name != null ? this.name === e.name : !1;
      }
      return !1;
    }
    get plugins() {
      return Array.from(this.#n.values());
    }
    attachPlugin(e) {
      if (this.#n.get(e.name))
        throw new Error(`cannot replace existing plugin: ${e.name} `);
      return this.#n.set(e.name, e.clone()), this;
    }
    getPlugin(e) {
      return this.#n.get(e) || null;
    }
    getPlugins(e) {
      return this.plugins.filter((t) => t.name.split("#")[0] === e);
    }
    clone() {
      let e = new n(this.name, this.chainId);
      return (
        this.plugins.forEach((t) => {
          e.attachPlugin(t.clone());
        }),
        e
      );
    }
    computeIntrinsicGas(e) {
      let t = this.getPlugin("org.ethers.plugins.network.GasCost") || new lc(),
        r = t.txBase;
      if ((e.to == null && (r += t.txCreate), e.data))
        for (let i = 2; i < e.data.length; i += 2)
          e.data.substring(i, i + 2) === "00"
            ? (r += t.txDataZero)
            : (r += t.txDataNonzero);
      if (e.accessList) {
        let i = Yn(e.accessList);
        for (let s in i)
          r +=
            t.txAccessListAddress +
            t.txAccessListStorageKey * i[s].storageKeys.length;
      }
      return r;
    }
    static from(e) {
      if ((s8(), e == null)) return n.from("mainnet");
      if (
        (typeof e == "number" && (e = BigInt(e)),
        typeof e == "string" || typeof e == "bigint")
      ) {
        let t = vy.get(e);
        if (t) return t();
        if (typeof e == "bigint") return new n("unknown", e);
        x(!1, "unknown network", "network", e);
      }
      if (typeof e.clone == "function") return e.clone();
      if (typeof e == "object") {
        x(
          typeof e.name == "string" && typeof e.chainId == "number",
          "invalid network object name or chainId",
          "network",
          e
        );
        let t = new n(e.name, e.chainId);
        return (
          (e.ensAddress || e.ensNetwork != null) &&
            t.attachPlugin(new hc(e.ensAddress, e.ensNetwork)),
          t
        );
      }
      x(!1, "invalid network", "network", e);
    }
    static register(e, t) {
      typeof e == "number" && (e = BigInt(e));
      let r = vy.get(e);
      r &&
        x(
          !1,
          `conflicting network for ${JSON.stringify(r.name)}`,
          "nameOrChainId",
          e
        ),
        vy.set(e, t);
    }
  };
function qv(n, e) {
  let t = String(n);
  if (!t.match(/^[0-9.]+$/)) throw new Error(`invalid gwei value: ${n}`);
  let r = t.split(".");
  if ((r.length === 1 && r.push(""), r.length !== 2))
    throw new Error(`invalid gwei value: ${n}`);
  for (; r[1].length < e; ) r[1] += "0";
  if (r[1].length > 9) {
    let i = BigInt(r[1].substring(0, 9));
    r[1].substring(9).match(/^0+$/) || i++, (r[1] = i.toString());
  }
  return BigInt(r[0] + r[1]);
}
function Qv(n) {
  return new Il(n, (e, t, r) =>
    d(this, null, function* () {
      r.setHeader("User-Agent", "ethers");
      let i;
      try {
        let [s, o] = yield Promise.all([r.send(), e()]);
        i = s;
        let a = i.bodyJson.standard;
        return {
          gasPrice: o.gasPrice,
          maxFeePerGas: qv(a.maxFee, 9),
          maxPriorityFeePerGas: qv(a.maxPriorityFee, 9),
        };
      } catch (s) {
        R(
          !1,
          `error encountered with polygon gas station (${JSON.stringify(
            r.url
          )})`,
          "SERVER_ERROR",
          { request: r, response: i, error: s }
        );
      }
    })
  );
}
var Jv = !1;
function s8() {
  if (Jv) return;
  Jv = !0;
  function n(e, t, r) {
    let i = function () {
      let s = new Xn(e, t);
      return (
        r.ensNetwork != null && s.attachPlugin(new hc(null, r.ensNetwork)),
        s.attachPlugin(new lc()),
        (r.plugins || []).forEach((o) => {
          s.attachPlugin(o);
        }),
        s
      );
    };
    Xn.register(e, i),
      Xn.register(t, i),
      r.altNames &&
        r.altNames.forEach((s) => {
          Xn.register(s, i);
        });
  }
  n("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }),
    n("ropsten", 3, { ensNetwork: 3 }),
    n("rinkeby", 4, { ensNetwork: 4 }),
    n("goerli", 5, { ensNetwork: 5 }),
    n("kovan", 42, { ensNetwork: 42 }),
    n("sepolia", 11155111, { ensNetwork: 11155111 }),
    n("holesky", 17e3, { ensNetwork: 17e3 }),
    n("classic", 61, {}),
    n("classicKotti", 6, {}),
    n("arbitrum", 42161, { ensNetwork: 1 }),
    n("arbitrum-goerli", 421613, {}),
    n("arbitrum-sepolia", 421614, {}),
    n("base", 8453, { ensNetwork: 1 }),
    n("base-goerli", 84531, {}),
    n("base-sepolia", 84532, {}),
    n("bnb", 56, { ensNetwork: 1 }),
    n("bnbt", 97, {}),
    n("linea", 59144, { ensNetwork: 1 }),
    n("linea-goerli", 59140, {}),
    n("linea-sepolia", 59141, {}),
    n("matic", 137, {
      ensNetwork: 1,
      plugins: [Qv("https://gasstation.polygon.technology/v2")],
    }),
    n("matic-amoy", 80002, {}),
    n("matic-mumbai", 80001, {
      altNames: ["maticMumbai", "maticmum"],
      plugins: [Qv("https://gasstation-testnet.polygon.technology/v2")],
    }),
    n("optimism", 10, { ensNetwork: 1, plugins: [] }),
    n("optimism-goerli", 420, {}),
    n("optimism-sepolia", 11155420, {}),
    n("xdai", 100, { ensNetwork: 1 });
}
p();
function Iy(n) {
  return JSON.parse(JSON.stringify(n));
}
var fd = class {
    #e;
    #t;
    #n;
    #r;
    constructor(e) {
      (this.#e = e), (this.#t = null), (this.#n = 4e3), (this.#r = -2);
    }
    get pollingInterval() {
      return this.#n;
    }
    set pollingInterval(e) {
      this.#n = e;
    }
    #i() {
      return d(this, null, function* () {
        try {
          let e = yield this.#e.getBlockNumber();
          if (this.#r === -2) {
            this.#r = e;
            return;
          }
          if (e !== this.#r) {
            for (let t = this.#r + 1; t <= e; t++) {
              if (this.#t == null) return;
              yield this.#e.emit("block", t);
            }
            this.#r = e;
          }
        } catch {}
        this.#t != null &&
          (this.#t = this.#e._setTimeout(this.#i.bind(this), this.#n));
      });
    }
    start() {
      this.#t ||
        ((this.#t = this.#e._setTimeout(this.#i.bind(this), this.#n)),
        this.#i());
    }
    stop() {
      this.#t && (this.#e._clearTimeout(this.#t), (this.#t = null));
    }
    pause(e) {
      this.stop(), e && (this.#r = -2);
    }
    resume() {
      this.start();
    }
  },
  Cl = class {
    #e;
    #t;
    #n;
    constructor(e) {
      (this.#e = e),
        (this.#n = !1),
        (this.#t = (t) => {
          this._poll(t, this.#e);
        });
    }
    _poll(e, t) {
      return d(this, null, function* () {
        throw new Error("sub-classes must override this");
      });
    }
    start() {
      this.#n || ((this.#n = !0), this.#t(-2), this.#e.on("block", this.#t));
    }
    stop() {
      this.#n && ((this.#n = !1), this.#e.off("block", this.#t));
    }
    pause(e) {
      this.stop();
    }
    resume() {
      this.start();
    }
  },
  dd = class extends Cl {
    #e;
    #t;
    constructor(e, t) {
      super(e), (this.#e = t), (this.#t = -2);
    }
    pause(e) {
      e && (this.#t = -2), super.pause(e);
    }
    _poll(e, t) {
      return d(this, null, function* () {
        let r = yield t.getBlock(this.#e);
        r != null &&
          (this.#t === -2
            ? (this.#t = r.number)
            : r.number > this.#t &&
              (t.emit(this.#e, r.number), (this.#t = r.number)));
      });
    }
  },
  pd = class extends Cl {
    #e;
    constructor(e, t) {
      super(e), (this.#e = Iy(t));
    }
    _poll(e, t) {
      return d(this, null, function* () {
        throw new Error("@TODO");
      });
    }
  },
  gd = class extends Cl {
    #e;
    constructor(e, t) {
      super(e), (this.#e = t);
    }
    _poll(e, t) {
      return d(this, null, function* () {
        let r = yield t.getTransactionReceipt(this.#e);
        r && t.emit(this.#e, r);
      });
    }
  },
  Ss = class {
    #e;
    #t;
    #n;
    #r;
    #i;
    constructor(e, t) {
      (this.#e = e),
        (this.#t = Iy(t)),
        (this.#n = this.#o.bind(this)),
        (this.#r = !1),
        (this.#i = -2);
    }
    #o(e) {
      return d(this, null, function* () {
        if (this.#i === -2) return;
        let t = Iy(this.#t);
        (t.fromBlock = this.#i + 1), (t.toBlock = e);
        let r = yield this.#e.getLogs(t);
        if (r.length === 0) {
          this.#i < e - 60 && (this.#i = e - 60);
          return;
        }
        for (let i of r) this.#e.emit(this.#t, i), (this.#i = i.blockNumber);
      });
    }
    start() {
      this.#r ||
        ((this.#r = !0),
        this.#i === -2 &&
          this.#e.getBlockNumber().then((e) => {
            this.#i = e;
          }),
        this.#e.on("block", this.#n));
    }
    stop() {
      this.#r && ((this.#r = !1), this.#e.off("block", this.#n));
    }
    pause(e) {
      this.stop(), e && (this.#i = -2);
    }
    resume() {
      this.start();
    }
  };
var o8 = BigInt(2),
  a8 = 10;
function md(n) {
  return n && typeof n.then == "function";
}
function yd(n, e) {
  return (
    n +
    ":" +
    JSON.stringify(e, (t, r) => {
      if (r == null) return "null";
      if (typeof r == "bigint") return `bigint:${r.toString()}`;
      if (typeof r == "string") return r.toLowerCase();
      if (typeof r == "object" && !Array.isArray(r)) {
        let i = Object.keys(r);
        return i.sort(), i.reduce((s, o) => ((s[o] = r[o]), s), {});
      }
      return r;
    })
  );
}
var fc = class {
  name;
  constructor(e) {
    ee(this, { name: e });
  }
  start() {}
  stop() {}
  pause(e) {}
  resume() {}
};
function c8(n) {
  return JSON.parse(JSON.stringify(n));
}
function Ty(n) {
  return (n = Array.from(new Set(n).values())), n.sort(), n;
}
function Cy(n, e) {
  return d(this, null, function* () {
    if (n == null) throw new Error("invalid event");
    if ((Array.isArray(n) && (n = { topics: n }), typeof n == "string"))
      switch (n) {
        case "block":
        case "debug":
        case "error":
        case "finalized":
        case "network":
        case "pending":
        case "safe":
          return { type: n, tag: n };
      }
    if (De(n, 32)) {
      let t = n.toLowerCase();
      return { type: "transaction", tag: yd("tx", { hash: t }), hash: t };
    }
    if (n.orphan) {
      let t = n;
      return { type: "orphan", tag: yd("orphan", t), filter: c8(t) };
    }
    if (n.address || n.topics) {
      let t = n,
        r = {
          topics: (t.topics || []).map((i) =>
            i == null
              ? null
              : Array.isArray(i)
              ? Ty(i.map((s) => s.toLowerCase()))
              : i.toLowerCase()
          ),
        };
      if (t.address) {
        let i = [],
          s = [],
          o = (a) => {
            De(a)
              ? i.push(a)
              : s.push(
                  d(this, null, function* () {
                    i.push(yield Pt(a, e));
                  })
                );
          };
        Array.isArray(t.address) ? t.address.forEach(o) : o(t.address),
          s.length && (yield Promise.all(s)),
          (r.address = Ty(i.map((a) => a.toLowerCase())));
      }
      return { filter: r, tag: yd("event", r), type: "event" };
    }
    x(!1, "unknown ProviderEvent", "event", n);
  });
}
function ky() {
  return new Date().getTime();
}
var u8 = { cacheTimeout: 250, pollingInterval: 4e3 },
  kl = class {
    #e;
    #t;
    #n;
    #r;
    #i;
    #o;
    #s;
    #a;
    #h;
    #u;
    #p;
    #g;
    constructor(e, t) {
      if (((this.#g = Object.assign({}, u8, t || {})), e === "any"))
        (this.#o = !0), (this.#i = null);
      else if (e) {
        let r = Xn.from(e);
        (this.#o = !1),
          (this.#i = Promise.resolve(r)),
          setTimeout(() => {
            this.emit("network", r, null);
          }, 0);
      } else (this.#o = !1), (this.#i = null);
      (this.#a = -1),
        (this.#s = new Map()),
        (this.#e = new Map()),
        (this.#t = new Map()),
        (this.#n = null),
        (this.#r = !1),
        (this.#h = 1),
        (this.#u = new Map()),
        (this.#p = !1);
    }
    get pollingInterval() {
      return this.#g.pollingInterval;
    }
    get provider() {
      return this;
    }
    get plugins() {
      return Array.from(this.#t.values());
    }
    attachPlugin(e) {
      if (this.#t.get(e.name))
        throw new Error(`cannot replace existing plugin: ${e.name} `);
      return this.#t.set(e.name, e.connect(this)), this;
    }
    getPlugin(e) {
      return this.#t.get(e) || null;
    }
    get disableCcipRead() {
      return this.#p;
    }
    set disableCcipRead(e) {
      this.#p = !!e;
    }
    #c(e) {
      return d(this, null, function* () {
        let t = this.#g.cacheTimeout;
        if (t < 0) return yield this._perform(e);
        let r = yd(e.method, e),
          i = this.#s.get(r);
        return (
          i ||
            ((i = this._perform(e)),
            this.#s.set(r, i),
            setTimeout(() => {
              this.#s.get(r) === i && this.#s.delete(r);
            }, t)),
          yield i
        );
      });
    }
    ccipReadFetch(e, t, r) {
      return d(this, null, function* () {
        if (this.disableCcipRead || r.length === 0 || e.to == null) return null;
        let i = e.to.toLowerCase(),
          s = t.toLowerCase(),
          o = [];
        for (let a = 0; a < r.length; a++) {
          let c = r[a],
            u = c.replace("{sender}", i).replace("{data}", s),
            l = new Jn(u);
          c.indexOf("{data}") === -1 && (l.body = { data: s, sender: i }),
            this.emit("debug", {
              action: "sendCcipReadFetchRequest",
              request: l,
              index: a,
              urls: r,
            });
          let h = "unknown error",
            f;
          try {
            f = yield l.send();
          } catch (g) {
            o.push(g.message),
              this.emit("debug", {
                action: "receiveCcipReadFetchError",
                request: l,
                result: { error: g },
              });
            continue;
          }
          try {
            let g = f.bodyJson;
            if (g.data)
              return (
                this.emit("debug", {
                  action: "receiveCcipReadFetchResult",
                  request: l,
                  result: g,
                }),
                g.data
              );
            g.message && (h = g.message),
              this.emit("debug", {
                action: "receiveCcipReadFetchError",
                request: l,
                result: g,
              });
          } catch {}
          R(
            f.statusCode < 400 || f.statusCode >= 500,
            `response not found during CCIP fetch: ${h}`,
            "OFFCHAIN_FAULT",
            {
              reason: "404_MISSING_RESOURCE",
              transaction: e,
              info: { url: c, errorMessage: h },
            }
          ),
            o.push(h);
        }
        R(
          !1,
          `error encountered during CCIP fetch: ${o
            .map((a) => JSON.stringify(a))
            .join(", ")}`,
          "OFFCHAIN_FAULT",
          {
            reason: "500_SERVER_ERROR",
            transaction: e,
            info: { urls: r, errorMessages: o },
          }
        );
      });
    }
    _wrapBlock(e, t) {
      return new El(Gv(e), this);
    }
    _wrapLog(e, t) {
      return new _r($v(e), this);
    }
    _wrapTransactionReceipt(e, t) {
      return new vo(Kv(e), this);
    }
    _wrapTransactionResponse(e, t) {
      return new As(Sy(e), this);
    }
    _detectNetwork() {
      R(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
        operation: "_detectNetwork",
      });
    }
    _perform(e) {
      return d(this, null, function* () {
        R(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
          operation: e.method,
          info: e,
        });
      });
    }
    getBlockNumber() {
      return d(this, null, function* () {
        let e = me(yield this.#c({ method: "getBlockNumber" }), "%response");
        return this.#a >= 0 && (this.#a = e), e;
      });
    }
    _getAddress(e) {
      return Pt(e, this);
    }
    _getBlockTag(e) {
      if (e == null) return "latest";
      switch (e) {
        case "earliest":
          return "0x0";
        case "finalized":
        case "latest":
        case "pending":
        case "safe":
          return e;
      }
      if (De(e)) return De(e, 32) ? e : Ir(e);
      if (
        (typeof e == "bigint" && (e = me(e, "blockTag")), typeof e == "number")
      )
        return e >= 0
          ? Ir(e)
          : this.#a >= 0
          ? Ir(this.#a + e)
          : this.getBlockNumber().then((t) => Ir(t + e));
      x(!1, "invalid blockTag", "blockTag", e);
    }
    _getFilter(e) {
      let t = (e.topics || []).map((c) =>
          c == null
            ? null
            : Array.isArray(c)
            ? Ty(c.map((u) => u.toLowerCase()))
            : c.toLowerCase()
        ),
        r = "blockHash" in e ? e.blockHash : void 0,
        i = (c, u, l) => {
          let h;
          switch (c.length) {
            case 0:
              break;
            case 1:
              h = c[0];
              break;
            default:
              c.sort(), (h = c);
          }
          if (r && (u != null || l != null)) throw new Error("invalid filter");
          let f = {};
          return (
            h && (f.address = h),
            t.length && (f.topics = t),
            u && (f.fromBlock = u),
            l && (f.toBlock = l),
            r && (f.blockHash = r),
            f
          );
        },
        s = [];
      if (e.address)
        if (Array.isArray(e.address))
          for (let c of e.address) s.push(this._getAddress(c));
        else s.push(this._getAddress(e.address));
      let o;
      "fromBlock" in e && (o = this._getBlockTag(e.fromBlock));
      let a;
      return (
        "toBlock" in e && (a = this._getBlockTag(e.toBlock)),
        s.filter((c) => typeof c != "string").length ||
        (o != null && typeof o != "string") ||
        (a != null && typeof a != "string")
          ? Promise.all([Promise.all(s), o, a]).then((c) => i(c[0], c[1], c[2]))
          : i(s, o, a)
      );
    }
    _getTransactionRequest(e) {
      let t = Es(e),
        r = [];
      if (
        (["to", "from"].forEach((i) => {
          if (t[i] == null) return;
          let s = Pt(t[i], this);
          md(s)
            ? r.push(
                (function () {
                  return d(this, null, function* () {
                    t[i] = yield s;
                  });
                })()
              )
            : (t[i] = s);
        }),
        t.blockTag != null)
      ) {
        let i = this._getBlockTag(t.blockTag);
        md(i)
          ? r.push(
              (function () {
                return d(this, null, function* () {
                  t.blockTag = yield i;
                });
              })()
            )
          : (t.blockTag = i);
      }
      return r.length
        ? (function () {
            return d(this, null, function* () {
              return yield Promise.all(r), t;
            });
          })()
        : t;
    }
    getNetwork() {
      return d(this, null, function* () {
        if (this.#i == null) {
          let i = d(this, null, function* () {
            try {
              let s = yield this._detectNetwork();
              return this.emit("network", s, null), s;
            } catch (s) {
              throw (this.#i === i && (this.#i = null), s);
            }
          });
          return (this.#i = i), (yield i).clone();
        }
        let e = this.#i,
          [t, r] = yield Promise.all([e, this._detectNetwork()]);
        return (
          t.chainId !== r.chainId &&
            (this.#o
              ? (this.emit("network", r, t),
                this.#i === e && (this.#i = Promise.resolve(r)))
              : R(
                  !1,
                  `network changed: ${t.chainId} => ${r.chainId} `,
                  "NETWORK_ERROR",
                  { event: "changed" }
                )),
          t.clone()
        );
      });
    }
    getFeeData() {
      return d(this, null, function* () {
        let e = yield this.getNetwork(),
          t = () =>
            d(this, null, function* () {
              let {
                  _block: i,
                  gasPrice: s,
                  priorityFee: o,
                } = yield It({
                  _block: this.#m("latest", !1),
                  gasPrice: d(this, null, function* () {
                    try {
                      let l = yield this.#c({ method: "getGasPrice" });
                      return Y(l, "%response");
                    } catch {}
                    return null;
                  }),
                  priorityFee: d(this, null, function* () {
                    try {
                      let l = yield this.#c({ method: "getPriorityFee" });
                      return Y(l, "%response");
                    } catch {}
                    return null;
                  }),
                }),
                a = null,
                c = null,
                u = this._wrapBlock(i, e);
              return (
                u &&
                  u.baseFeePerGas &&
                  ((c = o ?? BigInt("1000000000")),
                  (a = u.baseFeePerGas * o8 + c)),
                new ic(s, a, c)
              );
            }),
          r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        if (r) {
          let i = new Jn(r.url),
            s = yield r.processFunc(t, this, i);
          return new ic(s.gasPrice, s.maxFeePerGas, s.maxPriorityFeePerGas);
        }
        return yield t();
      });
    }
    estimateGas(e) {
      return d(this, null, function* () {
        let t = this._getTransactionRequest(e);
        return (
          md(t) && (t = yield t),
          Y(
            yield this.#c({ method: "estimateGas", transaction: t }),
            "%response"
          )
        );
      });
    }
    #l(e, t, r) {
      return d(this, null, function* () {
        R(r < a8, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
          reason: "TOO_MANY_REDIRECTS",
          transaction: Object.assign({}, e, {
            blockTag: t,
            enableCcipRead: !0,
          }),
        });
        let i = Es(e);
        try {
          return V(
            yield this._perform({ method: "call", transaction: i, blockTag: t })
          );
        } catch (s) {
          if (
            !this.disableCcipRead &&
            co(s) &&
            s.data &&
            r >= 0 &&
            t === "latest" &&
            i.to != null &&
            at(s.data, 0, 4) === "0x556f1830"
          ) {
            let o = s.data,
              a = yield Pt(i.to, this),
              c;
            try {
              c = p8(at(s.data, 4));
            } catch (h) {
              R(!1, h.message, "OFFCHAIN_FAULT", {
                reason: "BAD_DATA",
                transaction: i,
                info: { data: o },
              });
            }
            R(
              c.sender.toLowerCase() === a.toLowerCase(),
              "CCIP Read sender mismatch",
              "CALL_EXCEPTION",
              {
                action: "call",
                data: o,
                reason: "OffchainLookup",
                transaction: i,
                invocation: null,
                revert: {
                  signature:
                    "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  name: "OffchainLookup",
                  args: c.errorArgs,
                },
              }
            );
            let u = yield this.ccipReadFetch(i, c.calldata, c.urls);
            R(u != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
              reason: "FETCH_FAILED",
              transaction: i,
              info: { data: s.data, errorArgs: c.errorArgs },
            });
            let l = { to: a, data: Fe([c.selector, d8([u, c.extraData])]) };
            this.emit("debug", { action: "sendCcipReadCall", transaction: l });
            try {
              let h = yield this.#l(l, t, r + 1);
              return (
                this.emit("debug", {
                  action: "receiveCcipReadCallResult",
                  transaction: Object.assign({}, l),
                  result: h,
                }),
                h
              );
            } catch (h) {
              throw (
                (this.emit("debug", {
                  action: "receiveCcipReadCallError",
                  transaction: Object.assign({}, l),
                  error: h,
                }),
                h)
              );
            }
          }
          throw s;
        }
      });
    }
    #f(e) {
      return d(this, null, function* () {
        let { value: t } = yield It({ network: this.getNetwork(), value: e });
        return t;
      });
    }
    call(e) {
      return d(this, null, function* () {
        let { tx: t, blockTag: r } = yield It({
          tx: this._getTransactionRequest(e),
          blockTag: this._getBlockTag(e.blockTag),
        });
        return yield this.#f(this.#l(t, r, e.enableCcipRead ? 0 : -1));
      });
    }
    #d(e, t, r) {
      return d(this, null, function* () {
        let i = this._getAddress(t),
          s = this._getBlockTag(r);
        return (
          (typeof i != "string" || typeof s != "string") &&
            ([i, s] = yield Promise.all([i, s])),
          yield this.#f(this.#c(Object.assign(e, { address: i, blockTag: s })))
        );
      });
    }
    getBalance(e, t) {
      return d(this, null, function* () {
        return Y(yield this.#d({ method: "getBalance" }, e, t), "%response");
      });
    }
    getTransactionCount(e, t) {
      return d(this, null, function* () {
        return me(
          yield this.#d({ method: "getTransactionCount" }, e, t),
          "%response"
        );
      });
    }
    getCode(e, t) {
      return d(this, null, function* () {
        return V(yield this.#d({ method: "getCode" }, e, t));
      });
    }
    getStorage(e, t, r) {
      return d(this, null, function* () {
        let i = Y(t, "position");
        return V(yield this.#d({ method: "getStorage", position: i }, e, r));
      });
    }
    broadcastTransaction(e) {
      return d(this, null, function* () {
        let {
            blockNumber: t,
            hash: r,
            network: i,
          } = yield It({
            blockNumber: this.getBlockNumber(),
            hash: this._perform({
              method: "broadcastTransaction",
              signedTransaction: e,
            }),
            network: this.getNetwork(),
          }),
          s = yo.from(e);
        if (s.hash !== r)
          throw new Error("@TODO: the returned hash did not match");
        return this._wrapTransactionResponse(s, i).replaceableTransaction(t);
      });
    }
    #m(e, t) {
      return d(this, null, function* () {
        if (De(e, 32))
          return yield this.#c({
            method: "getBlock",
            blockHash: e,
            includeTransactions: t,
          });
        let r = this._getBlockTag(e);
        return (
          typeof r != "string" && (r = yield r),
          yield this.#c({
            method: "getBlock",
            blockTag: r,
            includeTransactions: t,
          })
        );
      });
    }
    getBlock(e, t) {
      return d(this, null, function* () {
        let { network: r, params: i } = yield It({
          network: this.getNetwork(),
          params: this.#m(e, !!t),
        });
        return i == null ? null : this._wrapBlock(i, r);
      });
    }
    getTransaction(e) {
      return d(this, null, function* () {
        let { network: t, params: r } = yield It({
          network: this.getNetwork(),
          params: this.#c({ method: "getTransaction", hash: e }),
        });
        return r == null ? null : this._wrapTransactionResponse(r, t);
      });
    }
    getTransactionReceipt(e) {
      return d(this, null, function* () {
        let { network: t, params: r } = yield It({
          network: this.getNetwork(),
          params: this.#c({ method: "getTransactionReceipt", hash: e }),
        });
        if (r == null) return null;
        if (r.gasPrice == null && r.effectiveGasPrice == null) {
          let i = yield this.#c({ method: "getTransaction", hash: e });
          if (i == null)
            throw new Error(
              "report this; could not find tx or effectiveGasPrice"
            );
          r.effectiveGasPrice = i.gasPrice;
        }
        return this._wrapTransactionReceipt(r, t);
      });
    }
    getTransactionResult(e) {
      return d(this, null, function* () {
        let { result: t } = yield It({
          network: this.getNetwork(),
          result: this.#c({ method: "getTransactionResult", hash: e }),
        });
        return t == null ? null : V(t);
      });
    }
    getLogs(e) {
      return d(this, null, function* () {
        let t = this._getFilter(e);
        md(t) && (t = yield t);
        let { network: r, params: i } = yield It({
          network: this.getNetwork(),
          params: this.#c({ method: "getLogs", filter: t }),
        });
        return i.map((s) => this._wrapLog(s, r));
      });
    }
    _getProvider(e) {
      R(
        !1,
        "provider cannot connect to target network",
        "UNSUPPORTED_OPERATION",
        { operation: "_getProvider()" }
      );
    }
    getResolver(e) {
      return d(this, null, function* () {
        return yield ac.fromName(this, e);
      });
    }
    getAvatar(e) {
      return d(this, null, function* () {
        let t = yield this.getResolver(e);
        return t ? yield t.getAvatar() : null;
      });
    }
    resolveName(e) {
      return d(this, null, function* () {
        let t = yield this.getResolver(e);
        return t ? yield t.getAddress() : null;
      });
    }
    lookupAddress(e) {
      return d(this, null, function* () {
        e = ke(e);
        let t = ec(e.substring(2).toLowerCase() + ".addr.reverse");
        try {
          let r = yield ac.getEnsAddress(this),
            s = yield new Pr(
              r,
              ["function resolver(bytes32) view returns (address)"],
              this
            ).resolver(t);
          if (s == null || s === Qr) return null;
          let a = yield new Pr(
            s,
            ["function name(bytes32) view returns (string)"],
            this
          ).name(t);
          return (yield this.resolveName(a)) !== e ? null : a;
        } catch (r) {
          if (
            (ut(r, "BAD_DATA") && r.value === "0x") ||
            ut(r, "CALL_EXCEPTION")
          )
            return null;
          throw r;
        }
        return null;
      });
    }
    waitForTransaction(e, t, r) {
      return d(this, null, function* () {
        let i = t ?? 1;
        return i === 0
          ? this.getTransactionReceipt(e)
          : new Promise((s, o) =>
              d(this, null, function* () {
                let a = null,
                  c = (u) =>
                    d(this, null, function* () {
                      try {
                        let l = yield this.getTransactionReceipt(e);
                        if (l != null && u - l.blockNumber + 1 >= i) {
                          s(l), a && (clearTimeout(a), (a = null));
                          return;
                        }
                      } catch (l) {
                        console.log("EEE", l);
                      }
                      this.once("block", c);
                    });
                r != null &&
                  (a = setTimeout(() => {
                    a != null &&
                      ((a = null),
                      this.off("block", c),
                      o(Ye("timeout", "TIMEOUT", { reason: "timeout" })));
                  }, r)),
                  c(yield this.getBlockNumber());
              })
            );
      });
    }
    waitForBlock(e) {
      return d(this, null, function* () {
        R(!1, "not implemented yet", "NOT_IMPLEMENTED", {
          operation: "waitForBlock",
        });
      });
    }
    _clearTimeout(e) {
      let t = this.#u.get(e);
      t && (t.timer && clearTimeout(t.timer), this.#u.delete(e));
    }
    _setTimeout(e, t) {
      t == null && (t = 0);
      let r = this.#h++,
        i = () => {
          this.#u.delete(r), e();
        };
      if (this.paused) this.#u.set(r, { timer: null, func: i, time: t });
      else {
        let s = setTimeout(i, t);
        this.#u.set(r, { timer: s, func: i, time: ky() });
      }
      return r;
    }
    _forEachSubscriber(e) {
      for (let t of this.#e.values()) e(t.subscriber);
    }
    _getSubscriber(e) {
      switch (e.type) {
        case "debug":
        case "error":
        case "network":
          return new fc(e.type);
        case "block": {
          let t = new fd(this);
          return (t.pollingInterval = this.pollingInterval), t;
        }
        case "safe":
        case "finalized":
          return new dd(this, e.type);
        case "event":
          return new Ss(this, e.filter);
        case "transaction":
          return new gd(this, e.hash);
        case "orphan":
          return new pd(this, e.filter);
      }
      throw new Error(`unsupported event: ${e.type}`);
    }
    _recoverSubscriber(e, t) {
      for (let r of this.#e.values())
        if (r.subscriber === e) {
          r.started && r.subscriber.stop(),
            (r.subscriber = t),
            r.started && t.start(),
            this.#n != null && t.pause(this.#n);
          break;
        }
    }
    #y(e, t) {
      return d(this, null, function* () {
        let r = yield Cy(e, this);
        return (
          r.type === "event" &&
            t &&
            t.length > 0 &&
            t[0].removed === !0 &&
            (r = yield Cy({ orphan: "drop-log", log: t[0] }, this)),
          this.#e.get(r.tag) || null
        );
      });
    }
    #w(e) {
      return d(this, null, function* () {
        let t = yield Cy(e, this),
          r = t.tag,
          i = this.#e.get(r);
        return (
          i ||
            ((i = {
              subscriber: this._getSubscriber(t),
              tag: r,
              addressableMap: new WeakMap(),
              nameMap: new Map(),
              started: !1,
              listeners: [],
            }),
            this.#e.set(r, i)),
          i
        );
      });
    }
    on(e, t) {
      return d(this, null, function* () {
        let r = yield this.#w(e);
        return (
          r.listeners.push({ listener: t, once: !1 }),
          r.started ||
            (r.subscriber.start(),
            (r.started = !0),
            this.#n != null && r.subscriber.pause(this.#n)),
          this
        );
      });
    }
    once(e, t) {
      return d(this, null, function* () {
        let r = yield this.#w(e);
        return (
          r.listeners.push({ listener: t, once: !0 }),
          r.started ||
            (r.subscriber.start(),
            (r.started = !0),
            this.#n != null && r.subscriber.pause(this.#n)),
          this
        );
      });
    }
    emit(e, ...t) {
      return d(this, null, function* () {
        let r = yield this.#y(e, t);
        if (!r || r.listeners.length === 0) return !1;
        let i = r.listeners.length;
        return (
          (r.listeners = r.listeners.filter(({ listener: s, once: o }) => {
            let a = new ds(this, o ? null : s, e);
            try {
              s.call(this, ...t, a);
            } catch {}
            return !o;
          })),
          r.listeners.length === 0 &&
            (r.started && r.subscriber.stop(), this.#e.delete(r.tag)),
          i > 0
        );
      });
    }
    listenerCount(e) {
      return d(this, null, function* () {
        if (e) {
          let r = yield this.#y(e);
          return r ? r.listeners.length : 0;
        }
        let t = 0;
        for (let { listeners: r } of this.#e.values()) t += r.length;
        return t;
      });
    }
    listeners(e) {
      return d(this, null, function* () {
        if (e) {
          let r = yield this.#y(e);
          return r ? r.listeners.map(({ listener: i }) => i) : [];
        }
        let t = [];
        for (let { listeners: r } of this.#e.values())
          t = t.concat(r.map(({ listener: i }) => i));
        return t;
      });
    }
    off(e, t) {
      return d(this, null, function* () {
        let r = yield this.#y(e);
        if (!r) return this;
        if (t) {
          let i = r.listeners.map(({ listener: s }) => s).indexOf(t);
          i >= 0 && r.listeners.splice(i, 1);
        }
        return (
          (!t || r.listeners.length === 0) &&
            (r.started && r.subscriber.stop(), this.#e.delete(r.tag)),
          this
        );
      });
    }
    removeAllListeners(e) {
      return d(this, null, function* () {
        if (e) {
          let { tag: t, started: r, subscriber: i } = yield this.#w(e);
          r && i.stop(), this.#e.delete(t);
        } else for (let [t, { started: r, subscriber: i }] of this.#e) r && i.stop(), this.#e.delete(t);
        return this;
      });
    }
    addListener(e, t) {
      return d(this, null, function* () {
        return yield this.on(e, t);
      });
    }
    removeListener(e, t) {
      return d(this, null, function* () {
        return this.off(e, t);
      });
    }
    get destroyed() {
      return this.#r;
    }
    destroy() {
      this.removeAllListeners();
      for (let e of this.#u.keys()) this._clearTimeout(e);
      this.#r = !0;
    }
    get paused() {
      return this.#n != null;
    }
    set paused(e) {
      !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
    }
    pause(e) {
      if (((this.#a = -1), this.#n != null)) {
        if (this.#n == !!e) return;
        R(
          !1,
          "cannot change pause type; resume first",
          "UNSUPPORTED_OPERATION",
          { operation: "pause" }
        );
      }
      this._forEachSubscriber((t) => t.pause(e)), (this.#n = !!e);
      for (let t of this.#u.values())
        t.timer && clearTimeout(t.timer), (t.time = ky() - t.time);
    }
    resume() {
      if (this.#n != null) {
        this._forEachSubscriber((e) => e.resume()), (this.#n = null);
        for (let e of this.#u.values()) {
          let t = e.time;
          t < 0 && (t = 0), (e.time = ky()), setTimeout(e.func, t);
        }
      }
    }
  };
function l8(n, e) {
  try {
    let t = Ry(n, e);
    if (t) return ki(t);
  } catch {}
  return null;
}
function Ry(n, e) {
  if (n === "0x") return null;
  try {
    let t = me(at(n, e, e + 32)),
      r = me(at(n, t, t + 32));
    return at(n, t + 32, t + 32 + r);
  } catch {}
  return null;
}
function Yv(n) {
  let e = Rt(n);
  if (e.length > 32) throw new Error("internal; should not happen");
  let t = new Uint8Array(32);
  return t.set(e, 32 - e.length), t;
}
function h8(n) {
  if (n.length % 32 === 0) return n;
  let e = new Uint8Array(Math.ceil(n.length / 32) * 32);
  return e.set(n), e;
}
var f8 = new Uint8Array([]);
function d8(n) {
  let e = [],
    t = 0;
  for (let r = 0; r < n.length; r++) e.push(f8), (t += 32);
  for (let r = 0; r < n.length; r++) {
    let i = fe(n[r]);
    (e[r] = Yv(t)),
      e.push(Yv(i.length)),
      e.push(h8(i)),
      (t += 32 + Math.ceil(i.length / 32) * 32);
  }
  return Fe(e);
}
var Zv = "0x0000000000000000000000000000000000000000000000000000000000000000";
function p8(n) {
  let e = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: [],
  };
  R(Sr(n) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data",
  });
  let t = at(n, 0, 32);
  R(
    at(t, 0, 12) === at(Zv, 0, 12),
    "corrupt OffchainLookup sender",
    "OFFCHAIN_FAULT",
    { reason: "corrupt OffchainLookup sender" }
  ),
    (e.sender = at(t, 12));
  try {
    let r = [],
      i = me(at(n, 32, 64)),
      s = me(at(n, i, i + 32)),
      o = at(n, i + 32);
    for (let a = 0; a < s; a++) {
      let c = l8(o, a * 32);
      if (c == null) throw new Error("abort");
      r.push(c);
    }
    e.urls = r;
  } catch {
    R(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls",
    });
  }
  try {
    let r = Ry(n, 64);
    if (r == null) throw new Error("abort");
    e.calldata = r;
  } catch {
    R(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata",
    });
  }
  R(
    at(n, 100, 128) === at(Zv, 0, 28),
    "corrupt OffchainLookup callbaackSelector",
    "OFFCHAIN_FAULT",
    { reason: "corrupt OffchainLookup callbaackSelector" }
  ),
    (e.selector = at(n, 96, 100));
  try {
    let r = Ry(n, 128);
    if (r == null) throw new Error("abort");
    e.extraData = r;
  } catch {
    R(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData",
    });
  }
  return (
    (e.errorArgs = "sender,urls,calldata,selector,extraData"
      .split(/,/)
      .map((r) => e[r])),
    e
  );
}
p();
function dc(n, e) {
  if (n.provider) return n.provider;
  R(!1, "missing provider", "UNSUPPORTED_OPERATION", { operation: e });
}
function Xv(n, e) {
  return d(this, null, function* () {
    let t = Es(e);
    if ((t.to != null && (t.to = Pt(t.to, n)), t.from != null)) {
      let r = t.from;
      t.from = Promise.all([n.getAddress(), Pt(r, n)]).then(
        ([i, s]) => (
          x(
            i.toLowerCase() === s.toLowerCase(),
            "transaction from mismatch",
            "tx.from",
            s
          ),
          i
        )
      );
    } else t.from = n.getAddress();
    return yield It(t);
  });
}
var Tl = class {
  provider;
  constructor(e) {
    ee(this, { provider: e || null });
  }
  getNonce(e) {
    return d(this, null, function* () {
      return dc(this, "getTransactionCount").getTransactionCount(
        yield this.getAddress(),
        e
      );
    });
  }
  populateCall(e) {
    return d(this, null, function* () {
      return yield Xv(this, e);
    });
  }
  populateTransaction(e) {
    return d(this, null, function* () {
      let t = dc(this, "populateTransaction"),
        r = yield Xv(this, e);
      r.nonce == null && (r.nonce = yield this.getNonce("pending")),
        r.gasLimit == null && (r.gasLimit = yield this.estimateGas(r));
      let i = yield this.provider.getNetwork();
      if (r.chainId != null) {
        let o = Y(r.chainId);
        x(
          o === i.chainId,
          "transaction chainId mismatch",
          "tx.chainId",
          e.chainId
        );
      } else r.chainId = i.chainId;
      let s = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
      if (
        (r.gasPrice != null && (r.type === 2 || s)
          ? x(!1, "eip-1559 transaction do not support gasPrice", "tx", e)
          : (r.type === 0 || r.type === 1) &&
            s &&
            x(
              !1,
              "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
              "tx",
              e
            ),
        (r.type === 2 || r.type == null) &&
          r.maxFeePerGas != null &&
          r.maxPriorityFeePerGas != null)
      )
        r.type = 2;
      else if (r.type === 0 || r.type === 1) {
        let o = yield t.getFeeData();
        R(
          o.gasPrice != null,
          "network does not support gasPrice",
          "UNSUPPORTED_OPERATION",
          { operation: "getGasPrice" }
        ),
          r.gasPrice == null && (r.gasPrice = o.gasPrice);
      } else {
        let o = yield t.getFeeData();
        if (r.type == null)
          if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
            if (((r.type = 2), r.gasPrice != null)) {
              let a = r.gasPrice;
              delete r.gasPrice,
                (r.maxFeePerGas = a),
                (r.maxPriorityFeePerGas = a);
            } else
              r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas),
                r.maxPriorityFeePerGas == null &&
                  (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas);
          else
            o.gasPrice != null
              ? (R(
                  !s,
                  "network does not support EIP-1559",
                  "UNSUPPORTED_OPERATION",
                  { operation: "populateTransaction" }
                ),
                r.gasPrice == null && (r.gasPrice = o.gasPrice),
                (r.type = 0))
              : R(
                  !1,
                  "failed to get consistent fee data",
                  "UNSUPPORTED_OPERATION",
                  { operation: "signer.getFeeData" }
                );
        else
          (r.type === 2 || r.type === 3) &&
            (r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas),
            r.maxPriorityFeePerGas == null &&
              (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas));
      }
      return yield It(r);
    });
  }
  estimateGas(e) {
    return d(this, null, function* () {
      return dc(this, "estimateGas").estimateGas(yield this.populateCall(e));
    });
  }
  call(e) {
    return d(this, null, function* () {
      return dc(this, "call").call(yield this.populateCall(e));
    });
  }
  resolveName(e) {
    return d(this, null, function* () {
      return yield dc(this, "resolveName").resolveName(e);
    });
  }
  sendTransaction(e) {
    return d(this, null, function* () {
      let t = dc(this, "sendTransaction"),
        r = yield this.populateTransaction(e);
      delete r.from;
      let i = yo.from(r);
      return yield t.broadcastTransaction(yield this.signTransaction(i));
    });
  }
};
p();
p();
function g8(n) {
  return JSON.parse(JSON.stringify(n));
}
var wd = class {
    #e;
    #t;
    #n;
    #r;
    #i;
    #o;
    constructor(e) {
      (this.#e = e),
        (this.#t = null),
        (this.#n = this.#s.bind(this)),
        (this.#r = !1),
        (this.#i = null),
        (this.#o = !1);
    }
    _subscribe(e) {
      throw new Error("subclasses must override this");
    }
    _emitResults(e, t) {
      throw new Error("subclasses must override this");
    }
    _recover(e) {
      throw new Error("subclasses must override this");
    }
    #s(e) {
      return d(this, null, function* () {
        try {
          this.#t == null && (this.#t = this._subscribe(this.#e));
          let t = null;
          try {
            t = yield this.#t;
          } catch (s) {
            if (
              !ut(s, "UNSUPPORTED_OPERATION") ||
              s.operation !== "eth_newFilter"
            )
              throw s;
          }
          if (t == null) {
            (this.#t = null),
              this.#e._recoverSubscriber(this, this._recover(this.#e));
            return;
          }
          let r = yield this.#e.getNetwork();
          if ((this.#i || (this.#i = r), this.#i.chainId !== r.chainId))
            throw new Error("chaid changed");
          if (this.#o) return;
          let i = yield this.#e.send("eth_getFilterChanges", [t]);
          yield this._emitResults(this.#e, i);
        } catch (t) {
          console.log("@TODO", t);
        }
        this.#e.once("block", this.#n);
      });
    }
    #a() {
      let e = this.#t;
      e &&
        ((this.#t = null),
        e.then((t) => {
          this.#e.destroyed || this.#e.send("eth_uninstallFilter", [t]);
        }));
    }
    start() {
      this.#r || ((this.#r = !0), this.#s(-2));
    }
    stop() {
      this.#r &&
        ((this.#r = !1),
        (this.#o = !0),
        this.#a(),
        this.#e.off("block", this.#n));
    }
    pause(e) {
      e && this.#a(), this.#e.off("block", this.#n);
    }
    resume() {
      this.start();
    }
  },
  bd = class extends wd {
    #e;
    constructor(e, t) {
      super(e), (this.#e = g8(t));
    }
    _recover(e) {
      return new Ss(e, this.#e);
    }
    _subscribe(e) {
      return d(this, null, function* () {
        return yield e.send("eth_newFilter", [this.#e]);
      });
    }
    _emitResults(e, t) {
      return d(this, null, function* () {
        for (let r of t) e.emit(this.#e, e._wrapLog(r, e._network));
      });
    }
  },
  Ad = class extends wd {
    _subscribe(e) {
      return d(this, null, function* () {
        return yield e.send("eth_newPendingTransactionFilter", []);
      });
    }
    _emitResults(e, t) {
      return d(this, null, function* () {
        for (let r of t) e.emit("pending", r);
      });
    }
  };
var m8 = "bigint,boolean,function,number,string,symbol".split(/,/g);
function Ed(n) {
  if (
    n == null ||
    m8.indexOf(typeof n) >= 0 ||
    typeof n.getAddress == "function"
  )
    return n;
  if (Array.isArray(n)) return n.map(Ed);
  if (typeof n == "object")
    return Object.keys(n).reduce((e, t) => ((e[t] = n[t]), e), {});
  throw new Error(`should not happen: ${n} (${typeof n})`);
}
function y8(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function pc(n) {
  return n && n.toLowerCase();
}
function eI(n) {
  return n && typeof n.pollingInterval == "number";
}
var tI = {
    polling: !1,
    staticNetwork: null,
    batchStallTime: 10,
    batchMaxSize: 1 << 20,
    batchMaxCount: 100,
    cacheTimeout: 250,
    pollingInterval: 4e3,
  },
  gc = class extends Tl {
    address;
    constructor(e, t) {
      super(e), (t = ke(t)), ee(this, { address: t });
    }
    connect(e) {
      R(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
        operation: "signer.connect",
      });
    }
    getAddress() {
      return d(this, null, function* () {
        return this.address;
      });
    }
    populateTransaction(e) {
      return d(this, null, function* () {
        return yield this.populateCall(e);
      });
    }
    sendUncheckedTransaction(e) {
      return d(this, null, function* () {
        let t = Ed(e),
          r = [];
        if (t.from) {
          let s = t.from;
          r.push(
            d(this, null, function* () {
              let o = yield Pt(s, this.provider);
              x(
                o != null && o.toLowerCase() === this.address.toLowerCase(),
                "from address mismatch",
                "transaction",
                e
              ),
                (t.from = o);
            })
          );
        } else t.from = this.address;
        if (
          (t.gasLimit == null &&
            r.push(
              d(this, null, function* () {
                t.gasLimit = yield this.provider.estimateGas(
                  $(v({}, t), { from: this.address })
                );
              })
            ),
          t.to != null)
        ) {
          let s = t.to;
          r.push(
            d(this, null, function* () {
              t.to = yield Pt(s, this.provider);
            })
          );
        }
        r.length && (yield Promise.all(r));
        let i = this.provider.getRpcTransaction(t);
        return this.provider.send("eth_sendTransaction", [i]);
      });
    }
    sendTransaction(e) {
      return d(this, null, function* () {
        let t = yield this.provider.getBlockNumber(),
          r = yield this.sendUncheckedTransaction(e);
        return yield new Promise((i, s) => {
          let o = [1e3, 100],
            a = 0,
            c = () =>
              d(this, null, function* () {
                try {
                  let u = yield this.provider.getTransaction(r);
                  if (u != null) {
                    i(u.replaceableTransaction(t));
                    return;
                  }
                } catch (u) {
                  if (
                    ut(u, "CANCELLED") ||
                    ut(u, "BAD_DATA") ||
                    ut(u, "NETWORK_ERROR") ||
                    ut(u, "UNSUPPORTED_OPERATION")
                  ) {
                    u.info == null && (u.info = {}),
                      (u.info.sendTransactionHash = r),
                      s(u);
                    return;
                  }
                  if (
                    ut(u, "INVALID_ARGUMENT") &&
                    (a++,
                    u.info == null && (u.info = {}),
                    (u.info.sendTransactionHash = r),
                    a > 10)
                  ) {
                    s(u);
                    return;
                  }
                  this.provider.emit(
                    "error",
                    Ye(
                      "failed to fetch transation after sending (will try again)",
                      "UNKNOWN_ERROR",
                      { error: u }
                    )
                  );
                }
                this.provider._setTimeout(() => {
                  c();
                }, o.pop() || 4e3);
              });
          c();
        });
      });
    }
    signTransaction(e) {
      return d(this, null, function* () {
        let t = Ed(e);
        if (t.from) {
          let i = yield Pt(t.from, this.provider);
          x(
            i != null && i.toLowerCase() === this.address.toLowerCase(),
            "from address mismatch",
            "transaction",
            e
          ),
            (t.from = i);
        } else t.from = this.address;
        let r = this.provider.getRpcTransaction(t);
        return yield this.provider.send("eth_signTransaction", [r]);
      });
    }
    signMessage(e) {
      return d(this, null, function* () {
        let t = typeof e == "string" ? mn(e) : e;
        return yield this.provider.send("personal_sign", [
          V(t),
          this.address.toLowerCase(),
        ]);
      });
    }
    signTypedData(e, t, r) {
      return d(this, null, function* () {
        let i = Ed(r),
          s = yield tc.resolveNames(e, t, i, (o) =>
            d(this, null, function* () {
              let a = yield Pt(o);
              return (
                x(
                  a != null,
                  "TypedData does not support null address",
                  "value",
                  o
                ),
                a
              );
            })
          );
        return yield this.provider.send("eth_signTypedData_v4", [
          this.address.toLowerCase(),
          JSON.stringify(tc.getPayload(s.domain, t, s.value)),
        ]);
      });
    }
    unlock(e) {
      return d(this, null, function* () {
        return this.provider.send("personal_unlockAccount", [
          this.address.toLowerCase(),
          e,
          null,
        ]);
      });
    }
    _legacySignMessage(e) {
      return d(this, null, function* () {
        let t = typeof e == "string" ? mn(e) : e;
        return yield this.provider.send("eth_sign", [
          this.address.toLowerCase(),
          V(t),
        ]);
      });
    }
  },
  xd = class n extends kl {
    #e;
    #t;
    #n;
    #r;
    #i;
    #o;
    #s;
    #a() {
      if (this.#r) return;
      let e =
        this._getOption("batchMaxCount") === 1
          ? 0
          : this._getOption("batchStallTime");
      this.#r = setTimeout(() => {
        this.#r = null;
        let t = this.#n;
        for (this.#n = []; t.length; ) {
          let r = [t.shift()];
          for (; t.length && r.length !== this.#e.batchMaxCount; )
            if (
              (r.push(t.shift()),
              JSON.stringify(r.map((s) => s.payload)).length >
                this.#e.batchMaxSize)
            ) {
              t.unshift(r.pop());
              break;
            }
          d(this, null, function* () {
            let i = r.length === 1 ? r[0].payload : r.map((s) => s.payload);
            this.emit("debug", { action: "sendRpcPayload", payload: i });
            try {
              let s = yield this._send(i);
              this.emit("debug", { action: "receiveRpcResult", result: s });
              for (let { resolve: o, reject: a, payload: c } of r) {
                if (this.destroyed) {
                  a(
                    Ye(
                      "provider destroyed; cancelled request",
                      "UNSUPPORTED_OPERATION",
                      { operation: c.method }
                    )
                  );
                  continue;
                }
                let u = s.filter((l) => l.id === c.id)[0];
                if (u == null) {
                  let l = Ye("missing response for request", "BAD_DATA", {
                    value: s,
                    info: { payload: c },
                  });
                  this.emit("error", l), a(l);
                  continue;
                }
                if ("error" in u) {
                  a(this.getRpcError(c, u));
                  continue;
                }
                o(u.result);
              }
            } catch (s) {
              this.emit("debug", { action: "receiveRpcError", error: s });
              for (let { reject: o } of r) o(s);
            }
          });
        }
      }, e);
    }
    constructor(e, t) {
      super(e, t),
        (this.#t = 1),
        (this.#e = Object.assign({}, tI, t || {})),
        (this.#n = []),
        (this.#r = null),
        (this.#o = null),
        (this.#s = null);
      {
        let i = null,
          s = new Promise((o) => {
            i = o;
          });
        this.#i = { promise: s, resolve: i };
      }
      let r = this._getOption("staticNetwork");
      typeof r == "boolean"
        ? (x(
            !r || e !== "any",
            "staticNetwork cannot be used on special network 'any'",
            "options",
            t
          ),
          r && e != null && (this.#o = Xn.from(e)))
        : r &&
          (x(
            e == null || r.matches(e),
            "staticNetwork MUST match network object",
            "options",
            t
          ),
          (this.#o = r));
    }
    _getOption(e) {
      return this.#e[e];
    }
    get _network() {
      return (
        R(this.#o, "network is not available yet", "NETWORK_ERROR"), this.#o
      );
    }
    _perform(e) {
      return d(this, null, function* () {
        if (e.method === "call" || e.method === "estimateGas") {
          let r = e.transaction;
          if (
            r &&
            r.type != null &&
            Y(r.type) &&
            r.maxFeePerGas == null &&
            r.maxPriorityFeePerGas == null
          ) {
            let i = yield this.getFeeData();
            i.maxFeePerGas == null &&
              i.maxPriorityFeePerGas == null &&
              (e = Object.assign({}, e, {
                transaction: Object.assign({}, r, { type: void 0 }),
              }));
          }
        }
        let t = this.getRpcRequest(e);
        return t != null
          ? yield this.send(t.method, t.args)
          : Js(n.prototype, this, "_perform").call(this, e);
      });
    }
    _detectNetwork() {
      return d(this, null, function* () {
        let e = this._getOption("staticNetwork");
        if (e)
          if (e === !0) {
            if (this.#o) return this.#o;
          } else return e;
        return this.#s
          ? yield this.#s
          : this.ready
          ? ((this.#s = d(this, null, function* () {
              try {
                let t = Xn.from(Y(yield this.send("eth_chainId", [])));
                return (this.#s = null), t;
              } catch (t) {
                throw ((this.#s = null), t);
              }
            })),
            yield this.#s)
          : ((this.#s = d(this, null, function* () {
              let t = {
                id: this.#t++,
                method: "eth_chainId",
                params: [],
                jsonrpc: "2.0",
              };
              this.emit("debug", { action: "sendRpcPayload", payload: t });
              let r;
              try {
                (r = (yield this._send(t))[0]), (this.#s = null);
              } catch (i) {
                throw (
                  ((this.#s = null),
                  this.emit("debug", { action: "receiveRpcError", error: i }),
                  i)
                );
              }
              if (
                (this.emit("debug", { action: "receiveRpcResult", result: r }),
                "result" in r)
              )
                return Xn.from(Y(r.result));
              throw this.getRpcError(t, r);
            })),
            yield this.#s);
      });
    }
    _start() {
      this.#i == null ||
        this.#i.resolve == null ||
        (this.#i.resolve(),
        (this.#i = null),
        d(this, null, function* () {
          for (; this.#o == null && !this.destroyed; )
            try {
              this.#o = yield this._detectNetwork();
            } catch (e) {
              if (this.destroyed) break;
              console.log(
                "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
              ),
                this.emit(
                  "error",
                  Ye("failed to bootstrap network detection", "NETWORK_ERROR", {
                    event: "initial-network-discovery",
                    info: { error: e },
                  })
                ),
                yield y8(1e3);
            }
          this.#a();
        }));
    }
    _waitUntilReady() {
      return d(this, null, function* () {
        if (this.#i != null) return yield this.#i.promise;
      });
    }
    _getSubscriber(e) {
      return e.type === "pending"
        ? new Ad(this)
        : e.type === "event"
        ? this._getOption("polling")
          ? new Ss(this, e.filter)
          : new bd(this, e.filter)
        : e.type === "orphan" && e.filter.orphan === "drop-log"
        ? new fc("orphan")
        : super._getSubscriber(e);
    }
    get ready() {
      return this.#i == null;
    }
    getRpcTransaction(e) {
      let t = {};
      return (
        [
          "chainId",
          "gasLimit",
          "gasPrice",
          "type",
          "maxFeePerGas",
          "maxPriorityFeePerGas",
          "nonce",
          "value",
        ].forEach((r) => {
          if (e[r] == null) return;
          let i = r;
          r === "gasLimit" && (i = "gas"), (t[i] = Ir(Y(e[r], `tx.${r}`)));
        }),
        ["from", "to", "data"].forEach((r) => {
          e[r] != null && (t[r] = V(e[r]));
        }),
        e.accessList && (t.accessList = Yn(e.accessList)),
        e.blobVersionedHashes &&
          (t.blobVersionedHashes = e.blobVersionedHashes.map((r) =>
            r.toLowerCase()
          )),
        t
      );
    }
    getRpcRequest(e) {
      switch (e.method) {
        case "chainId":
          return { method: "eth_chainId", args: [] };
        case "getBlockNumber":
          return { method: "eth_blockNumber", args: [] };
        case "getGasPrice":
          return { method: "eth_gasPrice", args: [] };
        case "getPriorityFee":
          return { method: "eth_maxPriorityFeePerGas", args: [] };
        case "getBalance":
          return {
            method: "eth_getBalance",
            args: [pc(e.address), e.blockTag],
          };
        case "getTransactionCount":
          return {
            method: "eth_getTransactionCount",
            args: [pc(e.address), e.blockTag],
          };
        case "getCode":
          return { method: "eth_getCode", args: [pc(e.address), e.blockTag] };
        case "getStorage":
          return {
            method: "eth_getStorageAt",
            args: [pc(e.address), "0x" + e.position.toString(16), e.blockTag],
          };
        case "broadcastTransaction":
          return {
            method: "eth_sendRawTransaction",
            args: [e.signedTransaction],
          };
        case "getBlock":
          if ("blockTag" in e)
            return {
              method: "eth_getBlockByNumber",
              args: [e.blockTag, !!e.includeTransactions],
            };
          if ("blockHash" in e)
            return {
              method: "eth_getBlockByHash",
              args: [e.blockHash, !!e.includeTransactions],
            };
          break;
        case "getTransaction":
          return { method: "eth_getTransactionByHash", args: [e.hash] };
        case "getTransactionReceipt":
          return { method: "eth_getTransactionReceipt", args: [e.hash] };
        case "call":
          return {
            method: "eth_call",
            args: [this.getRpcTransaction(e.transaction), e.blockTag],
          };
        case "estimateGas":
          return {
            method: "eth_estimateGas",
            args: [this.getRpcTransaction(e.transaction)],
          };
        case "getLogs":
          return (
            e.filter &&
              e.filter.address != null &&
              (Array.isArray(e.filter.address)
                ? (e.filter.address = e.filter.address.map(pc))
                : (e.filter.address = pc(e.filter.address))),
            { method: "eth_getLogs", args: [e.filter] }
          );
      }
      return null;
    }
    getRpcError(e, t) {
      let { method: r } = e,
        { error: i } = t;
      if (r === "eth_estimateGas" && i.message) {
        let a = i.message;
        if (!a.match(/revert/i) && a.match(/insufficient funds/i))
          return Ye("insufficient funds", "INSUFFICIENT_FUNDS", {
            transaction: e.params[0],
            info: { payload: e, error: i },
          });
      }
      if (r === "eth_call" || r === "eth_estimateGas") {
        let a = By(i),
          c = bs.getBuiltinCallException(
            r === "eth_call" ? "call" : "estimateGas",
            e.params[0],
            a ? a.data : null
          );
        return (c.info = { error: i, payload: e }), c;
      }
      let s = JSON.stringify(w8(i));
      if (
        typeof i.message == "string" &&
        i.message.match(/user denied|ethers-user-denied/i)
      )
        return Ye("user rejected action", "ACTION_REJECTED", {
          action:
            {
              eth_sign: "signMessage",
              personal_sign: "signMessage",
              eth_signTypedData_v4: "signTypedData",
              eth_signTransaction: "signTransaction",
              eth_sendTransaction: "sendTransaction",
              eth_requestAccounts: "requestAccess",
              wallet_requestAccounts: "requestAccess",
            }[r] || "unknown",
          reason: "rejected",
          info: { payload: e, error: i },
        });
      if (r === "eth_sendRawTransaction" || r === "eth_sendTransaction") {
        let a = e.params[0];
        if (s.match(/insufficient funds|base fee exceeds gas limit/i))
          return Ye(
            "insufficient funds for intrinsic transaction cost",
            "INSUFFICIENT_FUNDS",
            { transaction: a, info: { error: i } }
          );
        if (s.match(/nonce/i) && s.match(/too low/i))
          return Ye("nonce has already been used", "NONCE_EXPIRED", {
            transaction: a,
            info: { error: i },
          });
        if (s.match(/replacement transaction/i) && s.match(/underpriced/i))
          return Ye("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: a,
            info: { error: i },
          });
        if (s.match(/only replay-protected/i))
          return Ye(
            "legacy pre-eip-155 transactions not supported",
            "UNSUPPORTED_OPERATION",
            { operation: r, info: { transaction: a, info: { error: i } } }
          );
      }
      let o = !!s.match(/the method .* does not exist/i);
      return (
        o ||
          (i &&
            i.details &&
            i.details.startsWith("Unauthorized method:") &&
            (o = !0)),
        o
          ? Ye("unsupported operation", "UNSUPPORTED_OPERATION", {
              operation: e.method,
              info: { error: i, payload: e },
            })
          : Ye("could not coalesce error", "UNKNOWN_ERROR", {
              error: i,
              payload: e,
            })
      );
    }
    send(e, t) {
      if (this.destroyed)
        return Promise.reject(
          Ye("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: e,
          })
        );
      let r = this.#t++,
        i = new Promise((s, o) => {
          this.#n.push({
            resolve: s,
            reject: o,
            payload: { method: e, params: t, id: r, jsonrpc: "2.0" },
          });
        });
      return this.#a(), i;
    }
    getSigner(e) {
      return d(this, null, function* () {
        e == null && (e = 0);
        let t = this.send("eth_accounts", []);
        if (typeof e == "number") {
          let i = yield t;
          if (e >= i.length) throw new Error("no such account");
          return new gc(this, i[e]);
        }
        let { accounts: r } = yield It({
          network: this.getNetwork(),
          accounts: t,
        });
        e = ke(e);
        for (let i of r) if (ke(i) === e) return new gc(this, e);
        throw new Error("invalid account");
      });
    }
    listAccounts() {
      return d(this, null, function* () {
        return (yield this.send("eth_accounts", [])).map(
          (t) => new gc(this, t)
        );
      });
    }
    destroy() {
      this.#r && (clearTimeout(this.#r), (this.#r = null));
      for (let { payload: e, reject: t } of this.#n)
        t(
          Ye("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: e.method,
          })
        );
      (this.#n = []), super.destroy();
    }
  },
  Sd = class extends xd {
    #e;
    constructor(e, t) {
      super(e, t);
      let r = this._getOption("pollingInterval");
      r == null && (r = tI.pollingInterval), (this.#e = r);
    }
    _getSubscriber(e) {
      let t = super._getSubscriber(e);
      return eI(t) && (t.pollingInterval = this.#e), t;
    }
    get pollingInterval() {
      return this.#e;
    }
    set pollingInterval(e) {
      if (!Number.isInteger(e) || e < 0) throw new Error("invalid interval");
      (this.#e = e),
        this._forEachSubscriber((t) => {
          eI(t) && (t.pollingInterval = this.#e);
        });
    }
  };
function By(n) {
  if (n == null) return null;
  if (typeof n.message == "string" && n.message.match(/revert/i) && De(n.data))
    return { message: n.message, data: n.data };
  if (typeof n == "object") {
    for (let e in n) {
      let t = By(n[e]);
      if (t) return t;
    }
    return null;
  }
  if (typeof n == "string")
    try {
      return By(JSON.parse(n));
    } catch {}
  return null;
}
function Dy(n, e) {
  if (n != null) {
    if (
      (typeof n.message == "string" && e.push(n.message), typeof n == "object")
    )
      for (let t in n) Dy(n[t], e);
    if (typeof n == "string")
      try {
        return Dy(JSON.parse(n), e);
      } catch {}
  }
}
function w8(n) {
  let e = [];
  return Dy(n, e), e;
}
p();
var mc = class n extends Sd {
  #e;
  constructor(e, t, r) {
    let i = Object.assign({}, r ?? {}, { batchMaxCount: 1 });
    x(e && e.request, "invalid EIP-1193 provider", "ethereum", e),
      super(t, i),
      (this.#e = (s, o) =>
        d(this, null, function* () {
          let a = { method: s, params: o };
          this.emit("debug", { action: "sendEip1193Request", payload: a });
          try {
            let c = yield e.request(a);
            return (
              this.emit("debug", { action: "receiveEip1193Result", result: c }),
              c
            );
          } catch (c) {
            let u = new Error(c.message);
            throw (
              ((u.code = c.code),
              (u.data = c.data),
              (u.payload = a),
              this.emit("debug", { action: "receiveEip1193Error", error: u }),
              u)
            );
          }
        }));
  }
  send(e, t) {
    return d(this, null, function* () {
      return (
        yield this._start(),
        yield Js(n.prototype, this, "send").call(this, e, t)
      );
    });
  }
  _send(e) {
    return d(this, null, function* () {
      x(
        !Array.isArray(e),
        "EIP-1193 does not support batch request",
        "payload",
        e
      );
      try {
        let t = yield this.#e(e.method, e.params || []);
        return [{ id: e.id, result: t }];
      } catch (t) {
        return [
          {
            id: e.id,
            error: { code: t.code, data: t.data, message: t.message },
          },
        ];
      }
    });
  }
  getRpcError(e, t) {
    switch (((t = JSON.parse(JSON.stringify(t))), t.error.code || -1)) {
      case 4001:
        t.error.message = `ethers-user-denied: ${t.error.message}`;
        break;
      case 4200:
        t.error.message = `ethers-unsupported: ${t.error.message}`;
        break;
    }
    return super.getRpcError(e, t);
  }
  hasSigner(e) {
    return d(this, null, function* () {
      e == null && (e = 0);
      let t = yield this.send("eth_accounts", []);
      return typeof e == "number"
        ? t.length > e
        : ((e = e.toLowerCase()),
          t.filter((r) => r.toLowerCase() === e).length !== 0);
    });
  }
  getSigner(e) {
    return d(this, null, function* () {
      if ((e == null && (e = 0), !(yield this.hasSigner(e))))
        try {
          yield this.#e("eth_requestAccounts", []);
        } catch (t) {
          let r = t.payload;
          throw this.getRpcError(r, { id: r.id, error: t });
        }
      return yield Js(n.prototype, this, "getSigner").call(this, e);
    });
  }
};
p();
function nI(n) {
  let e = bi(() => n());
  return b8(e)
    ? new Proxy(n, {
        get(t, r) {
          return r in e
            ? (EE(t[r]) ||
                Object.defineProperty(t, r, {
                  value: Pn(() => t()[r]),
                  configurable: !0,
                }),
              nI(t[r]))
            : t[r];
        },
      })
    : n;
}
function b8(n) {
  return n?.constructor === Object;
}
var A8 = new WeakMap(),
  dr = Symbol("STATE_SOURCE");
function Rl(n, ...e) {
  n[dr].update((t) =>
    e.reduce((r, i) => v(v({}, r), typeof i == "function" ? i(r) : i), t)
  ),
    S8(n);
}
function E8(n) {
  return n[dr]();
}
function x8(n) {
  return A8.get(n[dr]) || [];
}
function S8(n) {
  let e = x8(n);
  for (let t of e) {
    let r = bi(() => E8(n));
    t(r);
  }
}
function rI(...n) {
  let e = [...n],
    t = typeof e[0] == "function" ? {} : e.shift(),
    r = e;
  return (() => {
    class s {
      constructor() {
        let a = r.reduce((w, m) => m(w), v8()),
          { stateSignals: c, computedSignals: u, methods: l, hooks: h } = a,
          f = v(v(v({}, c), u), l);
        this[dr] = a[dr];
        for (let w in f) this[w] = f[w];
        let { onInit: g, onDestroy: y } = h;
        g && g(), y && M(gi).onDestroy(y);
      }
      static ɵfac = function (c) {
        return new (c || s)();
      };
      static ɵprov = ae({
        token: s,
        factory: s.ɵfac,
        providedIn: t.providedIn || null,
      });
    }
    return s;
  })();
}
function v8() {
  return {
    [dr]: Tu({}),
    stateSignals: {},
    computedSignals: {},
    methods: {},
    hooks: {},
  };
}
function iI(n) {
  return (e) => {
    let t = n(v(v({}, e.stateSignals), e.computedSignals));
    return (
      Object.keys(t),
      $(v({}, e), { computedSignals: v(v({}, e.computedSignals), t) })
    );
  };
}
function sI(n) {
  return (e) => {
    let t = v(
        v(v({ [dr]: e[dr] }, e.stateSignals), e.computedSignals),
        e.methods
      ),
      r = typeof n == "function" ? n(t) : n,
      i = (s) => {
        let o = r[s],
          a = e.hooks[s];
        return o
          ? () => {
              a && a(), o(t);
            }
          : a;
      };
    return $(v({}, e), {
      hooks: { onInit: i("onInit"), onDestroy: i("onDestroy") },
    });
  };
}
function oI(n) {
  return (e) => {
    let t = n(
      v(v(v({ [dr]: e[dr] }, e.stateSignals), e.computedSignals), e.methods)
    );
    return Object.keys(t), $(v({}, e), { methods: v(v({}, e.methods), t) });
  };
}
function aI(n) {
  return (e) => {
    let t = typeof n == "function" ? n() : n,
      r = Object.keys(t);
    e[dr].update((s) => v(v({}, s), t));
    let i = r.reduce((s, o) => {
      let a = Pn(() => e[dr]()[o]);
      return $(v({}, s), { [o]: nI(a) });
    }, {});
    return $(v({}, e), { stateSignals: v(v({}, e.stateSignals), i) });
  };
}
var _B = Et(uI());
p();
p();
p();
function I8() {
  return (n) =>
    new Ys((e) => {
      let t,
        r,
        i = new Ch();
      return (
        i.add(
          n.subscribe({
            complete: () => {
              t && e.next(r), e.complete();
            },
            error: (s) => {
              e.error(s);
            },
            next: (s) => {
              (r = s),
                t ||
                  ((t = qg.schedule(() => {
                    e.next(r), (t = void 0);
                  })),
                  i.add(t));
            },
          })
        ),
        i
      );
    });
}
function Py(n) {
  return typeof n.ngrxOnStoreInit == "function";
}
function Ly(n) {
  return typeof n.ngrxOnStateInit == "function";
}
function Oy(n) {
  let e = new Ae("@ngrx/component-store ComponentStore with Hooks");
  return [
    { provide: e, useClass: n },
    {
      provide: n,
      useFactory: () => {
        let t = M(e);
        return (
          (t.ɵhasProvider = !0),
          Py(t) && t.ngrxOnStoreInit(),
          Ly(t) && t.state$.pipe(br(1)).subscribe(() => t.ngrxOnStateInit()),
          t
        );
      },
    },
  ];
}
var C8 = new Ae("@ngrx/component-store Initial State"),
  yc = (() => {
    class n {
      constructor(t) {
        (this.destroySubject$ = new xu(1)),
          (this.destroy$ = this.destroySubject$.asObservable()),
          (this.stateSubject$ = new xu(1)),
          (this.isInitialized = !1),
          (this.state$ = this.select((r) => r)),
          (this.state = Ii(this.stateSubject$.pipe(Hr(this.destroy$)), {
            requireSync: !1,
            manualCleanup: !0,
          })),
          (this.ɵhasProvider = !1),
          t && this.initState(t),
          this.checkProviderForHooks();
      }
      ngOnDestroy() {
        this.stateSubject$.complete(), this.destroySubject$.next();
      }
      updater(t) {
        return (r) => {
          let i = !0,
            s,
            a = (Su(r) ? r : oe(r))
              .pipe(
                HA(Qg),
                Oe(() => this.assertStateIsInitialized()),
                Rh(this.stateSubject$),
                xe(([c, u]) => t(u, c)),
                Oe((c) => this.stateSubject$.next(c)),
                _n((c) => (i ? ((s = c), fn) : Tt(c))),
                Hr(this.destroy$)
              )
              .subscribe();
          if (s) throw s;
          return (i = !1), a;
        };
      }
      initState(t) {
        VA([t], Qg).subscribe((r) => {
          (this.isInitialized = !0), this.stateSubject$.next(r);
        });
      }
      setState(t) {
        typeof t != "function" ? this.initState(t) : this.updater(t)();
      }
      patchState(t) {
        let r = typeof t == "function" ? t(this.get()) : t;
        this.updater((i, s) => v(v({}, i), s))(r);
      }
      get(t) {
        this.assertStateIsInitialized();
        let r;
        return (
          this.stateSubject$.pipe(br(1)).subscribe((i) => {
            r = t ? t(i) : i;
          }),
          r
        );
      }
      select(...t) {
        let {
          observablesOrSelectorsObject: r,
          projector: i,
          config: s,
        } = k8(t);
        return (R8(r, i) ? this.stateSubject$ : dn(r)).pipe(
          s.debounce ? I8() : lI(),
          i
            ? xe((a) => (r.length > 0 && Array.isArray(a) ? i(...a) : i(a)))
            : lI(),
          Iu(s.equal),
          fa({ refCount: !0, bufferSize: 1 }),
          Hr(this.destroy$)
        );
      }
      selectSignal(...t) {
        let r = [...t],
          i = typeof r[t.length - 1] == "object" ? r.pop() : {},
          s = r.pop(),
          o = r,
          a =
            o.length === 0
              ? () => s(this.state())
              : () => {
                  let c = o.map((u) => u());
                  return s(...c);
                };
        return Pn(a, i);
      }
      effect(t) {
        let r = new rr();
        return (
          t(r).pipe(Hr(this.destroy$)).subscribe(),
          (i) =>
            (Su(i) ? i : oe(i)).pipe(Hr(this.destroy$)).subscribe((o) => {
              r.next(o);
            })
        );
      }
      checkProviderForHooks() {
        qg.schedule(() => {
          if (DE() && (Py(this) || Ly(this)) && !this.ɵhasProvider) {
            let t = [
              Py(this) ? "OnStoreInit" : "",
              Ly(this) ? "OnStateInit" : "",
            ].filter((r) => r);
            console.warn(
              `@ngrx/component-store: ${this.constructor.name} has the ${t.join(
                " and "
              )} lifecycle hook(s) implemented without being provided using the provideComponentStore(${
                this.constructor.name
              }) function. To resolve this, provide the component store via provideComponentStore(${
                this.constructor.name
              })`
            );
          }
        });
      }
      assertStateIsInitialized() {
        if (!this.isInitialized)
          throw new Error(
            `${this.constructor.name} has not been initialized yet. Please make sure it is initialized before updating/getting.`
          );
      }
      static {
        this.ɵfac = function (r) {
          return new (r || n)(le(C8, 8));
        };
      }
      static {
        this.ɵprov = ae({ token: n, factory: n.ɵfac });
      }
    }
    return n;
  })();
function k8(n) {
  let e = Array.from(n),
    r = { debounce: !1, equal: (o, a) => o === a };
  if (
    (T8(e[e.length - 1]) && (r = v(v({}, r), e.pop())),
    e.length === 1 && typeof e[0] != "function")
  )
    return { observablesOrSelectorsObject: e[0], projector: void 0, config: r };
  let i = e.pop();
  return { observablesOrSelectorsObject: e, projector: i, config: r };
}
function T8(n) {
  let e = n;
  return typeof e.debounce < "u" || typeof e.equal < "u";
}
function R8(n, e) {
  return Array.isArray(n) && n.length === 0 && e;
}
function lI() {
  return (n) => n;
}
tu();
p();
p();
p();
var W2 = Et(jE(), 1);
p();
var zt = class extends Error {
    constructor(e, t) {
      super(e), (this.error = t);
    }
  },
  li = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletNotReadyError");
    }
  };
var Ws = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletConfigError");
    }
  },
  Gi = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletConnectionError");
    }
  },
  nu = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletDisconnectedError");
    }
  },
  Yp = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletDisconnectionError");
    }
  },
  Ki = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletAccountError");
    }
  },
  ru = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletPublicKeyError");
    }
  };
var en = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletNotConnectedError");
    }
  },
  gr = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletSendTransactionError");
    }
  },
  mr = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletSignTransactionError");
    }
  },
  iu = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletSignMessageError");
    }
  },
  oh = class extends zt {
    constructor() {
      super(...arguments), (this.name = "WalletSignInError");
    }
  };
var At = (function (n) {
    return (
      (n.Installed = "Installed"),
      (n.NotDetected = "NotDetected"),
      (n.Loadable = "Loadable"),
      (n.Unsupported = "Unsupported"),
      n
    );
  })(At || {}),
  su = class extends W2.default {
    get connected() {
      return !!this.publicKey;
    }
    autoConnect() {
      return d(this, null, function* () {
        yield this.connect();
      });
    }
    prepareTransaction(i, s) {
      return d(this, arguments, function* (e, t, r = {}) {
        let o = this.publicKey;
        if (!o) throw new en();
        return (
          (e.feePayer = e.feePayer || o),
          (e.recentBlockhash =
            e.recentBlockhash ||
            (yield t.getLatestBlockhash({
              commitment: r.preflightCommitment,
              minContextSlot: r.minContextSlot,
            })).blockhash),
          e
        );
      });
    }
  };
p();
p();
function hi(n) {
  return "version" in n;
}
var Bb = class extends su {
    sendTransaction(i, s) {
      return d(this, arguments, function* (e, t, r = {}) {
        let o = !0;
        try {
          if (hi(e)) {
            if (!this.supportedTransactionVersions)
              throw new gr(
                "Sending versioned transactions isn't supported by this wallet"
              );
            if (!this.supportedTransactionVersions.has(e.version))
              throw new gr(
                `Sending transaction version ${e.version} isn't supported by this wallet`
              );
            try {
              e = yield this.signTransaction(e);
              let c = e.serialize();
              return yield t.sendRawTransaction(c, r);
            } catch (c) {
              throw c instanceof mr ? ((o = !1), c) : new gr(c?.message, c);
            }
          } else
            try {
              let a = r,
                { signers: c } = a,
                u = ln(a, ["signers"]);
              (e = yield this.prepareTransaction(e, t, u)),
                c?.length && e.partialSign(...c),
                (e = yield this.signTransaction(e));
              let l = e.serialize();
              return yield t.sendRawTransaction(l, u);
            } catch (c) {
              throw c instanceof mr ? ((o = !1), c) : new gr(c?.message, c);
            }
        } catch (c) {
          throw (o && this.emit("error", c), c);
        }
      });
    }
    signAllTransactions(e) {
      return d(this, null, function* () {
        for (let r of e)
          if (hi(r)) {
            if (!this.supportedTransactionVersions)
              throw new mr(
                "Signing versioned transactions isn't supported by this wallet"
              );
            if (!this.supportedTransactionVersions.has(r.version))
              throw new mr(
                `Signing transaction version ${r.version} isn't supported by this wallet`
              );
          }
        let t = [];
        for (let r of e) t.push(yield this.signTransaction(r));
        return t;
      });
    }
  },
  Db = class extends Bb {},
  Zp = class extends Db {};
p();
p();
var fi = "solana:signAndSendTransaction";
p();
var Xp = "solana:signIn";
p();
var ou = "solana:signMessage";
p();
var jt = "solana:signTransaction";
p();
var eg = "standard:connect";
p();
var _b = "standard:disconnect";
p();
var tg = "standard:events";
function H2(n) {
  return (
    eg in n.features &&
    tg in n.features &&
    (fi in n.features || jt in n.features)
  );
}
var ah = class extends zt {
  name = "WalletNotSelectedError";
};
p();
var ch = (n, e) =>
  kh(
    (t) => n.on(e, t),
    (t) => n.off(e, t)
  );
p();
p();
tu();
p();
tu();
p();
p();
function ng(n) {
  switch (n) {
    case "processed":
    case "confirmed":
    case "finalized":
    case void 0:
      return n;
    case "recent":
      return "processed";
    case "single":
    case "singleGossip":
      return "confirmed";
    case "max":
    case "root":
      return "finalized";
    default:
      return;
  }
}
p();
p();
var Pb = "solana:mainnet",
  V2 = "solana:devnet",
  $2 = "solana:testnet",
  G2 = "solana:localnet";
var z6 = "https://api.mainnet-beta.solana.com";
function K2(n) {
  return n.includes(z6)
    ? Pb
    : /\bdevnet\b/i.test(n)
    ? V2
    : /\btestnet\b/i.test(n)
    ? $2
    : /\blocalhost\b/i.test(n) || /\b127\.0\.0\.1\b/.test(n)
    ? G2
    : Pb;
}
p();
var j6 =
    "(?<domain>[^\\n]+?) wants you to sign in with your Solana account:\\n",
  W6 = "(?<address>[^\\n]+)(?:\\n|$)",
  H6 = "(?:\\n(?<statement>[\\S\\s]*?)(?:\\n|$))??",
  V6 = "(?:\\nURI: (?<uri>[^\\n]+))?",
  $6 = "(?:\\nVersion: (?<version>[^\\n]+))?",
  G6 = "(?:\\nChain ID: (?<chainId>[^\\n]+))?",
  K6 = "(?:\\nNonce: (?<nonce>[^\\n]+))?",
  q6 = "(?:\\nIssued At: (?<issuedAt>[^\\n]+))?",
  Q6 = "(?:\\nExpiration Time: (?<expirationTime>[^\\n]+))?",
  J6 = "(?:\\nNot Before: (?<notBefore>[^\\n]+))?",
  Y6 = "(?:\\nRequest ID: (?<requestId>[^\\n]+))?",
  Z6 = "(?:\\nResources:(?<resources>(?:\\n- [^\\n]+)*))?",
  X6 = `${V6}${$6}${G6}${K6}${q6}${Q6}${J6}${Y6}${Z6}`,
  fne = new RegExp(`^${j6}${W6}${H6}${X6}\\n*$`);
function q2(n) {
  let e = `${n.domain} wants you to sign in with your Solana account:
`;
  (e += `${n.address}`),
    n.statement &&
      (e += `

${n.statement}`);
  let t = [];
  if (
    (n.uri && t.push(`URI: ${n.uri}`),
    n.version && t.push(`Version: ${n.version}`),
    n.chainId && t.push(`Chain ID: ${n.chainId}`),
    n.nonce && t.push(`Nonce: ${n.nonce}`),
    n.issuedAt && t.push(`Issued At: ${n.issuedAt}`),
    n.expirationTime && t.push(`Expiration Time: ${n.expirationTime}`),
    n.notBefore && t.push(`Not Before: ${n.notBefore}`),
    n.requestId && t.push(`Request ID: ${n.requestId}`),
    n.resources)
  ) {
    t.push("Resources:");
    for (let r of n.resources) t.push(`- ${r}`);
  }
  return (
    t.length &&
      (e += `

${t.join(`
`)}`),
    e
  );
}
var qi = {
    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
    ERROR_REFLECTOR_ID_OUT_OF_RANGE: "ERROR_REFLECTOR_ID_OUT_OF_RANGE",
    ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
    ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
    ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
    ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
    ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND",
    ERROR_INVALID_PROTOCOL_VERSION: "ERROR_INVALID_PROTOCOL_VERSION",
  },
  zr = class extends Error {
    constructor(...e) {
      let [t, r, i] = e;
      super(r),
        (this.code = t),
        (this.data = i),
        (this.name = "SolanaMobileWalletAdapterError");
    }
  };
var rg = class extends Error {
  constructor(...e) {
    let [t, r, i, s] = e;
    super(i),
      (this.code = r),
      (this.data = s),
      (this.jsonRpcMessageId = t),
      (this.name = "SolanaMobileWalletAdapterProtocolError");
  }
};
function Lt(n, e, t, r) {
  function i(s) {
    return s instanceof t
      ? s
      : new t(function (o) {
          o(s);
        });
  }
  return new (t || (t = Promise))(function (s, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (h) {
        o(h);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (h) {
        o(h);
      }
    }
    function u(l) {
      l.done ? s(l.value) : i(l.value).then(a, c);
    }
    u((r = r.apply(n, e || [])).next());
  });
}
function Lb(n, e) {
  return Lt(this, void 0, void 0, function* () {
    let t = yield crypto.subtle.exportKey("raw", n),
      r = yield crypto.subtle.sign({ hash: "SHA-256", name: "ECDSA" }, e, t),
      i = new Uint8Array(t.byteLength + r.byteLength);
    return (
      i.set(new Uint8Array(t), 0), i.set(new Uint8Array(r), t.byteLength), i
    );
  });
}
function e5(n) {
  return window.btoa(n);
}
function t5(n) {
  return q2(n);
}
function n5(n) {
  return e5(t5(n));
}
var r5 = "solana:signTransactions",
  Q2 = "solana:cloneAuthorization";
function i5(n, e) {
  return new Proxy(
    {},
    {
      get(t, r) {
        return (
          t[r] == null &&
            (t[r] = function (i) {
              return Lt(this, void 0, void 0, function* () {
                let { method: s, params: o } = s5(r, i, n),
                  a = yield e(s, o);
                return (
                  s === "authorize" &&
                    o.sign_in_payload &&
                    !a.sign_in_result &&
                    (a.sign_in_result = yield a5(o.sign_in_payload, a, e)),
                  o5(r, a, n)
                );
              });
            }),
          t[r]
        );
      },
      defineProperty() {
        return !1;
      },
      deleteProperty() {
        return !1;
      },
    }
  );
}
function s5(n, e, t) {
  let r = e,
    i = n
      .toString()
      .replace(/[A-Z]/g, (s) => `_${s.toLowerCase()}`)
      .toLowerCase();
  switch (n) {
    case "authorize": {
      let { chain: s } = r;
      if (t === "legacy") {
        switch (s) {
          case "solana:testnet": {
            s = "testnet";
            break;
          }
          case "solana:devnet": {
            s = "devnet";
            break;
          }
          case "solana:mainnet": {
            s = "mainnet-beta";
            break;
          }
          default:
            s = r.cluster;
        }
        r.cluster = s;
      } else {
        switch (s) {
          case "testnet":
          case "devnet": {
            s = `solana:${s}`;
            break;
          }
          case "mainnet-beta": {
            s = "solana:mainnet";
            break;
          }
        }
        r.chain = s;
      }
    }
    case "reauthorize": {
      let { auth_token: s, identity: o } = r;
      if (s)
        switch (t) {
          case "legacy": {
            (i = "reauthorize"), (r = { auth_token: s, identity: o });
            break;
          }
          default: {
            i = "authorize";
            break;
          }
        }
      break;
    }
  }
  return { method: i, params: r };
}
function o5(n, e, t) {
  switch (n) {
    case "getCapabilities": {
      let r = e;
      switch (t) {
        case "legacy": {
          let i = [r5];
          return (
            r.supports_clone_authorization === !0 && i.push(Q2),
            Object.assign(Object.assign({}, r), { features: i })
          );
        }
        case "v1":
          return Object.assign(Object.assign({}, r), {
            supports_sign_and_send_transactions: !0,
            supports_clone_authorization: r.features.includes(Q2),
          });
      }
    }
  }
  return e;
}
function a5(n, e, t) {
  var r;
  return Lt(this, void 0, void 0, function* () {
    let i = (r = n.domain) !== null && r !== void 0 ? r : window.location.host,
      s = e.accounts[0].address,
      o = n5(Object.assign(Object.assign({}, n), { domain: i, address: s })),
      a = yield t("sign_messages", { addresses: [s], payloads: [o] });
    return {
      address: s,
      signed_message: o,
      signature: a.signed_payloads[0].slice(o.length),
    };
  });
}
var ta = 4;
function c5(n) {
  if (n >= 4294967296)
    throw new Error(
      "Outbound sequence number overflow. The maximum sequence number is 32-bytes."
    );
  let e = new ArrayBuffer(ta);
  return new DataView(e).setUint32(0, n, !1), new Uint8Array(e);
}
var Fb = 12,
  X2 = 65;
function u5(n, e, t) {
  return Lt(this, void 0, void 0, function* () {
    let r = c5(e),
      i = new Uint8Array(Fb);
    crypto.getRandomValues(i);
    let s = yield crypto.subtle.encrypt(
        tT(r, i),
        t,
        new TextEncoder().encode(n)
      ),
      o = new Uint8Array(r.byteLength + i.byteLength + s.byteLength);
    return (
      o.set(new Uint8Array(r), 0),
      o.set(new Uint8Array(i), r.byteLength),
      o.set(new Uint8Array(s), r.byteLength + i.byteLength),
      o
    );
  });
}
function eT(n, e) {
  return Lt(this, void 0, void 0, function* () {
    let t = n.slice(0, ta),
      r = n.slice(ta, ta + Fb),
      i = n.slice(ta + Fb),
      s = yield crypto.subtle.decrypt(tT(t, r), e, i);
    return l5().decode(s);
  });
}
function tT(n, e) {
  return { additionalData: n, iv: e, name: "AES-GCM", tagLength: 128 };
}
var Ob;
function l5() {
  return Ob === void 0 && (Ob = new TextDecoder("utf-8")), Ob;
}
function h5() {
  return Lt(this, void 0, void 0, function* () {
    return yield crypto.subtle.generateKey(
      { name: "ECDSA", namedCurve: "P-256" },
      !1,
      ["sign"]
    );
  });
}
function Nb() {
  return Lt(this, void 0, void 0, function* () {
    return yield crypto.subtle.generateKey(
      { name: "ECDH", namedCurve: "P-256" },
      !1,
      ["deriveKey", "deriveBits"]
    );
  });
}
function f5(n, e) {
  return Lt(this, void 0, void 0, function* () {
    let t = JSON.stringify(n),
      r = n.id;
    return u5(t, r, e);
  });
}
function d5(n, e) {
  return Lt(this, void 0, void 0, function* () {
    let t = yield eT(n, e),
      r = JSON.parse(t);
    if (Object.hasOwnProperty.call(r, "error"))
      throw new rg(r.id, r.error.code, r.error.message);
    return r;
  });
}
function p5(n, e, t) {
  return Lt(this, void 0, void 0, function* () {
    let [r, i] = yield Promise.all([
        crypto.subtle.exportKey("raw", e),
        crypto.subtle.importKey(
          "raw",
          n.slice(0, X2),
          { name: "ECDH", namedCurve: "P-256" },
          !1,
          []
        ),
      ]),
      s = yield crypto.subtle.deriveBits({ name: "ECDH", public: i }, t, 256),
      o = yield crypto.subtle.importKey("raw", s, "HKDF", !1, ["deriveKey"]);
    return yield crypto.subtle.deriveKey(
      {
        name: "HKDF",
        hash: "SHA-256",
        salt: new Uint8Array(r),
        info: new Uint8Array(),
      },
      o,
      { name: "AES-GCM", length: 128 },
      !1,
      ["encrypt", "decrypt"]
    );
  });
}
function g5(n, e) {
  return Lt(this, void 0, void 0, function* () {
    let t = yield eT(n, e),
      r = JSON.parse(t),
      i = "legacy";
    if (Object.hasOwnProperty.call(r, "v"))
      switch (r.v) {
        case 1:
        case "1":
        case "v1":
          i = "v1";
          break;
        case "legacy":
          i = "legacy";
          break;
        default:
          throw new zr(
            qi.ERROR_INVALID_PROTOCOL_VERSION,
            `Unknown/unsupported protocol version: ${r.v}`
          );
      }
    return { protocol_version: i };
  });
}
function m5() {
  return nT(49152 + Math.floor(Math.random() * 16384));
}
function nT(n) {
  if (n < 49152 || n > 65535)
    throw new zr(
      qi.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE,
      `Association port number must be between 49152 and 65535. ${n} given.`,
      { port: n }
    );
  return n;
}
function y5(n) {
  let e = "",
    t = new Uint8Array(n),
    r = t.byteLength;
  for (let i = 0; i < r; i++) e += String.fromCharCode(t[i]);
  return window.btoa(e);
}
function w5(n) {
  return n.replace(/[/+=]/g, (e) => ({ "/": "_", "+": "-", "=": "." }[e]));
}
var b5 = "solana-wallet";
function J2(n) {
  return n.replace(/(^\/+|\/+$)/g, "").split("/");
}
function A5(n, e) {
  let t = null;
  if (e) {
    try {
      t = new URL(e);
    } catch {}
    if (t?.protocol !== "https:")
      throw new zr(
        qi.ERROR_FORBIDDEN_WALLET_BASE_URL,
        "Base URLs supplied by wallets must be valid `https` URLs"
      );
  }
  t || (t = new URL(`${b5}:/`));
  let r = n.startsWith("/") ? n : [...J2(t.pathname), ...J2(n)].join("/");
  return new URL(r, t);
}
function E5(n, e, t, r = ["v1"]) {
  return Lt(this, void 0, void 0, function* () {
    let i = nT(e),
      s = yield crypto.subtle.exportKey("raw", n),
      o = y5(s),
      a = A5("v1/associate/local", t);
    return (
      a.searchParams.set("association", w5(o)),
      a.searchParams.set("port", `${i}`),
      r.forEach((c) => {
        a.searchParams.set("v", c);
      }),
      a
    );
  });
}
var ig = { Firefox: 0, Other: 1 };
function x5() {
  return navigator.userAgent.indexOf("Firefox/") !== -1 ? ig.Firefox : ig.Other;
}
function S5() {
  return new Promise((n, e) => {
    function t() {
      clearTimeout(i), window.removeEventListener("blur", r);
    }
    function r() {
      t(), n();
    }
    window.addEventListener("blur", r);
    let i = setTimeout(() => {
      t(), e();
    }, 2e3);
  });
}
var uh = null;
function v5(n) {
  uh == null &&
    ((uh = document.createElement("iframe")),
    (uh.style.display = "none"),
    document.body.appendChild(uh)),
    (uh.contentWindow.location.href = n.toString());
}
function I5(n) {
  return Lt(this, void 0, void 0, function* () {
    if (n.protocol === "https:") window.location.assign(n);
    else
      try {
        let e = x5();
        switch (e) {
          case ig.Firefox:
            v5(n);
            break;
          case ig.Other: {
            let t = S5();
            window.location.assign(n), yield t;
            break;
          }
          default:
        }
      } catch {
        throw new zr(
          qi.ERROR_WALLET_NOT_FOUND,
          "Found no installed wallet that supports the mobile wallet protocol."
        );
      }
  });
}
function C5(n, e) {
  return Lt(this, void 0, void 0, function* () {
    let t = m5(),
      r = yield E5(n, t, e);
    return yield I5(r), t;
  });
}
var Y2 = {
    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
    timeoutMs: 3e4,
  },
  k5 = "com.solana.mobilewalletadapter.v1";
function T5() {
  if (typeof window > "u" || window.isSecureContext !== !0)
    throw new zr(
      qi.ERROR_SECURE_CONTEXT_REQUIRED,
      "The mobile wallet adapter protocol must be used in a secure context (`https`)."
    );
}
function R5(n) {
  let e;
  try {
    e = new URL(n);
  } catch {
    throw new zr(
      qi.ERROR_FORBIDDEN_WALLET_BASE_URL,
      "Invalid base URL supplied by wallet"
    );
  }
  if (e.protocol !== "https:")
    throw new zr(
      qi.ERROR_FORBIDDEN_WALLET_BASE_URL,
      "Base URLs supplied by wallets must be valid `https` URLs"
    );
}
function Z2(n) {
  return new DataView(n).getUint32(0, !1);
}
function rT(n, e) {
  return Lt(this, void 0, void 0, function* () {
    T5();
    let t = yield h5(),
      i = `ws://localhost:${yield C5(t.publicKey, e?.baseUri)}/solana-wallet`,
      s,
      o = (() => {
        let l = [...Y2.retryDelayScheduleMs];
        return () => (l.length > 1 ? l.shift() : l[0]);
      })(),
      a = 1,
      c = 0,
      u = { __type: "disconnected" };
    return new Promise((l, h) => {
      let f,
        g = {},
        y = () =>
          Lt(this, void 0, void 0, function* () {
            if (u.__type !== "connecting") {
              console.warn(
                `Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${u.__type}\`.`
              );
              return;
            }
            f.removeEventListener("open", y);
            let { associationKeypair: B } = u,
              L = yield Nb();
            f.send(yield Lb(L.publicKey, B.privateKey)),
              (u = {
                __type: "hello_req_sent",
                associationPublicKey: B.publicKey,
                ecdhPrivateKey: L.privateKey,
              });
          }),
        w = (B) => {
          B.wasClean
            ? (u = { __type: "disconnected" })
            : h(
                new zr(
                  qi.ERROR_SESSION_CLOSED,
                  `The wallet session dropped unexpectedly (${B.code}: ${B.reason}).`,
                  { closeEvent: B }
                )
              ),
            I();
        },
        m = (B) =>
          Lt(this, void 0, void 0, function* () {
            I(),
              Date.now() - s >= Y2.timeoutMs
                ? h(
                    new zr(
                      qi.ERROR_SESSION_TIMEOUT,
                      `Failed to connect to the wallet websocket at ${i}.`
                    )
                  )
                : (yield new Promise((L) => {
                    let U = o();
                    E = window.setTimeout(L, U);
                  }),
                  T());
          }),
        b = (B) =>
          Lt(this, void 0, void 0, function* () {
            let L = yield B.data.arrayBuffer();
            switch (u.__type) {
              case "connecting":
                if (L.byteLength !== 0)
                  throw new Error(
                    "Encountered unexpected message while connecting"
                  );
                let U = yield Nb();
                f.send(yield Lb(U.publicKey, t.privateKey)),
                  (u = {
                    __type: "hello_req_sent",
                    associationPublicKey: t.publicKey,
                    ecdhPrivateKey: U.privateKey,
                  });
                break;
              case "connected":
                try {
                  let j = L.slice(0, ta),
                    W = Z2(j);
                  if (W !== c + 1)
                    throw new Error(
                      "Encrypted message has invalid sequence number"
                    );
                  c = W;
                  let be = yield d5(L, u.sharedSecret),
                    pe = g[be.id];
                  delete g[be.id], pe.resolve(be.result);
                } catch (j) {
                  if (j instanceof rg) {
                    let W = g[j.jsonRpcMessageId];
                    delete g[j.jsonRpcMessageId], W.reject(j);
                  } else throw j;
                }
                break;
              case "hello_req_sent": {
                if (L.byteLength === 0) {
                  let ge = yield Nb();
                  f.send(yield Lb(ge.publicKey, t.privateKey)),
                    (u = {
                      __type: "hello_req_sent",
                      associationPublicKey: t.publicKey,
                      ecdhPrivateKey: ge.privateKey,
                    });
                  break;
                }
                let j = yield p5(L, u.associationPublicKey, u.ecdhPrivateKey),
                  W = L.slice(X2),
                  be =
                    W.byteLength !== 0
                      ? yield Lt(this, void 0, void 0, function* () {
                          let ge = W.slice(0, ta),
                            _e = Z2(ge);
                          if (_e !== c + 1)
                            throw new Error(
                              "Encrypted message has invalid sequence number"
                            );
                          return (c = _e), g5(W, j);
                        })
                      : { protocol_version: "legacy" };
                u = {
                  __type: "connected",
                  sharedSecret: j,
                  sessionProperties: be,
                };
                let pe = i5(be.protocol_version, (ge, _e) =>
                  Lt(this, void 0, void 0, function* () {
                    let X = a++;
                    return (
                      f.send(
                        yield f5(
                          {
                            id: X,
                            jsonrpc: "2.0",
                            method: ge,
                            params: _e ?? {},
                          },
                          j
                        )
                      ),
                      new Promise((q, F) => {
                        g[X] = {
                          resolve(O) {
                            switch (ge) {
                              case "authorize":
                              case "reauthorize": {
                                let { wallet_uri_base: K } = O;
                                if (K != null)
                                  try {
                                    R5(K);
                                  } catch (H) {
                                    F(H);
                                    return;
                                  }
                                break;
                              }
                            }
                            q(O);
                          },
                          reject: F,
                        };
                      })
                    );
                  })
                );
                try {
                  l(yield n(pe));
                } catch (ge) {
                  h(ge);
                } finally {
                  I(), f.close();
                }
                break;
              }
            }
          }),
        I,
        E,
        T = () => {
          I && I(),
            (u = { __type: "connecting", associationKeypair: t }),
            s === void 0 && (s = Date.now()),
            (f = new WebSocket(i, [k5])),
            f.addEventListener("open", y),
            f.addEventListener("close", w),
            f.addEventListener("error", m),
            f.addEventListener("message", b),
            (I = () => {
              window.clearTimeout(E),
                f.removeEventListener("open", y),
                f.removeEventListener("close", w),
                f.removeEventListener("error", m),
                f.removeEventListener("message", b);
            });
        };
      T();
    });
  });
}
var uT = Et(aT(), 1);
function Mb(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
}
function sg(n, e, t, r) {
  function i(s) {
    return s instanceof t
      ? s
      : new t(function (o) {
          o(s);
        });
  }
  return new (t || (t = Promise))(function (s, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (h) {
        o(h);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (h) {
        o(h);
      }
    }
    function u(l) {
      l.done ? s(l.value) : i(l.value).then(a, c);
    }
    u((r = r.apply(n, e || [])).next());
  });
}
function lT(n) {
  return window.btoa(String.fromCharCode.call(null, ...n));
}
function Ub(n) {
  return new Uint8Array(
    window
      .atob(n)
      .split("")
      .map((e) => e.charCodeAt(0))
  );
}
function cT(n) {
  let e =
    "version" in n
      ? n.serialize()
      : n.serialize({ requireAllSignatures: !1, verifySignatures: !1 });
  return lT(e);
}
function P5(n) {
  let t = n[0] * Qo + 1;
  return sh.deserializeMessageVersion(n.slice(t, n.length)) === "legacy"
    ? Ne.from(n)
    : $i.deserialize(n);
}
function hT(n, e) {
  return sg(this, void 0, void 0, function* () {
    return yield rT((r) => {
      let i = new Proxy(
        {},
        {
          get(s, o) {
            if (s[o] == null)
              switch (o) {
                case "signAndSendTransactions":
                  s[o] = function (a) {
                    var {
                        minContextSlot: c,
                        commitment: u,
                        skipPreflight: l,
                        maxRetries: h,
                        waitForCommitmentToSendNextTransaction: f,
                        transactions: g,
                      } = a,
                      y = Mb(a, [
                        "minContextSlot",
                        "commitment",
                        "skipPreflight",
                        "maxRetries",
                        "waitForCommitmentToSendNextTransaction",
                        "transactions",
                      ]);
                    return sg(this, void 0, void 0, function* () {
                      let w = g.map(cT),
                        m = {
                          min_context_slot: c,
                          commitment: u,
                          skip_preflight: l,
                          max_retries: h,
                          wait_for_commitment_to_send_next_transaction: f,
                        },
                        { signatures: b } = yield r.signAndSendTransactions(
                          Object.assign(
                            Object.assign(
                              Object.assign({}, y),
                              Object.values(m).some((E) => E != null)
                                ? { options: m }
                                : null
                            ),
                            { payloads: w }
                          )
                        );
                      return b.map(Ub).map(uT.default.encode);
                    });
                  };
                  break;
                case "signMessages":
                  s[o] = function (a) {
                    var { payloads: c } = a,
                      u = Mb(a, ["payloads"]);
                    return sg(this, void 0, void 0, function* () {
                      let l = c.map(lT),
                        { signed_payloads: h } = yield r.signMessages(
                          Object.assign(Object.assign({}, u), { payloads: l })
                        );
                      return h.map(Ub);
                    });
                  };
                  break;
                case "signTransactions":
                  s[o] = function (a) {
                    var { transactions: c } = a,
                      u = Mb(a, ["transactions"]);
                    return sg(this, void 0, void 0, function* () {
                      let l = c.map(cT),
                        { signed_payloads: h } = yield r.signTransactions(
                          Object.assign(Object.assign({}, u), { payloads: l })
                        );
                      return h.map(Ub).map(P5);
                    });
                  };
                  break;
                default: {
                  s[o] = r[o];
                  break;
                }
              }
            return s[o];
          },
          defineProperty() {
            return !1;
          },
          deleteProperty() {
            return !1;
          },
        }
      );
      return n(i);
    }, e);
  });
}
var kz = Et(lR(), 1);
function $e(n, e, t, r) {
  function i(s) {
    return s instanceof t
      ? s
      : new t(function (o) {
          o(s);
        });
  }
  return new (t || (t = Promise))(function (s, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (h) {
        o(h);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (h) {
        o(h);
      }
    }
    function u(l) {
      l.done ? s(l.value) : i(l.value).then(a, c);
    }
    u((r = r.apply(n, e || [])).next());
  });
}
function yg(n) {
  return new Uint8Array(
    window
      .atob(n)
      .split("")
      .map((e) => e.charCodeAt(0))
  );
}
function Tz() {
  return (
    typeof window < "u" &&
    window.isSecureContext &&
    typeof document < "u" &&
    /android/i.test(navigator.userAgent)
  );
}
var yh = "Mobile Wallet Adapter",
  Rz = 64;
function Bz(n) {
  let e = yg(n);
  return new J(e);
}
function hR(n) {
  return "version" in n;
}
function Dz(n) {
  switch (n) {
    case "mainnet-beta":
      return "solana:mainnet";
    case "testnet":
      return "solana:testnet";
    case "devnet":
      return "solana:devnet";
  }
}
var wg = class extends Zp {
  constructor(e) {
    var t;
    super(),
      (this.supportedTransactionVersions = new Set(["legacy", 0])),
      (this.name = yh),
      (this.url = "https://solanamobile.com/wallets"),
      (this.icon =
        "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg=="),
      (this._connecting = !1),
      (this._connectionGeneration = 0),
      (this._readyState = Tz() ? At.Loadable : At.Unsupported),
      (this._authorizationResultCache = e.authorizationResultCache),
      (this._addressSelector = e.addressSelector),
      (this._appIdentity = e.appIdentity),
      (this._chain =
        (t = e.chain) !== null && t !== void 0 ? t : Dz(e.cluster)),
      (this._hostAuthority = e.remoteHostAuthority),
      (this._onWalletNotFound = e.onWalletNotFound),
      this._readyState !== At.Unsupported &&
        this._authorizationResultCache.get().then((r) => {
          r && this.declareWalletAsInstalled();
        });
  }
  get publicKey() {
    if (this._publicKey == null && this._selectedAddress != null)
      try {
        this._publicKey = Bz(this._selectedAddress);
      } catch (e) {
        throw new ru((e instanceof Error && e?.message) || "Unknown error", e);
      }
    return this._publicKey ? this._publicKey : null;
  }
  get connected() {
    return !!this._authorizationResult;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  declareWalletAsInstalled() {
    this._readyState !== At.Installed &&
      this.emit("readyStateChange", (this._readyState = At.Installed));
  }
  runWithGuard(e) {
    return $e(this, void 0, void 0, function* () {
      try {
        return yield e();
      } catch (t) {
        throw (this.emit("error", t), t);
      }
    });
  }
  autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
    return $e(this, void 0, void 0, function* () {
      return yield this.autoConnect();
    });
  }
  autoConnect() {
    return $e(this, void 0, void 0, function* () {
      if (!(this.connecting || this.connected))
        return yield this.runWithGuard(() =>
          $e(this, void 0, void 0, function* () {
            if (
              this._readyState !== At.Installed &&
              this._readyState !== At.Loadable
            )
              throw new li();
            this._connecting = !0;
            try {
              let e = yield this._authorizationResultCache.get();
              e && this.handleAuthorizationResult(e);
            } catch (e) {
              throw new Gi(
                (e instanceof Error && e.message) || "Unknown error",
                e
              );
            } finally {
              this._connecting = !1;
            }
          })
        );
    });
  }
  connect() {
    return $e(this, void 0, void 0, function* () {
      if (!(this.connecting || this.connected))
        return yield this.runWithGuard(() =>
          $e(this, void 0, void 0, function* () {
            if (
              this._readyState !== At.Installed &&
              this._readyState !== At.Loadable
            )
              throw new li();
            this._connecting = !0;
            try {
              yield this.performAuthorization();
            } catch (e) {
              throw new Gi(
                (e instanceof Error && e.message) || "Unknown error",
                e
              );
            } finally {
              this._connecting = !1;
            }
          })
        );
    });
  }
  performAuthorization(e) {
    return $e(this, void 0, void 0, function* () {
      try {
        let t = yield this._authorizationResultCache.get();
        return t
          ? (this.handleAuthorizationResult(t), t)
          : yield this.transact((r) =>
              $e(this, void 0, void 0, function* () {
                let i = yield r.authorize({
                  chain: this._chain,
                  identity: this._appIdentity,
                  sign_in_payload: e,
                });
                return (
                  Promise.all([
                    this._authorizationResultCache.set(i),
                    this.handleAuthorizationResult(i),
                  ]),
                  i
                );
              })
            );
      } catch (t) {
        throw new Gi((t instanceof Error && t.message) || "Unknown error", t);
      }
    });
  }
  handleAuthorizationResult(e) {
    var t;
    return $e(this, void 0, void 0, function* () {
      let r =
        this._authorizationResult == null ||
        ((t = this._authorizationResult) === null || t === void 0
          ? void 0
          : t.accounts.length) !== e.accounts.length ||
        this._authorizationResult.accounts.some(
          (i, s) => i.address !== e.accounts[s].address
        );
      if (
        ((this._authorizationResult = e), this.declareWalletAsInstalled(), r)
      ) {
        let i = yield this._addressSelector.select(
          e.accounts.map(({ address: s }) => s)
        );
        i !== this._selectedAddress &&
          ((this._selectedAddress = i),
          delete this._publicKey,
          this.emit("connect", this.publicKey));
      }
    });
  }
  performReauthorization(e, t) {
    return $e(this, void 0, void 0, function* () {
      try {
        let r = yield e.authorize({
          auth_token: t,
          identity: this._appIdentity,
        });
        Promise.all([
          this._authorizationResultCache.set(r),
          this.handleAuthorizationResult(r),
        ]);
      } catch (r) {
        throw (
          (this.disconnect(),
          new nu((r instanceof Error && r?.message) || "Unknown error", r))
        );
      }
    });
  }
  disconnect() {
    return $e(this, void 0, void 0, function* () {
      this._authorizationResultCache.clear(),
        (this._connecting = !1),
        this._connectionGeneration++,
        delete this._authorizationResult,
        delete this._publicKey,
        delete this._selectedAddress,
        this.emit("disconnect");
    });
  }
  transact(e) {
    var t;
    return $e(this, void 0, void 0, function* () {
      let r =
          (t = this._authorizationResult) === null || t === void 0
            ? void 0
            : t.wallet_uri_base,
        i = r ? { baseUri: r } : void 0,
        s = this._hostAuthority
          ? { remoteHostAuthority: this._hostAuthority }
          : void 0,
        o = this._connectionGeneration;
      try {
        return yield hT(e, Object.assign(Object.assign({}, i), s));
      } catch (a) {
        throw (
          (this._connectionGeneration !== o && (yield new Promise(() => {})),
          a instanceof Error &&
            a.name === "SolanaMobileWalletAdapterError" &&
            a.code === "ERROR_WALLET_NOT_FOUND" &&
            (yield this._onWalletNotFound(this)),
          a)
        );
      }
    });
  }
  assertIsAuthorized() {
    if (!this._authorizationResult || !this._selectedAddress) throw new en();
    return {
      authToken: this._authorizationResult.auth_token,
      selectedAddress: this._selectedAddress,
    };
  }
  performSignTransactions(e) {
    return $e(this, void 0, void 0, function* () {
      let { authToken: t } = this.assertIsAuthorized();
      try {
        return yield this.transact((r) =>
          $e(this, void 0, void 0, function* () {
            return (
              yield this.performReauthorization(r, t),
              yield r.signTransactions({ transactions: e })
            );
          })
        );
      } catch (r) {
        throw new mr(r?.message, r);
      }
    });
  }
  sendTransaction(e, t, r) {
    return $e(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        $e(this, void 0, void 0, function* () {
          let { authToken: i } = this.assertIsAuthorized(),
            s = r?.minContextSlot;
          try {
            return yield this.transact((o) =>
              $e(this, void 0, void 0, function* () {
                function a() {
                  let h;
                  switch (t.commitment) {
                    case "confirmed":
                    case "finalized":
                    case "processed":
                      h = t.commitment;
                      break;
                    default:
                      h = "finalized";
                  }
                  let f;
                  switch (r?.preflightCommitment) {
                    case "confirmed":
                    case "finalized":
                    case "processed":
                      f = r.preflightCommitment;
                      break;
                    case void 0:
                      f = h;
                      break;
                    default:
                      f = "finalized";
                  }
                  return (f === "finalized" ? 2 : f === "confirmed" ? 1 : 0) <
                    (h === "finalized" ? 2 : h === "confirmed" ? 1 : 0)
                    ? f
                    : h;
                }
                let [c, u, l] = yield Promise.all([
                  o.getCapabilities(),
                  this.performReauthorization(o, i),
                  hR(e)
                    ? null
                    : $e(this, void 0, void 0, function* () {
                        var h;
                        if (
                          (e.feePayer ||
                            (e.feePayer =
                              (h = this.publicKey) !== null && h !== void 0
                                ? h
                                : void 0),
                          e.recentBlockhash == null)
                        ) {
                          let { blockhash: f } = yield t.getLatestBlockhash({
                            commitment: a(),
                          });
                          e.recentBlockhash = f;
                        }
                      }),
                ]);
                if (c.supports_sign_and_send_transactions)
                  return (yield o.signAndSendTransactions({
                    minContextSlot: s,
                    transactions: [e],
                  }))[0];
                {
                  let [h] = yield o.signTransactions({ transactions: [e] });
                  if (hR(h)) return yield t.sendTransaction(h);
                  {
                    let f = h.serialize();
                    return yield t.sendRawTransaction(
                      f,
                      Object.assign(Object.assign({}, r), {
                        preflightCommitment: a(),
                      })
                    );
                  }
                }
              })
            );
          } catch (o) {
            throw new gr(o?.message, o);
          }
        })
      );
    });
  }
  signTransaction(e) {
    return $e(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        $e(this, void 0, void 0, function* () {
          let [t] = yield this.performSignTransactions([e]);
          return t;
        })
      );
    });
  }
  signAllTransactions(e) {
    return $e(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        $e(this, void 0, void 0, function* () {
          return yield this.performSignTransactions(e);
        })
      );
    });
  }
  signMessage(e) {
    return $e(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        $e(this, void 0, void 0, function* () {
          let { authToken: t, selectedAddress: r } = this.assertIsAuthorized();
          try {
            return yield this.transact((i) =>
              $e(this, void 0, void 0, function* () {
                yield this.performReauthorization(i, t);
                let [s] = yield i.signMessages({
                  addresses: [r],
                  payloads: [e],
                });
                return s.slice(-Rz);
              })
            );
          } catch (i) {
            throw new iu(i?.message, i);
          }
        })
      );
    });
  }
  signIn(e) {
    return $e(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        $e(this, void 0, void 0, function* () {
          var t, r;
          if (
            this._readyState !== At.Installed &&
            this._readyState !== At.Loadable
          )
            throw new li();
          this._connecting = !0;
          try {
            let i = yield this.performAuthorization(
              Object.assign(Object.assign({}, e), {
                domain:
                  (t = e?.domain) !== null && t !== void 0
                    ? t
                    : window.location.host,
              })
            );
            if (!i.sign_in_result)
              throw new Error(
                "Sign in failed, no sign in result returned by wallet"
              );
            let s = i.sign_in_result.address;
            return {
              account: Object.assign(
                Object.assign(
                  {},
                  (r = i.accounts.find((a) => a.address == s)) !== null &&
                    r !== void 0
                    ? r
                    : { address: s }
                ),
                { publicKey: yg(s) }
              ),
              signedMessage: yg(i.sign_in_result.signed_message),
              signature: yg(i.sign_in_result.signature),
            };
          } catch (i) {
            throw new Gi(
              (i instanceof Error && i.message) || "Unknown error",
              i
            );
          } finally {
            this._connecting = !1;
          }
        })
      );
    });
  }
};
function fR() {
  return {
    select(n) {
      return $e(this, void 0, void 0, function* () {
        return n[0];
      });
    },
  };
}
var cA = "SolanaMobileWalletAdapterDefaultAuthorizationCache";
function dR() {
  let n;
  try {
    n = window.localStorage;
  } catch {}
  return {
    clear() {
      return $e(this, void 0, void 0, function* () {
        if (n)
          try {
            n.removeItem(cA);
          } catch {}
      });
    },
    get() {
      return $e(this, void 0, void 0, function* () {
        if (n)
          try {
            return JSON.parse(n.getItem(cA)) || void 0;
          } catch {}
      });
    },
    set(e) {
      return $e(this, void 0, void 0, function* () {
        if (n)
          try {
            n.setItem(cA, JSON.stringify(e));
          } catch {}
      });
    },
  };
}
function _z(n) {
  return $e(this, void 0, void 0, function* () {
    typeof window < "u" && window.location.assign(n.url);
  });
}
function pR() {
  return _z;
}
function Pz(n) {
  return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(
    n
  );
}
function gR({ adapters: n, userAgentString: e }) {
  return n.some((t) => t.name !== yh && t.readyState === At.Installed)
    ? 0
    : e && /android/i.test(e) && !Pz(e)
    ? 1
    : 0;
}
p();
function mR(n) {
  return n
    ? /devnet/i.test(n)
      ? "devnet"
      : /testnet/i.test(n)
      ? "testnet"
      : "mainnet-beta"
    : "mainnet-beta";
}
p();
var uA;
function Lz() {
  return uA === void 0 && (uA = globalThis.navigator?.userAgent ?? null), uA;
}
function yR(n) {
  let e = Lz();
  return gR({ adapters: n, userAgentString: e }) === 1;
}
p();
function wR() {
  let n = globalThis.location;
  if (n) return `${n.protocol}//${n.host}`;
}
p();
var bg = (n) => (e) => e.pipe(ct((t) => (t === null ? oe(null) : n(t))));
p();
var bR = (n) => n.pipe(xn((e) => e != null));
p();
var Oz = (n) => {
    try {
      let e = localStorage.getItem(n);
      return e ? JSON.parse(e) : null;
    } catch (e) {
      typeof window < "u" && console.error(e);
    }
    return null;
  },
  Ag = class extends hn {
    constructor(t) {
      super(Oz(t));
      this._key = t;
    }
    next(t) {
      try {
        t === null
          ? localStorage.removeItem(this._key)
          : localStorage.setItem(this._key, JSON.stringify(t));
      } catch (r) {
        typeof window < "u" && console.error(r);
      }
      super.next(t);
    }
  };
p();
var AR = (n, e, t) => (r) =>
    e ? Ke(pn(() => n.signMessage(r))) : Tt(() => t(new en())),
  lA = (n, e, t) => (r) =>
    e ? Ke(pn(() => n.signTransaction(r))) : Tt(() => t(new en())),
  hA = (n, e, t) => (r) =>
    e ? Ke(pn(() => n.signAllTransactions(r))) : Tt(() => t(new en())),
  ER = (n, e, t) => (r) =>
    e ? Ke(pn(() => n.signIn(r))) : Tt(() => t(new en()));
var xR = new Ae("connectionConfig"),
  SR = (n = {}) => ({
    provide: xR,
    useValue: v({ commitment: "confirmed" }, n),
  }),
  Ks = class n extends yc {
    constructor(t) {
      super({
        connection: new Jc(
          "https://methodical-palpable-violet.solana-mainnet.quiknode.pro/cce1ec237ae994965f7c92c256c74a302a7ae378/",
          "confirmed"
        ),
        endpoint:
          "https://methodical-palpable-violet.solana-mainnet.quiknode.pro/cce1ec237ae994965f7c92c256c74a302a7ae378/",
      });
      this._config = t;
    }
    _endpoint$ = this.select(this.state$, ({ endpoint: t }) => t);
    connection$ = this.select(this.state$, ({ connection: t }) => t);
    setEndpoint = this.updater((t, r) => $(v({}, t), { endpoint: r }));
    onEndpointChange = this.effect(() =>
      this._endpoint$.pipe(
        bR,
        Oe((t) => this.patchState({ connection: new Jc(t, this._config) }))
      )
    );
    static ɵfac = function (r) {
      return new (r || n)(le(xR, 8));
    };
    static ɵprov = ae({ token: n, factory: n.ɵfac });
  };
p();
p();
p();
p();
tu();
p();
var Nz, Fz, Mz, Uz, zz, jz;
(Nz = new WeakMap()),
  (Fz = new WeakMap()),
  (Mz = new WeakMap()),
  (Uz = new WeakMap()),
  (zz = new WeakMap()),
  (jz = new WeakMap());
function vR(n, e) {
  if (n === e) return !0;
  let t = n.length;
  if (t !== e.length) return !1;
  for (let r = 0; r < t; r++) if (n[r] !== e[r]) return !1;
  return !0;
}
var RR = Et(Hd(), 1);
var Nt = function (n, e, t, r, i) {
    if (r === "m") throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? n !== e || !i : !e.has(n))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it"
      );
    return r === "a" ? i.call(n, t) : i ? (i.value = t) : e.set(n, t), t;
  },
  ue = function (n, e, t, r) {
    if (t === "a" && !r)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? n !== e || !r : !e.has(n))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it"
      );
    return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n);
  },
  cn,
  $n,
  aa,
  ca,
  oa,
  wh,
  xg,
  Ge,
  Sg,
  fA,
  Eg,
  dA,
  bh,
  pA,
  IR,
  CR,
  kR,
  TR,
  vg = class extends su {
    constructor({ wallet: e }) {
      super(),
        cn.add(this),
        $n.set(this, void 0),
        aa.set(this, void 0),
        ca.set(this, void 0),
        oa.set(this, void 0),
        wh.set(this, void 0),
        xg.set(this, void 0),
        Ge.set(this, void 0),
        Sg.set(
          this,
          typeof window > "u" || typeof document > "u"
            ? At.Unsupported
            : At.Installed
        ),
        pA.set(this, (t) => {
          if ("accounts" in t) {
            let r = ue(this, Ge, "f").accounts[0];
            ue(this, $n, "f") &&
              !ue(this, oa, "f") &&
              r !== ue(this, $n, "f") &&
              (r
                ? ue(this, cn, "m", Eg).call(this, r)
                : (this.emit("error", new nu()),
                  ue(this, cn, "m", dA).call(this)));
          }
          "features" in t && ue(this, cn, "m", bh).call(this);
        }),
        Nt(this, Ge, e, "f"),
        Nt(this, $n, null, "f"),
        Nt(this, aa, null, "f"),
        Nt(this, ca, !1, "f"),
        Nt(this, oa, !1, "f"),
        Nt(
          this,
          wh,
          ue(this, Ge, "f").features[tg].on("change", ue(this, pA, "f")),
          "f"
        ),
        ue(this, cn, "m", bh).call(this);
    }
    get name() {
      return ue(this, Ge, "f").name;
    }
    get url() {
      return "https://github.com/solana-labs/wallet-standard";
    }
    get icon() {
      return ue(this, Ge, "f").icon;
    }
    get readyState() {
      return ue(this, Sg, "f");
    }
    get publicKey() {
      return ue(this, aa, "f");
    }
    get connecting() {
      return ue(this, ca, "f");
    }
    get supportedTransactionVersions() {
      return ue(this, xg, "f");
    }
    get wallet() {
      return ue(this, Ge, "f");
    }
    get standard() {
      return !0;
    }
    destroy() {
      Nt(this, $n, null, "f"),
        Nt(this, aa, null, "f"),
        Nt(this, ca, !1, "f"),
        Nt(this, oa, !1, "f");
      let e = ue(this, wh, "f");
      e && (Nt(this, wh, null, "f"), e());
    }
    autoConnect() {
      return d(this, null, function* () {
        return ue(this, cn, "m", fA).call(this, { silent: !0 });
      });
    }
    connect() {
      return d(this, null, function* () {
        return ue(this, cn, "m", fA).call(this);
      });
    }
    disconnect() {
      return d(this, null, function* () {
        if (_b in ue(this, Ge, "f").features)
          try {
            Nt(this, oa, !0, "f"),
              yield ue(this, Ge, "f").features[_b].disconnect();
          } catch (e) {
            this.emit("error", new Yp(e?.message, e));
          } finally {
            Nt(this, oa, !1, "f");
          }
        ue(this, cn, "m", dA).call(this);
      });
    }
    sendTransaction(i, s) {
      return d(this, arguments, function* (e, t, r = {}) {
        try {
          let a = ue(this, $n, "f");
          if (!a) throw new en();
          let c;
          if (fi in ue(this, Ge, "f").features)
            if (a.features.includes(fi)) c = fi;
            else if (
              jt in ue(this, Ge, "f").features &&
              a.features.includes(jt)
            )
              c = jt;
            else throw new Ki();
          else if (jt in ue(this, Ge, "f").features) {
            if (!a.features.includes(jt)) throw new Ki();
            c = jt;
          } else throw new Ws();
          let u = K2(t.rpcEndpoint);
          if (!a.chains.includes(u)) throw new gr();
          try {
            let o = r,
              { signers: l } = o,
              h = ln(o, ["signers"]),
              f;
            if (
              (hi(e)
                ? (l?.length && e.sign(l), (f = e.serialize()))
                : ((e = yield this.prepareTransaction(e, t, h)),
                  l?.length && e.partialSign(...l),
                  (f = new Uint8Array(
                    e.serialize({
                      requireAllSignatures: !1,
                      verifySignatures: !1,
                    })
                  ))),
              c === fi)
            ) {
              let [g] = yield ue(this, Ge, "f").features[
                fi
              ].signAndSendTransaction({
                account: a,
                chain: u,
                transaction: f,
                options: {
                  preflightCommitment: ng(
                    h.preflightCommitment || t.commitment
                  ),
                  skipPreflight: h.skipPreflight,
                  maxRetries: h.maxRetries,
                  minContextSlot: h.minContextSlot,
                },
              });
              return RR.default.encode(g.signature);
            } else {
              let [g] = yield ue(this, Ge, "f").features[jt].signTransaction({
                account: a,
                chain: u,
                transaction: f,
                options: {
                  preflightCommitment: ng(
                    h.preflightCommitment || t.commitment
                  ),
                  minContextSlot: h.minContextSlot,
                },
              });
              return yield t.sendRawTransaction(
                g.signedTransaction,
                $(v({}, h), {
                  preflightCommitment: ng(
                    h.preflightCommitment || t.commitment
                  ),
                })
              );
            }
          } catch (l) {
            throw l instanceof zt ? l : new gr(l?.message, l);
          }
        } catch (a) {
          throw (this.emit("error", a), a);
        }
      });
    }
  };
($n = new WeakMap()),
  (aa = new WeakMap()),
  (ca = new WeakMap()),
  (oa = new WeakMap()),
  (wh = new WeakMap()),
  (xg = new WeakMap()),
  (Ge = new WeakMap()),
  (Sg = new WeakMap()),
  (pA = new WeakMap()),
  (cn = new WeakSet()),
  (fA = function (e) {
    return d(this, null, function* () {
      try {
        if (this.connected || this.connecting) return;
        if (ue(this, Sg, "f") !== At.Installed) throw new li();
        if ((Nt(this, ca, !0, "f"), !ue(this, Ge, "f").accounts.length))
          try {
            yield ue(this, Ge, "f").features[eg].connect(e);
          } catch (r) {
            throw new Gi(r?.message, r);
          }
        let t = ue(this, Ge, "f").accounts[0];
        if (!t) throw new Ki();
        ue(this, cn, "m", Eg).call(this, t);
      } catch (t) {
        throw (this.emit("error", t), t);
      } finally {
        Nt(this, ca, !1, "f");
      }
    });
  }),
  (Eg = function (e) {
    let t;
    try {
      t = new J(e.address);
    } catch (r) {
      throw new ru(r?.message, r);
    }
    Nt(this, $n, e, "f"),
      Nt(this, aa, t, "f"),
      ue(this, cn, "m", bh).call(this),
      this.emit("connect", t);
  }),
  (dA = function () {
    Nt(this, $n, null, "f"),
      Nt(this, aa, null, "f"),
      ue(this, cn, "m", bh).call(this),
      this.emit("disconnect");
  }),
  (bh = function () {
    let e =
      fi in ue(this, Ge, "f").features
        ? ue(this, Ge, "f").features[fi].supportedTransactionVersions
        : ue(this, Ge, "f").features[jt].supportedTransactionVersions;
    Nt(this, xg, vR(e, ["legacy"]) ? null : new Set(e), "f"),
      jt in ue(this, Ge, "f").features &&
      ue(this, $n, "f")?.features.includes(jt)
        ? ((this.signTransaction = ue(this, cn, "m", IR)),
          (this.signAllTransactions = ue(this, cn, "m", CR)))
        : (delete this.signTransaction, delete this.signAllTransactions),
      ou in ue(this, Ge, "f").features &&
      ue(this, $n, "f")?.features.includes(ou)
        ? (this.signMessage = ue(this, cn, "m", kR))
        : delete this.signMessage,
      Xp in ue(this, Ge, "f").features
        ? (this.signIn = ue(this, cn, "m", TR))
        : delete this.signIn;
  }),
  (IR = function (e) {
    return d(this, null, function* () {
      try {
        let t = ue(this, $n, "f");
        if (!t) throw new en();
        if (!(jt in ue(this, Ge, "f").features)) throw new Ws();
        if (!t.features.includes(jt)) throw new Ki();
        try {
          let i = (yield ue(this, Ge, "f").features[jt].signTransaction({
            account: t,
            transaction: hi(e)
              ? e.serialize()
              : new Uint8Array(
                  e.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1,
                  })
                ),
          }))[0].signedTransaction;
          return hi(e) ? $i.deserialize(i) : Ne.from(i);
        } catch (r) {
          throw r instanceof zt ? r : new mr(r?.message, r);
        }
      } catch (t) {
        throw (this.emit("error", t), t);
      }
    });
  }),
  (CR = function (e) {
    return d(this, null, function* () {
      try {
        let t = ue(this, $n, "f");
        if (!t) throw new en();
        if (!(jt in ue(this, Ge, "f").features)) throw new Ws();
        if (!t.features.includes(jt)) throw new Ki();
        try {
          let r = yield ue(this, Ge, "f").features[jt].signTransaction(
            ...e.map((i) => ({
              account: t,
              transaction: hi(i)
                ? i.serialize()
                : new Uint8Array(
                    i.serialize({
                      requireAllSignatures: !1,
                      verifySignatures: !1,
                    })
                  ),
            }))
          );
          return e.map((i, s) => {
            let o = r[s].signedTransaction;
            return hi(i) ? $i.deserialize(o) : Ne.from(o);
          });
        } catch (r) {
          throw new mr(r?.message, r);
        }
      } catch (t) {
        throw (this.emit("error", t), t);
      }
    });
  }),
  (kR = function (e) {
    return d(this, null, function* () {
      try {
        let t = ue(this, $n, "f");
        if (!t) throw new en();
        if (!(ou in ue(this, Ge, "f").features)) throw new Ws();
        if (!t.features.includes(ou)) throw new Ki();
        try {
          return (yield ue(this, Ge, "f").features[ou].signMessage({
            account: t,
            message: e,
          }))[0].signature;
        } catch (r) {
          throw new iu(r?.message, r);
        }
      } catch (t) {
        throw (this.emit("error", t), t);
      }
    });
  }),
  (TR = function () {
    return d(this, arguments, function* (e = {}) {
      try {
        if (!(Xp in ue(this, Ge, "f").features)) throw new Ws();
        let t;
        try {
          [t] = yield ue(this, Ge, "f").features[Xp].signIn(e);
        } catch (r) {
          throw new oh(r?.message, r);
        }
        if (!t) throw new oh();
        return ue(this, cn, "m", Eg).call(this, t.account), t;
      } catch (t) {
        throw (this.emit("error", t), t);
      }
    });
  });
p();
var Wz = function (n, e, t, r) {
    if (t === "a" && !r)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? n !== e || !r : !e.has(n))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it"
      );
    return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n);
  },
  Hz = function (n, e, t, r, i) {
    if (r === "m") throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? n !== e || !i : !e.has(n))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it"
      );
    return r === "a" ? i.call(n, t) : i ? (i.value = t) : e.set(n, t), t;
  },
  Ig,
  nr,
  Cg = new Set();
function Vz(n) {
  (Ah = void 0), Cg.add(n);
}
function $z(n) {
  (Ah = void 0), Cg.delete(n);
}
var fu = {};
function Gz() {
  if (
    nr ||
    ((nr = Object.freeze({ register: BR, get: Kz, on: qz })),
    typeof window > "u")
  )
    return nr;
  let n = Object.freeze({ register: BR });
  try {
    window.addEventListener(
      "wallet-standard:register-wallet",
      ({ detail: e }) => e(n)
    );
  } catch (e) {
    console.error(
      `wallet-standard:register-wallet event listener could not be added
`,
      e
    );
  }
  try {
    window.dispatchEvent(new mA(n));
  } catch (e) {
    console.error(
      `wallet-standard:app-ready event could not be dispatched
`,
      e
    );
  }
  return nr;
}
function BR(...n) {
  return (
    (n = n.filter((e) => !Cg.has(e))),
    n.length
      ? (n.forEach((e) => Vz(e)),
        fu.register?.forEach((e) => gA(() => e(...n))),
        function () {
          n.forEach((t) => $z(t)),
            fu.unregister?.forEach((t) => gA(() => t(...n)));
        })
      : () => {}
  );
}
var Ah;
function Kz() {
  return Ah || (Ah = [...Cg]), Ah;
}
function qz(n, e) {
  return (
    fu[n]?.push(e) || (fu[n] = [e]),
    function () {
      fu[n] = fu[n]?.filter((r) => e !== r);
    }
  );
}
function gA(n) {
  try {
    n();
  } catch (e) {
    console.error(e);
  }
}
var mA = class extends Event {
  get detail() {
    return Wz(this, Ig, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(e) {
    super("wallet-standard:app-ready", {
      bubbles: !1,
      cancelable: !1,
      composed: !1,
    }),
      Ig.set(this, void 0),
      Hz(this, Ig, e, "f");
  }
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
Ig = new WeakMap();
function DR() {
  if (nr || ((nr = Gz()), typeof window > "u")) return nr;
  let n = window.navigator.wallets || [];
  if (!Array.isArray(n))
    return console.error("window.navigator.wallets is not an array"), nr;
  let { register: e } = nr,
    t = (...r) => r.forEach((i) => gA(() => i({ register: e })));
  try {
    Object.defineProperty(window.navigator, "wallets", {
      value: Object.freeze({ push: t }),
    });
  } catch {
    return console.error("window.navigator.wallets could not be set"), nr;
  }
  return t(...n), nr;
}
function _R(n) {
  return n.filter(H2).map((e) => new vg({ wallet: e }));
}
function PR(n, e) {
  return kh(
    (t) => n.on(e, (...r) => t(r)),
    (t) => t()
  );
}
var du = class n extends yc {
  _standardWallets = DR();
  _standardAdapters$ = this.select(({ standardAdapters: e }) => e);
  _adapters$ = this.select(({ adapters: e }) => e);
  adapters$ = this.select(this._adapters$, this._standardAdapters$, (e, t) => [
    ...t,
    ...e.filter(({ name: r }) => !t.some((i) => i.name === r)),
  ]);
  warnings$ = this.select(this._adapters$, this._standardAdapters$, (e, t) => [
    ...e
      .filter(({ name: r }) => t.some((i) => i.name === r))
      .map(({ name: r }) => r),
  ]);
  _addStandardAdapters = this.updater((e, t) =>
    $(v({}, e), { standardAdapters: [...e.standardAdapters, ..._R(t)] })
  );
  _removeStandardAdapters = this.updater((e, t) =>
    $(v({}, e), {
      standardAdapters: e.standardAdapters.filter((r) =>
        t.some((i) => i === r.wallet)
      ),
    })
  );
  setAdapters = this.updater((e, t) => $(v({}, e), { adapters: t }));
  _handleStandardAdaptersChange = this.effect(
    Oe(([e, t]) => {
      let r = new Set(t);
      new Set(e.filter((s) => !r.has(s))).forEach((s) => s.destroy());
    })
  );
  constructor() {
    super();
    let e = _R(this._standardWallets.get());
    e.forEach((t) => t.destroy()),
      this.setState({ adapters: [], standardAdapters: e }),
      this._addStandardAdapters(PR(this._standardWallets, "register")),
      this._removeStandardAdapters(PR(this._standardWallets, "unregister")),
      this._handleStandardAdaptersChange(this._standardAdapters$.pipe(Th()));
  }
  static ɵfac = function (t) {
    return new (t || n)();
  };
  static ɵprov = ae({ token: n, factory: n.ɵfac });
};
var kg = new Ae("walletConfig"),
  OR = (n) => ({
    provide: kg,
    useValue: v(
      { autoConnect: !1, localStorageKey: "walletName", adapters: [] },
      n ?? {}
    ),
  }),
  LR = {
    wallet: null,
    adapter: null,
    connected: !1,
    publicKey: null,
    readyState: null,
  },
  An = class n extends yc {
    _config = M(kg);
    _name = new Ag(this._config.localStorageKey);
    _unloading$ = this.select(({ unloading: e }) => e);
    _adapters$ = this.select(({ adapters: e }) => e);
    _adapter$ = this.select(({ adapter: e }) => e);
    _name$ = this._name.asObservable();
    _readyState$ = this.select(({ readyState: e }) => e);
    autoConnect$ = this.select(({ autoConnect: e }) => e);
    wallets$ = this.select(({ wallets: e }) => e);
    wallet$ = this.select(({ wallet: e }) => e);
    publicKey$ = this.select(({ publicKey: e }) => e);
    connecting$ = this.select(({ connecting: e }) => e);
    connected$ = this.select(({ connected: e }) => e);
    disconnecting$ = this.select(({ disconnecting: e }) => e);
    error$ = this.select(({ error: e }) => e);
    anchorWallet$ = this.select(
      this.publicKey$,
      this._adapter$,
      this.connected$,
      (e, t, r) =>
        e && t && "signTransaction" in t && "signAllTransactions" in t
          ? {
              publicKey: e,
              signTransaction: (i) => vu(lA(t, r, (s) => this._setError(s))(i)),
              signAllTransactions: (i) =>
                vu(hA(t, r, (s) => this._setError(s))(i)),
            }
          : void 0,
      { debounce: !0 }
    );
    constructor(e) {
      super(
        $(v({}, LR), {
          wallets: [],
          adapters: [],
          connecting: !1,
          disconnecting: !1,
          unloading: !1,
          autoConnect: e.autoConnect || !1,
          readyState: null,
          error: null,
        })
      ),
        this.setAdapters(this._config.adapters);
    }
    _setError = this.updater((e, t) =>
      $(v({}, e), { error: e.unloading ? e.error : t })
    );
    _setReadyState = this.updater((e, { readyState: t, walletName: r }) =>
      $(v({}, e), {
        wallets: e.wallets.map((i) =>
          i.adapter.name === r ? $(v({}, i), { readyState: t }) : i
        ),
        readyState: e.adapter?.name === r ? t : e.readyState,
      })
    );
    setAdapters = this.updater((e, t) =>
      $(v({}, e), {
        adapters: t,
        wallets: t.map((r) => ({ adapter: r, readyState: r.readyState })),
      })
    );
    onAdapterChangeDisconnectPreviousAdapter = this.effect(() =>
      this._adapter$.pipe(
        Th(),
        Sn(([e]) =>
          e && e.connected ? Ke(pn(() => e.disconnect())) : oe(null)
        )
      )
    );
    onWalletChanged = this.effect(() =>
      dn([this._name$, this.wallets$]).pipe(
        Oe(([e, t]) => {
          let r = t.find(({ adapter: i }) => i.name === e);
          r
            ? this.patchState({
                wallet: r,
                adapter: r.adapter,
                connected: r.adapter.connected,
                publicKey: r.adapter.publicKey,
                readyState: r.adapter.readyState,
              })
            : this.patchState(LR);
        })
      )
    );
    onAutoConnect = this.effect(() =>
      dn([
        this._adapter$,
        this._readyState$,
        this.autoConnect$,
        this.connecting$,
        this.connected$,
      ]).pipe(
        Sn(([e, t, r, i, s]) =>
          !r || e == null || (t !== At.Installed && t !== At.Loadable) || i || s
            ? fn
            : (this.patchState({ connecting: !0 }),
              Ke(pn(() => e.connect())).pipe(
                _n(() => (this.selectWallet(null), fn)),
                Wr(() => this.patchState({ connecting: !1 }))
              ))
        )
      )
    );
    onWindowUnload = this.effect(() =>
      typeof window > "u"
        ? oe(null)
        : KA(window, "beforeunload").pipe(
            Oe(() => this.patchState({ unloading: !0 }))
          )
    );
    onConnect = this.effect(() =>
      this._adapter$.pipe(
        bg((e) =>
          ch(e, "connect").pipe(
            Oe(() =>
              this.patchState({
                connected: e.connected,
                publicKey: e.publicKey,
              })
            )
          )
        )
      )
    );
    onDisconnect = this.effect(() =>
      this._adapter$.pipe(
        bg((e) =>
          ch(e, "disconnect").pipe(
            Sn(() => oe(null).pipe(Rh(this._unloading$))),
            xn(([, t]) => !t),
            Oe(() => this.selectWallet(null))
          )
        )
      )
    );
    onError = this.effect(() =>
      this._adapter$.pipe(
        bg((e) => ch(e, "error").pipe(Oe((t) => this._setError(t))))
      )
    );
    onReadyStateChanges = this.effect(() =>
      this._adapters$.pipe(
        ct((e) =>
          qA(
            ...e.map((t) =>
              ch(t, "readyStateChange").pipe(
                Oe((r) =>
                  this._setReadyState({ readyState: r, walletName: t.name })
                )
              )
            )
          )
        )
      )
    );
    selectWallet(e) {
      this._name.next(e);
    }
    connect() {
      return dn([
        this.connecting$,
        this.disconnecting$,
        this.connected$,
        this._adapter$,
        this._readyState$,
      ]).pipe(
        ir(),
        xn(([e, t, r]) => !r && !e && !t),
        Sn(([, , , e, t]) => {
          if (!e) {
            let r = new ah();
            return this._setError(r), Tt(() => r);
          }
          if (!(t === At.Installed || t === At.Loadable)) {
            this.selectWallet(null),
              typeof window < "u" && window.open(e.url, "_blank");
            let r = new li();
            return this._setError(r), Tt(() => r);
          }
          return (
            this.patchState({ connecting: !0 }),
            Ke(pn(() => e.connect())).pipe(
              _n((r) => (this.selectWallet(null), Tt(() => r))),
              Wr(() => this.patchState({ connecting: !1 }))
            )
          );
        })
      );
    }
    disconnect() {
      return dn([this.disconnecting$, this._adapter$]).pipe(
        ir(),
        xn(([e]) => !e),
        Sn(([, e]) =>
          e
            ? (this.patchState({ disconnecting: !0 }),
              Ke(pn(() => e.disconnect())).pipe(
                _n((t) => (this.selectWallet(null), Tt(() => t))),
                Wr(() => {
                  this.patchState({ disconnecting: !1 });
                })
              ))
            : (this.selectWallet(null), fn)
        )
      );
    }
    sendTransaction(e, t, r) {
      return dn([this._adapter$, this.connected$]).pipe(
        ir(),
        Sn(([i, s]) => {
          if (!i) {
            let o = new ah();
            return this._setError(o), Tt(() => o);
          }
          if (!s) {
            let o = new en();
            return this._setError(o), Tt(() => o);
          }
          return Ke(pn(() => i.sendTransaction(e, t, r)));
        })
      );
    }
    signTransaction(e) {
      let { adapter: t, connected: r } = this.get();
      return t && "signTransaction" in t
        ? lA(t, r, (i) => this._setError(i))(e)
        : void 0;
    }
    signAllTransactions(e) {
      let { adapter: t, connected: r } = this.get();
      return t && "signAllTransactions" in t
        ? hA(t, r, (i) => this._setError(i))(e)
        : void 0;
    }
    signMessage(e) {
      let { adapter: t, connected: r } = this.get();
      return t && "signMessage" in t
        ? AR(t, r, (i) => this._setError(i))(e)
        : void 0;
    }
    signIn(e) {
      let { adapter: t, connected: r } = this.get();
      return t && "signIn" in t
        ? ER(t, r, (i) => this._setError(i))(e)
        : void 0;
    }
    static ɵfac = function (t) {
      return new (t || n)(le(kg));
    };
    static ɵprov = ae({ token: n, factory: n.ɵfac });
  },
  NR = {
    provide: An,
    useFactory: (n, e, t) => {
      let r = dn([n.connection$, e.adapters$]).pipe(
          xe(([o, a]) => {
            if (!yR(a)) return null;
            let c = a.find((u) => u.name === yh);
            return (
              c ||
              new wg({
                addressSelector: fR(),
                appIdentity: { uri: wR() },
                authorizationResultCache: dR(),
                cluster: mR(o?.rpcEndpoint),
                onWalletNotFound: pR(),
              })
            );
          })
        ),
        i = dn([r, e.adapters$]).pipe(
          xe(([o, a]) => (o == null || a.indexOf(o) !== -1 ? a : [o, ...a]))
        ),
        s = new An(t);
      return s.setAdapters(i), s;
    },
    deps: [Ks, du, kg],
  };
p();
p();
function Qz() {
  let n = M(Ks);
  return Ii(n.connection$, { initialValue: null });
}
p();
p();
p();
tu();
p();
function noe() {
  let n = M(An);
  return Ii(n.wallet$, { initialValue: null });
}
p();
function coe() {
  let n = M(An);
  return Ii(n.wallets$, { initialValue: [] });
}
p();
function moe(n, e) {
  return [OR(n), SR(e), Oy(Ks), Oy(du), NR];
}
p();
p();
var Poe = Et(HB(), 1);
var Ooe = Et(um(), 1);
var Foe = Et(VB(), 1);
var Moe = Et($B(), 1),
  Uoe = Et(jE(), 1);
p();
var vB = Et(mB(), 1);
p();
var Z = (function (n) {
    return (
      (n.AlphaWallet = "isAlphaWallet"),
      (n.ApexWallet = "isApexWallet"),
      (n.AToken = "isAToken"),
      (n.BifrostWallet = "isBifrost"),
      (n.Binance = "bbcSignTx"),
      (n.Bitpie = "isBitpie"),
      (n.BlockWallet = "isBlockWallet"),
      (n.Coinbase = "isToshi"),
      (n.CoinbaseExtension = "isCoinbaseWallet"),
      (n.Detected = "request"),
      (n.Dcent = "isDcentWallet"),
      (n.Exodus = "isExodus"),
      (n.Frontier = "isFrontier"),
      (n.Frame = "isFrame"),
      (n.HuobiWallet = "isHbWallet"),
      (n.HyperPay = "isHyperPay"),
      (n.ImToken = "isImToken"),
      (n.InfinityWallet = "isInfinityWallet"),
      (n.Liquality = "isLiquality"),
      (n.MeetOne = "wallet"),
      (n.MetaMask = "isMetaMask"),
      (n.MyKey = "isMYKEY"),
      (n.OwnBit = "isOwnbit"),
      (n.Status = "isStatus"),
      (n.Trust = "isTrust"),
      (n.TokenPocket = "isTokenPocket"),
      (n.TP = "isTp"),
      (n.WalletIo = "isWalletIO"),
      (n.XDEFI = "isXDEFI"),
      (n.OneInch = "isOneInchIOSWallet"),
      (n.Tokenary = "isTokenary"),
      (n.Tally = "isTally"),
      (n.BraveWallet = "isBraveWallet"),
      (n.Rabby = "isRabby"),
      (n.MathWallet = "isMathWallet"),
      (n.Bitget = "isBitKeep"),
      (n.Sequence = "isSequence"),
      (n.Core = "isAvalanche"),
      (n.Opera = "isOpera"),
      (n.Bitski = "isBitski"),
      (n.Enkrypt = "isEnkrypt"),
      (n.Phantom = "isPhantom"),
      (n.OKXWallet = "isOkxWallet"),
      (n.Zeal = "isZeal"),
      (n.Zerion = "isZerion"),
      (n.Rainbow = "isRainbow"),
      (n.SafePal = "isSafePal"),
      (n.DeFiWallet = "isDeficonnectProvider"),
      (n.Safeheron = "isSafeheron"),
      (n.Talisman = "isTalisman"),
      (n.OneKey = "isOneKey"),
      (n.Fordefi = "isFordefi"),
      (n.Coin98Wallet = "isCoin98"),
      (n.SubWallet = "isSubWallet"),
      (n.Kayros = "isKayros"),
      (n.FoxWallet = "isFoxWallet"),
      (n.Lif3Wallet = "isLif3Wallet"),
      (n.ZodiacPilot = "isZodiacPilot"),
      (n.StableWallet = "isStableWallet"),
      (n.Echooo = "isEchooo"),
      (n.Keplr = "keplr"),
      n
    );
  })(Z || {}),
  tn = (function (n) {
    return (
      (n.Binance =
        "https://www.bnbchain.org/ru/blog/binance-extension-wallet/"),
      (n.Bitget = "https://web3.bitget.com/en/wallet-download"),
      (n.Coinbase = "https://www.coinbase.com/wallet/downloads"),
      (n.MetaMask = "https://metamask.io/download/"),
      (n.OKXWallet = "https://okx.com/download"),
      (n.Phantom = "https://phantom.app/ul/v1/connect"),
      (n.Talisman = "https://www.talisman.xyz/"),
      (n.Trust = "https://link.trustwallet.com"),
      (n.OneKey = "https://onekey.so/download/"),
      (n.RoninWallet = "https://wallet.skymavis.com/"),
      (n.Coin98Wallet = "https://coin98.com/wallet/"),
      (n.SubWallet = "https://www.subwallet.app/"),
      (n.Kayros = "https://www.kayros.games/wallet/"),
      (n.XDEFI = "https://xdefi.io/"),
      (n.FoxWallet = "https://foxwallet.com/download"),
      (n.Lif3Wallet = "https://lif3.com"),
      (n.Rabby = "https://rabby.io"),
      (n.ZodiacPilot = "https://pilot.gnosisguild.org/"),
      (n.Echooo = "https://www.echooo.xyz"),
      (n.Keplr = "https://www.keplr.app/download"),
      n
    );
  })(tn || {}),
  se = (function (n) {
    return (
      (n.AlphaWallet = "AlphaWallet"),
      (n.ApexWallet = "Apex Wallet"),
      (n.AToken = "AToken"),
      (n.BifrostWallet = "Bifrost Wallet"),
      (n.Binance = "Binance Smart Wallet"),
      (n.Bitpie = "Bitpie"),
      (n.Bitski = "Bitski"),
      (n.BlockWallet = "BlockWallet"),
      (n.Brave = "Brave Wallet"),
      (n.Coinbase = "Coinbase Wallet"),
      (n.Dcent = "D'CENT"),
      (n.Detected = "Detected Wallet"),
      (n.Exodus = "Exodus"),
      (n.Frame = "Frame"),
      (n.Frontier = "Frontier"),
      (n.HuobiWallet = "Huobi Wallet"),
      (n.HyperPay = "HyperPay"),
      (n.ImToken = "imToken"),
      (n.InfinityWallet = "Infinity Wallet"),
      (n.Liquality = "Liquality"),
      (n.MeetOne = "MeetOne"),
      (n.MetaMask = "MetaMask"),
      (n.MyKey = "MyKey"),
      (n.Opera = "Opera Wallet"),
      (n.OwnBit = "OwnBit"),
      (n.Status = "Status Wallet"),
      (n.Trust = "Trust Wallet"),
      (n.TokenPocket = "TokenPocket"),
      (n.TP = "TP Wallet"),
      (n.WalletIo = "Wallet.io"),
      (n.XDEFI = "XDEFI Wallet"),
      (n.OneInch = "1inch Wallet"),
      (n.Tokenary = "Tokenary Wallet"),
      (n.Tally = "Taho"),
      (n.Rabby = "Rabby Wallet"),
      (n.MathWallet = "MathWallet"),
      (n.Bitget = "Bitget Wallet"),
      (n.Sequence = "Sequence"),
      (n.Core = "Core"),
      (n.Enkrypt = "Enkrypt"),
      (n.Zeal = "Zeal"),
      (n.Phantom = "Phantom"),
      (n.OKXWallet = "OKX Wallet"),
      (n.Zerion = "Zerion"),
      (n.Rainbow = "Rainbow"),
      (n.SafePal = "SafePal"),
      (n.DeFiWallet = "DeFi Wallet"),
      (n.Safeheron = "Safeheron"),
      (n.Talisman = "Talisman"),
      (n.OneKey = "OneKey"),
      (n.Fordefi = "Fordefi"),
      (n.RoninWallet = "Ronin Wallet"),
      (n.Coin98Wallet = "Coin98 Wallet"),
      (n.SubWallet = "SubWallet"),
      (n.Kayros = "Kayros"),
      (n.FoxWallet = "FoxWallet"),
      (n.Lif3Wallet = "Lif3 Wallet"),
      (n.ZodiacPilot = "Zodiac Pilot"),
      (n.StableWallet = "StableWallet"),
      (n.Echooo = "Echooo"),
      (n.Keplr = "Keplr"),
      n
    );
  })(se || {}),
  re = (function (n) {
    return (
      (n.Ethereum = "ethereum"),
      (n.Binance = "BinanceChain"),
      (n.Tally = "tally"),
      (n.Web3 = "web3"),
      (n.Arbitrum = "arbitrum"),
      (n.XFI = "xfi"),
      (n.Bitget = "bitkeep"),
      (n.Avalanche = "avalanche"),
      (n.Bitski = "Bitski"),
      (n.Enkrypt = "enkrypt"),
      (n.Zeal = "zeal"),
      (n.Phantom = "phantom"),
      (n.OKXWallet = "okxwallet"),
      (n.Trust = "trustwallet"),
      (n.Frontier = "frontier"),
      (n.DeFiConnectProvider = "deficonnectProvider"),
      (n.Safeheron = "safeheron"),
      (n.Talisman = "talismanEth"),
      (n.OneKey = "$onekey"),
      (n.RoninWallet = "ronin"),
      (n.Coin98Wallet = "coin98"),
      (n.SubWallet = "SubWallet"),
      (n.Kayros = "kayros"),
      (n.FoxWallet = "foxwallet"),
      (n.Echooo = "echooo"),
      n
    );
  })(re || {});
p();
var Ft = null;
function Rn(n, e) {
  return () =>
    d(this, null, function* () {
      return {
        provider:
          window.ethereum.providers && Array.isArray(window.ethereum.providers)
            ? jj(n, e)
            : window.ethereum,
      };
    });
}
function jj(n, e) {
  return window.ethereum.providers.find((t) =>
    e ? !!t[n] && !yB(n, t) : !!t[n]
  );
}
function yB(n, e) {
  return Object.values(Z)
    .filter((r) => r !== n && r !== Z.Detected)
    .some((r) => !!e[r]);
}
var Wj = {
    label: se.MetaMask,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) =>
      !!n && !!n[Z.MetaMask] && !yB(Z.MetaMask, n),
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-FLYZ6PDY.js")).default;
      }),
    getInterface: Rn(Z.MetaMask, !0),
    platforms: ["all"],
    externalUrl: tn.MetaMask,
  },
  Hj = {
    label: se.InfinityWallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.InfinityWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-O5AQ6PAO.js")).default;
      }),
    getInterface: Rn(Z.InfinityWallet),
    platforms: ["desktop"],
  },
  Vj = {
    label: se.Exodus,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Exodus],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-SFRT7G64.js")).default;
      }),
    getInterface: Rn(Z.Exodus),
    platforms: ["all"],
  },
  $j = {
    label: se.Frontier,
    injectedNamespace: re.Frontier,
    checkProviderIdentity: ({ provider: n }) =>
      !!n && !!n.ethereum && !!n.ethereum[Z.Frontier],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-XKTPCU75.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.frontier.ethereum) };
      }),
    platforms: ["all"],
  },
  Gj = {
    label: se.Brave,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.BraveWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-Z3UJ2OWW.js")).default;
      }),
    getInterface: Rn(Z.BraveWallet),
    platforms: ["all"],
  },
  Kj = {
    label: se.Binance,
    injectedNamespace: re.Binance,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Binance],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-R5A6ERNM.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        let n = v({}, window.BinanceChain);
        window.BinanceChain = n;
        let e = window.BinanceChain.on.bind(window.BinanceChain);
        window.BinanceChain.on = (r, i) => {
          r === "chainChanged"
            ? e(r, (s) => {
                i(`0x${parseInt(s).toString(16)}`);
              })
            : e(r, i);
        };
        let t = je(window.BinanceChain, {
          eth_chainId: ({ baseRequest: r }) =>
            r({ method: "eth_chainId" }).then(
              (i) => `0x${parseInt(i).toString(16)}`
            ),
          eth_selectAccounts: Ft,
          wallet_switchEthereumChain: Ft,
        });
        return (t.removeListener = (r, i) => {}), { provider: t };
      }),
    platforms: ["desktop"],
    externalUrl: tn.Binance,
  },
  qj = {
    label: se.Coinbase,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) =>
      (!!n && !!n[Z.Coinbase]) || (!!n && !!n[Z.CoinbaseExtension]),
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-JX5UXXKD.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        let { provider: n } = yield Rn(Z.CoinbaseExtension)(),
          e = n.on.bind(n);
        return (
          (n.on = (t, r) => {
            t === "chainChanged"
              ? e(t, (i) => {
                  r(`0x${parseInt(i).toString(16)}`);
                })
              : e(t, r);
          }),
          { provider: n }
        );
      }),
    platforms: ["all"],
    externalUrl: tn.Coinbase,
  },
  Qj = {
    label: se.Detected,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Detected],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-QPLRKSEW.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: window.ethereum };
      }),
    platforms: ["all"],
  },
  Jj = {
    label: se.Trust,
    injectedNamespace: re.Trust,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Trust],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-WZ4J4RXE.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        let n = window.hasOwnProperty(re.Ethereum),
          e;
        return (
          n && window[re.Ethereum].isTrust
            ? (e = window[re.Ethereum])
            : (e = window[re.Trust]),
          { provider: e }
        );
      }),
    platforms: ["all"],
    externalUrl: tn.Trust,
  },
  Yj = {
    label: se.Opera,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Opera],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-OO45XPNB.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return {
          provider: je(window.ethereum, {
            eth_requestAccounts: (e) =>
              d(void 0, [e], function* ({ baseRequest: n }) {
                return n({ method: "eth_accounts" });
              }),
            eth_selectAccounts: Ft,
          }),
        };
      }),
    platforms: ["all"],
  },
  Zj = {
    label: se.Status,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Status],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-UCEV76SU.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: window.ethereum };
      }),
    platforms: ["mobile"],
  },
  Xj = {
    label: se.AlphaWallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.AlphaWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-67WM7CFO.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return {
          provider: je(window.ethereum, {
            wallet_switchEthereumChain: Ft,
            eth_selectAccounts: Ft,
          }),
        };
      }),
    platforms: ["mobile"],
  },
  e7 = {
    label: se.ApexWallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.ApexWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-4PMYAGCT.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: window.ethereum };
      }),
    platforms: ["desktop", "Chrome", "Chromium", "Microsoft Edge"],
  },
  t7 = {
    label: se.AToken,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.AToken],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-RUHUEMIK.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: window.ethereum };
      }),
    platforms: ["mobile"],
  },
  n7 = {
    label: se.BifrostWallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.BifrostWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-PP4FHC7O.js")).default;
      }),
    getInterface: Rn(Z.BifrostWallet),
    platforms: ["all"],
  },
  r7 = {
    label: se.Bitpie,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: () => !!window.Bitpie,
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-VVPBGTWU.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return {
          provider: je(window.ethereum, {
            wallet_switchEthereumChain: Ft,
            eth_selectAccounts: Ft,
          }),
        };
      }),
    platforms: ["mobile"],
  },
  i7 = {
    label: se.BlockWallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.BlockWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-WIRYPAG5.js")).default;
      }),
    getInterface: Rn(Z.BlockWallet),
    platforms: ["desktop"],
  },
  s7 = {
    label: se.Frame,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Frame],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-QWMGWRC3.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        let n = window.ethereum;
        if (!n || !n.connected)
          throw new Error(
            "Frame App must be open with a hot wallet connected. If not installed first download the Frame App."
          );
        return { provider: n };
      }),
    platforms: ["desktop"],
  },
  o7 = {
    label: se.HuobiWallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.HuobiWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-R67HZUN2.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return {
          provider: je(window.ethereum, {
            wallet_switchEthereumChain: Ft,
            eth_selectAccounts: Ft,
          }),
        };
      }),
    platforms: ["mobile"],
  },
  a7 = {
    label: se.HyperPay,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: () => !!window.hiWallet,
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-NCKXKZ65.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return {
          provider: je(window.ethereum, {
            wallet_switchEthereumChain: Ft,
            eth_selectAccounts: Ft,
          }),
        };
      }),
    platforms: ["mobile"],
  },
  c7 = {
    label: se.ImToken,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.ImToken],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-HV67DASS.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.ethereum, { eth_selectAccounts: Ft }) };
      }),
    platforms: ["mobile"],
  },
  u7 = {
    label: se.Liquality,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Liquality],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-TICMJQDQ.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        let n = je(window.ethereum, {
          wallet_switchEthereumChain: Ft,
          eth_selectAccounts: Ft,
        });
        return (n.removeListener = (e, t) => {}), { provider: n };
      }),
    platforms: ["desktop"],
  },
  l7 = {
    label: se.MeetOne,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) =>
      !!n && n[Z.MeetOne] === "MEETONE",
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-PIADZULV.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: window.ethereum };
      }),
    platforms: ["mobile"],
  },
  h7 = {
    label: se.MyKey,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.MyKey],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-CGSXTBEF.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: window.ethereum };
      }),
    platforms: ["mobile"],
  },
  f7 = {
    label: se.OwnBit,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.OwnBit],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-L3WHIV2E.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        let n = je(window.ethereum, {
          eth_chainId: ({ baseRequest: e }) =>
            e({ method: "eth_chainId" }).then(
              (t) => `0x${parseInt(t).toString(16)}`
            ),
          wallet_switchEthereumChain: Ft,
          eth_selectAccounts: Ft,
        });
        return (
          (n.removeListener = (e, t) => {}),
          (n.on = (e, t) => {}),
          { provider: n }
        );
      }),
    platforms: ["mobile"],
  },
  d7 = {
    label: se.TokenPocket,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) =>
      !!n && !!n[Z.TokenPocket] && !n[Z.TP],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-C7DPFWOG.js")).default;
      }),
    getInterface: Rn(Z.TokenPocket),
    platforms: ["all"],
  },
  p7 = {
    label: se.TP,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.TP],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-4IG5YBAQ.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return {
          provider: je(window.ethereum, {
            wallet_switchEthereumChain: Ft,
            eth_selectAccounts: Ft,
          }),
        };
      }),
    platforms: ["mobile"],
  },
  g7 = {
    label: se.XDEFI,
    injectedNamespace: re.XFI,
    checkProviderIdentity: ({ provider: n }) =>
      n && n.ethereum && n.ethereum[Z.XDEFI],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-H2G5LXGM.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: window.xfi && window.xfi.ethereum };
      }),
    platforms: ["all"],
    externalUrl: tn.XDEFI,
  },
  m7 = {
    label: se.OneInch,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.OneInch],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-JHGPPTIX.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.ethereum) };
      }),
    platforms: ["mobile"],
  },
  y7 = {
    label: se.Tokenary,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Tokenary],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-Z2NXUIMW.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.ethereum) };
      }),
    platforms: ["all"],
  },
  w7 = {
    label: se.Tally,
    injectedNamespace: re.Tally,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Tally],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-P7ACW3YE.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.tally) };
      }),
    platforms: ["desktop"],
  },
  b7 = {
    label: se.Zeal,
    injectedNamespace: re.Zeal,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Zeal],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-OSNABW3B.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.zeal) };
      }),
    platforms: ["desktop"],
  },
  A7 = {
    label: se.Rabby,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Rabby],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-UACFESPN.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.ethereum) };
      }),
    platforms: ["desktop", "mobile"],
  },
  E7 = {
    label: se.MathWallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.MathWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-HBN5BVTL.js")).default;
      }),
    getInterface: Rn(Z.MathWallet),
    platforms: ["all"],
  },
  x7 = {
    label: se.Bitget,
    injectedNamespace: re.Bitget,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n.ethereum[Z.Bitget],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-NICPIVNV.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: window.bitkeep && window.bitkeep.ethereum };
      }),
    platforms: ["all"],
    externalUrl: tn.Bitget,
  },
  S7 = {
    label: se.Sequence,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Sequence],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-A2Z6YULT.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: window.ethereum };
      }),
    platforms: ["all"],
  },
  v7 = {
    label: se.Core,
    injectedNamespace: re.Avalanche,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Core],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-L3JDZ2NQ.js")).default;
      }),
    getInterface: Rn(Z.Core),
    platforms: ["desktop", "Chrome", "Chromium", "Microsoft Edge"],
  },
  I7 = {
    label: se.Bitski,
    injectedNamespace: re.Bitski,
    checkProviderIdentity: ({ provider: n }) =>
      !!n && !!n.getProvider && !!n.getProvider().isBitski,
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-IBN2522G.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return {
          provider:
            window.Bitski &&
            window.Bitski.getProvider &&
            window.Bitski.getProvider(),
        };
      }),
    platforms: ["all"],
  },
  C7 = {
    label: se.Zerion,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Zerion],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-HGTWKCD5.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.ethereum) };
      }),
    platforms: ["all"],
  },
  k7 = {
    label: se.Enkrypt,
    injectedNamespace: re.Enkrypt,
    checkProviderIdentity: ({ provider: n }) =>
      !!n && !!n.providers && !!n.providers.ethereum,
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-IAR4KIMD.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        let n = window.enkrypt.providers.ethereum.on.bind(
          window.enkrypt.providers.ethereum
        );
        window.enkrypt.providers.ethereum.on = (t, r) => {
          t === "chainChanged"
            ? n(t, (i) => {
                r(`0x${parseInt(i).toString(16)}`);
              })
            : n(t, r);
        };
        let e = je(window.enkrypt.providers.ethereum, {
          eth_chainId: ({ baseRequest: t }) =>
            t({ method: "eth_chainId" }).then(
              (r) => `0x${parseInt(r).toString(16)}`
            ),
        });
        return (e.removeListener = (t, r) => {}), { provider: e };
      }),
    platforms: ["all"],
  },
  T7 = {
    label: se.Phantom,
    injectedNamespace: re.Phantom,
    checkProviderIdentity: ({ provider: n }) =>
      !!n && !!n.ethereum && !!n.ethereum[Z.Phantom],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-2GTVDJQA.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.phantom.ethereum) };
      }),
    platforms: ["all"],
    externalUrl: tn.Phantom,
  },
  R7 = {
    label: se.SafePal,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.SafePal],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-UZGM5UHG.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.ethereum) };
      }),
    platforms: ["all"],
  },
  B7 = {
    label: se.Rainbow,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Rainbow],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-YN2WCTSP.js")).default;
      }),
    getInterface: Rn(Z.Rainbow),
    platforms: ["all"],
  },
  D7 = {
    label: se.OKXWallet,
    injectedNamespace: re.OKXWallet,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.OKXWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-4HIHMSUM.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.okxwallet) };
      }),
    platforms: ["all"],
    externalUrl: tn.OKXWallet,
  },
  _7 = {
    label: se.DeFiWallet,
    injectedNamespace: re.DeFiConnectProvider,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.DeFiWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-3C3BFC3F.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.deficonnectProvider) };
      }),
    platforms: ["all"],
  },
  P7 = {
    label: se.Safeheron,
    injectedNamespace: re.Safeheron,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Safeheron],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-UKPAVD4L.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.safeheron) };
      }),
    platforms: ["desktop", "Chrome", "Chromium", "Microsoft Edge"],
  },
  L7 = {
    label: se.Talisman,
    injectedNamespace: re.Talisman,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Talisman],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-KHYKLGZG.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.talismanEth) };
      }),
    platforms: ["desktop"],
    externalUrl: tn.Talisman,
  },
  O7 = {
    label: se.RoninWallet,
    injectedNamespace: re.RoninWallet,
    checkProviderIdentity: ({ provider: n }) => !!n,
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-OSXILTK7.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.ronin.provider) };
      }),
    platforms: ["all"],
    externalUrl: tn.RoninWallet,
  },
  N7 = {
    label: se.OneKey,
    injectedNamespace: re.OneKey,
    checkProviderIdentity: ({ provider: n }) =>
      !!n && !!n.ethereum && !!n.ethereum[Z.OneKey],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-NR3O2OHD.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.$onekey.ethereum) };
      }),
    platforms: ["all"],
    externalUrl: tn.OneKey,
  },
  F7 = {
    label: se.Fordefi,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Fordefi],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-AKK7M24E.js")).default;
      }),
    getInterface: Rn(Z.Fordefi, !0),
    platforms: ["desktop"],
  },
  M7 = {
    label: se.Coin98Wallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Coin98Wallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-MNBQ2DSG.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        let n = window.hasOwnProperty(re.Ethereum),
          e;
        return (
          n && window[re.Ethereum].isCoin98
            ? (e = window[re.Ethereum])
            : (e = window[re.Coin98Wallet].provider),
          { provider: e }
        );
      }),
    platforms: ["all"],
    externalUrl: tn.Coin98Wallet,
  },
  U7 = {
    label: se.SubWallet,
    injectedNamespace: re.SubWallet,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.SubWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-GR23SEPV.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.SubWallet) };
      }),
    platforms: ["all"],
    externalUrl: tn.SubWallet,
  },
  z7 = {
    label: se.Kayros,
    injectedNamespace: re.Kayros,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Kayros],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-VGFL5DFK.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.kayros) };
      }),
    platforms: ["desktop"],
  },
  j7 = {
    label: se.FoxWallet,
    injectedNamespace: re.FoxWallet,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.FoxWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-I5JVQ233.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.foxwallet) };
      }),
    platforms: ["mobile"],
  },
  W7 = {
    label: se.Lif3Wallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Lif3Wallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-BREZLAAN.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return {
          provider: je(window.ethereum, {
            wallet_switchEthereumChain: Ft,
            eth_selectAccounts: Ft,
          }),
        };
      }),
    platforms: ["mobile"],
  },
  H7 = {
    label: se.ZodiacPilot,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.ZodiacPilot],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-SKLIYAYD.js")).default;
      }),
    getInterface: () =>
      d(void 0, null, function* () {
        return { provider: je(window.ethereum) };
      }),
    platforms: ["desktop"],
    externalUrl: tn.ZodiacPilot,
  },
  V7 = {
    label: se.StableWallet,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.StableWallet],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-2GTJ53SK.js")).default;
      }),
    getInterface: Rn(Z.StableWallet),
    platforms: ["mobile"],
  },
  $7 = {
    label: se.Echooo,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Echooo],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-7X6RW3SK.js")).default;
      }),
    getInterface: Rn(Z.Echooo),
    platforms: ["all"],
    externalUrl: tn.Echooo,
  },
  G7 = {
    label: se.Keplr,
    injectedNamespace: re.Ethereum,
    checkProviderIdentity: ({ provider: n }) => !!n && !!n[Z.Keplr],
    getIcon: () =>
      d(void 0, null, function* () {
        return (yield import("./chunk-CMDUB4RE.js")).default;
      }),
    getInterface: Rn(Z.Keplr),
    platforms: ["all"],
    externalUrl: tn.Keplr,
  },
  K7 = [
    b7,
    Vj,
    $j,
    Wj,
    n7,
    Kj,
    qj,
    Qj,
    Jj,
    Yj,
    Zj,
    Xj,
    e7,
    t7,
    x7,
    r7,
    i7,
    Gj,
    s7,
    o7,
    a7,
    c7,
    u7,
    l7,
    h7,
    f7,
    d7,
    p7,
    g7,
    m7,
    y7,
    w7,
    A7,
    E7,
    S7,
    v7,
    I7,
    k7,
    T7,
    D7,
    C7,
    B7,
    R7,
    _7,
    Hj,
    P7,
    L7,
    N7,
    F7,
    O7,
    M7,
    U7,
    z7,
    j7,
    W7,
    H7,
    V7,
    $7,
    G7,
  ],
  wB = K7;
p();
var Qe = Et(um(), 1);
var q7 = Qe.default.object({
    label: Qe.default.string().required(),
    getIcon: Qe.default.function().arity(0).required(),
    getInterface: Qe.default.function().maxArity(1).required(),
    injectedNamespace: Qe.default.string().required(),
    checkProviderIdentity: Qe.default.function().arity(1).required(),
    platforms: Qe.default.array().items(Qe.default.string()),
    externalUrl: Qe.default.string(),
  }),
  Q7 = Qe.default.array().items(q7),
  J7 = Qe.default
    .object()
    .pattern(
      /\w+/,
      Qe.default
        .any()
        .allow(
          Qe.default.boolean(),
          Qe.default.array().items(Qe.default.string())
        )
    ),
  Y7 = Qe.default.object({
    custom: Q7,
    filter: J7,
    displayUnavailable: [
      Qe.default.boolean(),
      Qe.default.array().items(Qe.default.string()),
    ],
    walletUnavailableMessage: Qe.default.function(),
    sort: Qe.default.function(),
    externalUrl: Qe.default.string(),
    disable6963Support: Qe.default.boolean(),
  }),
  bB = (n) => lm(Y7, n),
  Z7 = Qe.default.object({
    uuid: Qe.default.string().required(),
    name: Qe.default.string().required(),
    icon: Qe.default.string().required(),
    rdns: Qe.default.string().required(),
  }),
  X7 = Qe.default.object({
    info: Z7.required(),
    provider: Qe.default.object().required(),
  }),
  AB = (n) => lm(X7, n);
p();
var EB = ({ label: n, externalUrl: e }) =>
    e
      ? `Please <a href="${e}" target="_blank">install or switch to</a> ${n} to continue`
      : `Please install or enable ${n} to continue`,
  xB = (n, e, t) =>
    n
      ? e({ provider: n, device: t })
        ? !0
        : !!n.providers?.some((r) => e({ provider: r, device: t }))
      : !1;
function SB(n) {
  if (!n) return !1;
  let e = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    t = /\bon[a-z]+\s*=\s*["']?(?:javascript:)?/gi,
    r = /\b(href|xlink:href)\s*=\s*["']?javascript:/gi;
  return !!(e.test(n) || t.test(n) || r.test(n));
}
var IB = [];
function eW() {
  window.addEventListener("eip6963:announceProvider", (n) => {
    let e = n,
      { detail: t } = e;
    if (!t) return;
    if (e) {
      let a = AB(t);
      if (a && a.error) throw a.error;
    }
    let { info: r, provider: i } = t,
      { name: s, icon: o } = r;
    if (SB(o)) {
      console.error(
        `The icon for injected wallet: ${s} contains executable JavaScript and has been blocked.`
      );
      return;
    }
    IB.push({
      label: s,
      getIcon: () =>
        d(this, null, function* () {
          return o;
        }),
      getInterface: () =>
        d(this, null, function* () {
          return { provider: i };
        }),
      platforms: ["all"],
      eip6963Provider: i,
      checkProviderIdentity: ({ provider: a }) => !!a,
    });
  }),
    window.dispatchEvent(new CustomEvent("eip6963:requestProvider"));
}
function tW(n) {
  if (typeof window > "u") return () => null;
  if (n) {
    let e = bB(n);
    if (e && e.error) throw e.error;
  }
  return (
    !n?.disable6963Support && eW(),
    (e) => {
      let { device: t } = e,
        {
          custom: r = [],
          filter: i = {},
          displayUnavailable: s,
          sort: o,
          walletUnavailableMessage: a,
        } = n || {},
        u = (0, vB.default)([...r, ...IB, ...wB], ({ label: l }) => l).reduce(
          (l, h) => {
            let {
                label: f,
                platforms: g,
                injectedNamespace: y,
                checkProviderIdentity: w,
                eip6963Provider: m,
              } = h,
              b = i[f],
              I = b === !1,
              E = m || window[y],
              T = xB(E, w, t),
              B = !1;
            Array.isArray(b) &&
              (b.includes(t.type) || (t.os && b.includes(t.os.name))) &&
              (B = !0),
              b === "unavailable" && !T && (B = !0);
            let L =
              !g.includes("all") &&
              t.type !== null &&
              !g.includes(t.type) &&
              !g.includes(t.os.name);
            return (
              !I &&
                !B &&
                !L &&
                (T ||
                  s === !0 ||
                  (Array.isArray(s) && s.length && s.includes(h.label))) &&
                l.push(
                  (s === !0 ||
                    (Array.isArray(s) && s.length && s.includes(h.label))) &&
                    !T
                    ? $(v({}, h), {
                        getInterface: () =>
                          d(this, null, function* () {
                            throw new Error(a ? a(h) : EB(h));
                          }),
                      })
                    : h
                ),
              l
            );
          },
          []
        );
      if (u.length) {
        let l = u.length > 1,
          h = u
            .filter((f) => {
              let { label: g } = f;
              return !(g === se.Detected && l);
            })
            .map(({ label: f, getIcon: g, getInterface: y }) => ({
              label: f,
              getIcon: g,
              getInterface: y,
            }))
            .sort((f, g) =>
              f.label < g.label ? -1 : f.label > g.label ? 1 : 0
            );
        return o ? o(h) : h;
      }
      return [];
    }
  );
}
var CB = tW;
p();
var nW = () =>
    d(void 0, null, function* () {
      if (jg) return yield jg;
      let { createEIP1193Provider: n } = yield import("./chunk-7IKKQ2EQ.js"),
        e = yield import("./chunk-I5FOSSVC.js"),
        t = e.MetaMaskSDK || e.default.MetaMaskSDK;
      if (!t) throw new Error("Error importing and initializing MetaMask SDK");
      return { createEIP1193Provider: n, MetaMaskSDKConstructor: t };
    }),
  jg = null,
  wr = null;
function rW({ options: n }) {
  return () => (
    (jg = nW().catch((e) => {
      throw e;
    })),
    {
      label: "MetaMask",
      getIcon: () =>
        d(this, null, function* () {
          return (yield import("./chunk-7ZZRS4BA.js")).default;
        }),
      getInterface: (t) =>
        d(this, [t], function* ({ appMetadata: e }) {
          var r, i;
          if (((wr = window.mmsdk || wr), wr))
            return { provider: wr.getProvider(), instance: wr };
          let { name: s, icon: o } = e || {},
            c = `data:image/svg+xml;base64,${window.btoa(o || "")}`,
            u = yield jg;
          if (!u?.MetaMaskSDKConstructor)
            throw new Error("Error importing and initializing MetaMask SDK");
          let { MetaMaskSDKConstructor: l } = u;
          (wr = new l(
            $(v({}, n), {
              dappMetadata: {
                name:
                  ((r = n.dappMetadata) === null || r === void 0
                    ? void 0
                    : r.name) ||
                  s ||
                  "",
                url:
                  ((i = n.dappMetadata) === null || i === void 0
                    ? void 0
                    : i.url) || window.location.origin,
                base64Icon: c,
              },
              _source: "web3-onboard",
            })
          )),
            yield wr.init();
          let h = wr.getProvider();
          return (
            h &&
              (h.disconnect = () => {
                wr?.terminate();
              }),
            { provider: h, instance: wr }
          );
        }),
    }
  );
}
var kB = rW;
p();
p();
var Bn = Et(um(), 1),
  iW = Bn.default.object({
    handleUri: Bn.default.func().optional(),
    version: Bn.default
      .number()
      .optional()
      .custom((n, e) => {
        if (n === 1)
          console.warn(
            "Version 1 of WalletConnect has been fully deprecated. This version of @web3-onboard/walletconnect only supports version 2"
          );
        else if (n !== 2 && n !== void 0)
          return e.error("any.invalid", {
            message:
              "Invalid version number. This version of @web3-onboard/walletconnect only supports version 2",
          });
        return n;
      }, "Custom version validation"),
    projectId: Bn.default
      .string()
      .messages({
        "any.required":
          "WalletConnect version 2 requires a projectId. Please visit https://cloud.walletconnect.com to get one.",
      }),
    dappUrl: Bn.default
      .string()
      .optional()
      .custom(
        (n, e) =>
          n ||
          e.message({
            message:
              "It is strongly recommended to supply a dappUrl as it is required by some wallets (i.e. MetaMask) to allow connection.",
            type: "any.custom",
          }),
        "Custom dappUrl validation"
      ),
    requiredChains: Bn.default.array().items(Bn.default.number()).optional(),
    optionalChains: Bn.default.array().items(Bn.default.number()).optional(),
    qrModalOptions: Bn.default.object().optional(),
    additionalRequiredMethods: Bn.default
      .array()
      .items(Bn.default.string())
      .optional(),
    additionalOptionalMethods: Bn.default
      .array()
      .items(Bn.default.string())
      .optional(),
  }),
  sW = (n, e) => {
    let t = n.validate(e);
    return t.error ? t : null;
  },
  TB = (n) => sW(iW, n);
p();
var RB = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "personal_sign",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v4",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
];
function oW(n) {
  if (!n.projectId)
    throw new Error(
      "WalletConnect requires a projectId. Please visit https://cloud.walletconnect.com to get one."
    );
  n.dappUrl ||
    console.warn(
      "It is strongly recommended to supply a dappUrl to the WalletConnect init object as it is required by some wallets (i.e. MetaMask) to allow connection."
    );
  let {
      projectId: e,
      handleUri: t,
      requiredChains: r,
      optionalChains: i,
      qrModalOptions: s,
      additionalRequiredMethods: o,
      additionalOptionalMethods: a,
      dappUrl: c,
    } = n,
    u;
  return () => ({
    label: "WalletConnect",
    getIcon: () =>
      d(this, null, function* () {
        return (yield import("./chunk-UHEVSGZL.js")).default;
      }),
    getInterface: (g) =>
      d(this, [g], function* ({ chains: l, EventEmitter: h, appMetadata: f }) {
        let { ProviderRpcError: y, ProviderRpcErrorCode: w } = yield import(
            "./chunk-7IKKQ2EQ.js"
          ),
          { default: m, REQUIRED_METHODS: b } = yield import(
            "./chunk-PK52EPDI.js"
          ),
          { Subject: I, fromEvent: E } = yield import("./chunk-AIDIPZOB.js"),
          { takeUntil: T, take: B } = yield import("./chunk-JF2NTQ23.js"),
          L = () => {
            if (!f) return;
            let q = c || f.explore || "";
            !q &&
              !q.length &&
              console.warn(
                "It is strongly recommended to supply a dappUrl as it is required by some wallets (i.e. MetaMask) to allow connection."
              );
            let F = {
              name: f.name,
              description: f.description || "",
              url: q,
              icons: [],
            };
            return (
              f.icon !== void 0 && f.icon.length && (F.icons = [f.icon]),
              f.logo !== void 0 &&
                f.logo.length &&
                (F.icons = F.icons.length ? [...F.icons, f.logo] : [f.logo]),
              F
            );
          },
          U =
            Array.isArray(r) && r.length && r.every((q) => !isNaN(q))
              ? r.map((q) => parseInt(q))
              : [],
          j =
            Array.isArray(i) && i.length && i.every((q) => !isNaN(q))
              ? i.map((q) => parseInt(q))
              : l.map(({ id: q }) => parseInt(q, 16)),
          W = new Set(o && Array.isArray(o) ? [...o, ...b] : b),
          be = Array.from(W),
          pe = a && Array.isArray(a) ? [...a, ...RB] : RB,
          ge = yield m.init({
            projectId: e,
            chains: U,
            methods: be,
            optionalChains: j,
            optionalMethods: pe,
            showQrModal: !0,
            rpcMap: l
              .map(({ id: q, rpcUrl: F }) => ({ id: q, rpcUrl: F }))
              .reduce(
                (q, { id: F, rpcUrl: O }) => (
                  (q[parseInt(F, 16)] = O || ""), q
                ),
                {}
              ),
            metadata: L(),
            qrModalOptions: s,
          }),
          _e = new h();
        class X {
          constructor({ connector: F, chains: O }) {
            (this.emit = _e.emit.bind(_e)),
              (this.on = _e.on.bind(_e)),
              (this.removeListener = _e.removeListener.bind(_e)),
              (this.connector = F),
              (this.chains = O),
              (this.disconnected$ = new I()),
              E(this.connector, "accountsChanged", (H) => H)
                .pipe(T(this.disconnected$))
                .subscribe({
                  next: (H) => {
                    let he = Array.isArray(H) ? H : [H];
                    this.emit("accountsChanged", he);
                  },
                  error: console.warn,
                }),
              E(this.connector, "chainChanged", (H) => H)
                .pipe(T(this.disconnected$))
                .subscribe({
                  next: (H) => {
                    let he = Wg(H) ? H : `0x${H.toString(16)}`;
                    this.emit("chainChanged", he);
                  },
                  error: console.warn,
                }),
              E(this.connector, "session_delete", (H) => H)
                .pipe(T(this.disconnected$))
                .subscribe({
                  next: () => {
                    this.emit("accountsChanged", []),
                      this.disconnected$.next(!0),
                      typeof localStorage < "u" &&
                        localStorage.removeItem("walletconnect");
                  },
                  error: console.warn,
                }),
              (this.disconnect = () => {
                this.connector.session &&
                  (this.connector.disconnect(), (u = null));
              }),
              n &&
                t &&
                E(this.connector, "display_uri", (H) => H)
                  .pipe(T(this.disconnected$))
                  .subscribe((H) =>
                    d(this, null, function* () {
                      try {
                        t && (yield t(H));
                      } catch (he) {
                        throw `An error occurred when handling the URI. Error: ${he}`;
                      }
                    })
                  ),
              (() => {
                let H = this.connector.session;
                (u = H),
                  H &&
                    (this.emit("accountsChanged", this.connector.accounts),
                    this.emit("chainChanged", this.connector.chainId));
              })(),
              (this.request = (Ee) =>
                d(this, [Ee], function* ({ method: H, params: he }) {
                  if (H === "eth_chainId")
                    return Wg(this.connector.chainId)
                      ? this.connector.chainId
                      : `0x${this.connector.chainId.toString(16)}`;
                  if (H === "eth_requestAccounts")
                    return new Promise((Se, Pe) =>
                      d(this, null, function* () {
                        if (
                          (E(this.connector, "connect", (ye) => ye)
                            .pipe(B(1))
                            .subscribe({
                              next: ({ chainId: ye }) => {
                                this.emit(
                                  "accountsChanged",
                                  this.connector.accounts
                                );
                                let ze = Wg(ye) ? ye : `0x${ye.toString(16)}`;
                                this.emit("chainChanged", ze),
                                  Se(this.connector.accounts);
                              },
                              error: Pe,
                            }),
                          !this.connector.session)
                        )
                          yield this.connector.connect().catch((ye) => {
                            console.error("err creating new session: ", ye),
                              Pe(
                                new y({
                                  code: 4001,
                                  message: "User rejected the request.",
                                })
                              );
                          });
                        else {
                          let ye = this.connector.accounts,
                            ze = this.connector.chainId;
                          u = this.connector.session;
                          let nt = `0x${ze.toString(16)}`;
                          return this.emit("chainChanged", nt), Se(ye);
                        }
                      })
                    );
                  if (H === "eth_selectAccounts")
                    throw new y({
                      code: w.UNSUPPORTED_METHOD,
                      message: `The Provider does not support the requested method: ${H}`,
                    });
                  if (H == "wallet_switchEthereumChain") {
                    if (!he)
                      throw new y({
                        code: w.INVALID_PARAMS,
                        message:
                          "The Provider requires a chainId to be passed in as an argument",
                      });
                    let Se = he[0];
                    if (
                      !Se.hasOwnProperty("chainId") ||
                      typeof Se.chainId > "u"
                    )
                      throw new y({
                        code: w.INVALID_PARAMS,
                        message:
                          "The Provider requires a chainId to be passed in as an argument",
                      });
                    return this.connector.request({
                      method: "wallet_switchEthereumChain",
                      params: [{ chainId: Se.chainId }],
                    });
                  }
                  return this.connector.request({ method: H, params: he });
                }));
          }
        }
        return { provider: new X({ chains: l, connector: ge }), instance: u };
      }),
  });
}
var BB = oW;
var Wg = (n) => !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/));
function aW(n) {
  if (!n)
    throw new Error(
      "WalletConnect requires an initialization object to be passed - see the official docs for an example: https://onboard.blocknative.com/docs/wallets/walletconnect"
    );
  if (n) {
    let e = TB(n);
    if (e) throw e;
  }
  return BB(n);
}
var DB = aW;
p();
var PA = new Ae("chains-config"),
  Cae = () => ({
    provide: PA,
    useValue: [
      {
        id: 8453,
        token: "ETH",
        label: "Base Mainnet",
        rpcUrl: "https://mainnet.base.org",
        blockExplorerUrl: "https://base.blockscout.com/",
        icon: "https://basescan.org/assets/base/images/svg/logos/chain-light.svg",
        color: "#FFFFFF",
      },
      {
        id: 1,
        token: "ETH",
        label: "Ethereum Mainnet",
        rpcUrl: "https://mainnet.infura.io",
        blockExplorerUrl: "https://etherscan.io/",
        icon: "https://etherscan.io/images/svg/brands/ethereum-original.svg",
        color: "#FFFFFF",
      },
      {
        id: 137,
        token: "POL",
        label: "Polygon Mainnet",
        rpcUrl: "https://polygon.llamarpc.com",
        blockExplorerUrl: "https://polygonscan.com/",
        icon: "https://polygonscan.com/assets/poly/images/svg/logos/chain-light.svg?v=25.1.4.0",
        color: "#FFFFFF",
      },
      {
        id: 324,
        token: "ETH",
        label: "zkSync Era Mainnet",
        rpcUrl: "https://mainnet.era.zksync.io",
        blockExplorerUrl: "https://explorer.zksync.io/",
        icon: "https://zksync.io/favicon.ico",
        color: "#FFFFFF",
      },
      {
        id: 10,
        token: "ETH",
        label: "OP Mainnet",
        rpcUrl: "https://optimism-mainnet.infura.io",
        blockExplorerUrl: "https://optimistic.etherscan.io/",
        icon: "https://optimistic.etherscan.io/assets/optimism/images/svg/logos/chain-light.svg?v=25.1.4.0",
        color: "#FFFFFF",
      },
      {
        id: 42161,
        token: "ETH",
        label: "Arbitrum One",
        rpcUrl: "https://arb1.arbiturum.io/rpc",
        blockExplorerUrl: "https://arbiscan.io/",
        icon: "https://arbiscan.io/assets/arbitrum/images/svg/logos/chain-light.svg?v=25.1.4.0",
        color: "#FFFFFF",
      },
    ],
  });
var Ih = class n {
  static PROVIDER_KEY = "AI_PUMP_LAST_USED_PROVIDER";
  #e = M(PA);
  #t = M(Er);
  #n = hm({
    wallets: [
      CB(),
      kB({ options: {} }),
      DB({
        projectId: "037f5e845b905b8845f4db6035c71705",
        dappUrl: window.location.origin,
        requiredChains: this.#e.map((e) => e.id),
        qrModalOptions: { themeVariables: { "--wcm-z-index": "1100" } },
      }),
    ],
    chains: this.#e,
    theme: "dark",
    accountCenter: {
      desktop: { enabled: !0, minimal: !0, position: "bottomRight" },
      mobile: { enabled: !0, minimal: !0, position: "bottomRight" },
    },
    appMetadata: {
      name: "AI Pump",
      description: "AI Pump",
      icon: "favicon.ico",
      logo: "images/logo.png",
      recommendedInjectedWallets: [
        { name: "MetaMask", url: "https://metamask.io" },
      ],
    },
  });
  activeWallet$ = this.#n.state.select("wallets").pipe(
    Iu(
      (e, t) => (
        e.length && !t.length && localStorage.removeItem(n.PROVIDER_KEY), !1
      )
    ),
    xe((e) => e.at(0)),
    Oe((e) => {
      let t = e?.label;
      t && localStorage.setItem(n.PROVIDER_KEY, t);
    }),
    Iu(),
    fa(1)
  );
  constructor() {
    this.reconnect();
  }
  reconnect() {
    return d(this, null, function* () {
      let e = localStorage.getItem(n.PROVIDER_KEY);
      console.log("lastConnectedProvider", e),
        e &&
          (yield this.#n.connectWallet({
            autoSelect: { label: e, disableModals: !0 },
          }));
    });
  }
  connect() {
    return this.#n.connectWallet();
  }
  disconnect() {
    return this.#n.state.get().wallets.forEach((e) => {
      this.#n.disconnectWallet({ label: e.label });
    });
  }
  setFirstChain() {
    let e = this.#e.at(0);
    if (!e) throw new Error("[Web3OnboardService] No chains config");
    return this.setChain(e.id);
  }
  setChain(e) {
    return Ke(this.#n.setChain({ chainId: e })).pipe(
      ct((t) =>
        t ? oe(!0) : Tt(() => new Error("[Web3OnboardService] Chain not set"))
      )
    );
  }
  static ɵfac = function (t) {
    return new (t || n)();
  };
  static ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
};
var cW = { evmWallet: null, solanaWallet: null },
  Qae = rI(
    { providedIn: "root" },
    aI(cW),
    iI(({ evmWallet: n, solanaWallet: e }) => ({
      isEvmConnected: Pn(() => !!n()),
      isSolanaConnected: Pn(() => !!e()),
      isConnected: Pn(() => !!n() || !!e()),
      address: Pn(() => n()?.address ?? e()?.address),
      chainId: Pn(() => n()?.chainId ?? 900),
      walletType: Pn(() => (n() ? "EVM" : e() ? "SOLANA" : null)),
    })),
    oI((n, e = M(An), t = M(Ih)) => ({
      signMessage: (r) => {
        let i = n.evmWallet(),
          s = n.solanaWallet();
        if (i)
          return pn(() => i.provider.getSigner()).pipe(
            ct((o) => o.signMessage(r))
          );
        if (s) {
          let o = new TextEncoder().encode(r);
          return e.signMessage(o).pipe(xe((a) => _B.default.encode(a)));
        } else throw new Error("[WalletStore] No wallet connected");
      },
      handleEvmTransaction: (c) =>
        d(
          void 0,
          [c],
          function* ({ chainId: r, from: i, to: s, value: o, data: a }) {
            let u = n.evmWallet();
            if (!u) throw new Error("[WalletStore] No EVM wallet connected");
            let h = yield u.provider.getSigner();
            yield vu(t.setChain(r));
            let f = yield h.sendTransaction({
              chainId: r,
              from: i,
              to: s,
              value: o,
              data: a,
            });
            return yield f.wait(), f.hash;
          }
        ),
    })),
    sI((n, e = M(Ih), t = M(An)) => ({
      onInit() {
        return d(this, null, function* () {
          t.publicKey$.pipe(ao()).subscribe((i) => {
            let s = i?.toString();
            s
              ? Rl(n, (o) => ({ solanaWallet: { address: s, service: t } }))
              : Rl(n, (o) => ({ solanaWallet: null }));
          }),
            e.activeWallet$.pipe(ao()).subscribe((i) => {
              let s = i?.chains.at(0)?.id ?? null,
                o = s ? parseInt(s) : null,
                a = i?.accounts.at(0)?.address ?? null,
                c = i && o ? new mc(i.provider, o) : null;
              o && a && c
                ? Rl(n, (u) => ({
                    evmWallet: {
                      chainId: o,
                      address: a,
                      provider: c,
                      setFirstChain: () => e.setFirstChain(),
                    },
                  }))
                : Rl(n, (u) => ({ evmWallet: null }));
            });
        });
      },
    }))
  );
p();
p();
var LA = new Pu(() => !1),
  PB = new Pu(() => !1);
var LB = class n {
  #e = M(Om);
  #t = new Sa().set(LA, !0);
  #n = new Sa().set(PB, !0).set(LA, !0);
  auth = {
    signature: (e, t, r, i) =>
      this.#e.post(
        "/auth/signature",
        { signature: e, signatureTimestamp: t, wallet: r, walletType: i },
        { context: this.#t }
      ),
  };
  agent = {
    get: (e) => this.#e.get(`/agent/${e}`, { context: this.#t }),
    getSignedUrlVoiceChat: (e) =>
      this.#e.get(`/agent/${e}/voice/url`, { context: this.#t }),
    getAiPump: () => this.#e.get("/agent/ai-pump", { context: this.#t }),
    list: (e, t, r) =>
      this.#e.get(`/agent${e ? "/" + e : ""}/list-internal`, {
        params: new ur()
          .set("search", t)
          .set("page", r.page.toString())
          .set("perPage", r.perPage.toString())
          .set("filterBy", r.filter),
        context: this.#t,
      }),
    create: (e) => this.#e.post("/agent", e, { context: this.#n }),
    update: (e, t) => this.#e.put(`/agent/${t}`, e, { context: this.#n }),
    setToken: (e, t, r) =>
      this.#e.put(
        `/agent/${e}/token`,
        { token: t, chainId: r },
        { context: this.#n }
      ),
    getTelegramConnectionData: (e) =>
      this.#e.get(`/agent/${e}/telegram/connect`, { context: this.#n }),
    getTweets: (e, t) =>
      this.#e.get(`/agent/${e}/twitter?page=${t}&perPage=5`, {
        context: this.#t,
      }),
    spotlight: () => this.#e.get("/agent/spotlight", { context: this.#t }),
  };
  s3 = { getPresignedUrl: () => this.#e.get("/file", { context: this.#t }) };
  twitter = {
    connect: (e, t) =>
      this.#e.post(`/agent/${t}/twitter`, e, { context: this.#n }),
  };
  telegram = {
    connectStep1: (e, t) =>
      this.#e.post(`/agent/${t}/telegram/1`, e, { context: this.#n }),
    connectStep2: (e, t) =>
      this.#e.post(`/agent/${t}/telegram/2`, e, { context: this.#n }),
  };
  holders = {
    get: (e, t) =>
      this.#e.get("/token-holders", {
        params: new ur().set("tokenAddress", e).set("chainId", t.toString()),
        context: this.#t,
      }),
  };
  pools = {
    get: (e) =>
      this.#e.get("/get-pool", {
        params: new ur().set("token", e),
        context: this.#t,
      }),
  };
  tokensPrice = {
    get: () => this.#e.get("/token/price", { context: this.#t }),
  };
  analyticsData = {
    get: () => this.#e.get("/analytics", { context: this.#t }),
  };
  static ɵfac = function (t) {
    return new (t || n)();
  };
  static ɵprov = ae({ token: n, factory: n.ɵfac, providedIn: "root" });
};
export {
  Aa as a,
  Vt as b,
  xa as c,
  IW as d,
  CW as e,
  kW as f,
  TW as g,
  RW as h,
  BW as i,
  DW as j,
  _W as k,
  PW as l,
  pD as m,
  mD as n,
  LW as o,
  ss as p,
  Om as q,
  qW as r,
  QW as s,
  w1 as t,
  bH as u,
  b_ as v,
  Da as w,
  Y_ as x,
  Er as y,
  WH as z,
  HH as A,
  VH as B,
  $H as C,
  PA as D,
  Cae as E,
  Ih as F,
  wx as G,
  ao as H,
  wL as I,
  Ii as J,
  NL as K,
  xV as L,
  SV as M,
  Rl as N,
  rI as O,
  iI as P,
  sI as Q,
  oI as R,
  aI as S,
  W0 as T,
  H0 as U,
  Xx as V,
  eS as W,
  Qr as X,
  yS as Y,
  Pr as Z,
  ud as _,
  Fw as $,
  QC as aa,
  J as ba,
  tt as ca,
  Ne as da,
  Up as ea,
  $i as fa,
  ii as ga,
  qc as ha,
  hb as ia,
  an as ja,
  eh as ka,
  Hp as la,
  rh as ma,
  U6 as na,
  tu as oa,
  An as pa,
  Qz as qa,
  noe as ra,
  coe as sa,
  moe as ta,
  Qae as ua,
  LA as va,
  PB as wa,
  LB as xa,
};
